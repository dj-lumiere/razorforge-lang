/*
 * RazorForge Runtime - Memory Management
 * Native implementation of stack and heap slice operations
 */

#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>

// Type aliases for RazorForge integration
typedef uintptr_t uaddr;
typedef size_t rf_size_t;

/*
 * Heap allocation with error handling
 */
uaddr heap_alloc(uaddr bytes)
{
    void* ptr = malloc(bytes);
    if (!ptr)
    {
        fprintf(stderr, "RazorForge: Failed to allocate %zu bytes\n", (size_t)bytes);
        return 0;
    }

    // Zero-initialize allocated memory for safety
    memset(ptr, 0, bytes);
    return (uaddr)ptr;
}

/*
 * Heap deallocation
 */
void heap_free(uaddr address)
{
    if (address == 0)
    {
        return; // Null pointer, safe to ignore
    }

    free((void*)address);
}

/*
 * Heap reallocation
 */
uaddr heap_realloc(uaddr address, uaddr new_bytes)
{
    void* old_ptr = (void*)address;
    void* new_ptr = realloc(old_ptr, new_bytes);

    if (!new_ptr && new_bytes != 0)
    {
        fprintf(stderr, "RazorForge: Failed to reallocate to %zu bytes\n", (size_t)new_bytes);
        return 0;
    }

    return (uaddr)new_ptr;
}

/*
 * Generic memory copy operation
 */
void memory_copy(uaddr src_address, uaddr dst_address, uaddr bytes)
{
    if (src_address == 0 || dst_address == 0 || bytes == 0)
    {
        return;
    }

    void* src = (void*)src_address;
    void* dst = (void*)dst_address;

    memmove(dst, src, bytes); // Use memmove for overlapping regions
}

/*
 * Memory read operations (generic template will be specialized in LLVM)
 */
void memory_read_bytes(uaddr address, void* output, uaddr bytes)
{
    if (address == 0 || output == NULL || bytes == 0)
    {
        return;
    }

    memcpy(output, (void*)address, bytes);
}

/*
 * Memory write operations (generic template will be specialized in LLVM)
 */
void memory_write_bytes(uaddr address, const void* input, uaddr bytes)
{
    if (address == 0 || input == NULL || bytes == 0)
    {
        return;
    }

    memcpy((void*)address, input, bytes);
}

/*
 * Type size lookup table for common RazorForge types
 * This will be generated by the compiler for each program
 */
uaddr get_type_size(const char* type_name)
{
    // Basic types
    if (strcmp(type_name, "s8") == 0) return 1;
    if (strcmp(type_name, "u8") == 0) return 1;
    if (strcmp(type_name, "s16") == 0) return 2;
    if (strcmp(type_name, "u16") == 0) return 2;
    if (strcmp(type_name, "s32") == 0) return 4;
    if (strcmp(type_name, "u32") == 0) return 4;
    if (strcmp(type_name, "s64") == 0) return 8;
    if (strcmp(type_name, "u64") == 0) return 8;
    if (strcmp(type_name, "s128") == 0) return 16;
    if (strcmp(type_name, "u128") == 0) return 16;
    if (strcmp(type_name, "saddr") == 0) return sizeof(intptr_t);
    if (strcmp(type_name, "uaddr") == 0) return sizeof(uintptr_t);

    // Float types
    if (strcmp(type_name, "f16") == 0) return 2;
    if (strcmp(type_name, "f32") == 0) return 4;
    if (strcmp(type_name, "f64") == 0) return 8;
    if (strcmp(type_name, "f128") == 0) return 16;

    // Decimal types
    if (strcmp(type_name, "d32") == 0) return 4;
    if (strcmp(type_name, "d64") == 0) return 8;
    if (strcmp(type_name, "d128") == 0) return 16;

    // Text types
    if (strcmp(type_name, "letter") == 0) return 4; // UTF-32
    if (strcmp(type_name, "text") == 0) return sizeof(void*); // Pointer to text data

    // Boolean
    if (strcmp(type_name, "bool") == 0) return 1;

    // Default to pointer size for unknown types
    return sizeof(void*);
}

/*
 * Runtime bounds checking function
 */
void rf_bounds_check(uaddr index, uaddr length, const char* operation)
{
    if (index >= length)
    {
        fprintf(stderr, "RazorForge Runtime Error: Index %zu out of bounds for %s (length %zu)\n",
                (size_t)index, operation, (size_t)length);
        abort();
    }
}

/*
 * Runtime crash function for unrecoverable errors
 */
void rf_crash(const char* message)
{
    fprintf(stderr, "RazorForge Runtime Crash: %s\n", message);
    abort();
}

/*
 * Danger zone operations - raw memory access without safety checks
 * These functions bypass all bounds checking and safety mechanisms
 * Only available within danger! blocks
 */

/*
 * Read typed value from arbitrary memory address (danger! only)
 */
void read_as_bytes(uaddr address, void* output, uaddr bytes)
{
    if (address == 0 || output == NULL || bytes == 0)
    {
        return;
    }
    memcpy(output, (void*)address, bytes);
}

/*
 * Write typed value to arbitrary memory address (danger! only)
 */
void write_as_bytes(uaddr address, const void* input, uaddr bytes)
{
    if (address == 0 || input == NULL || bytes == 0)
    {
        return;
    }
    memcpy((void*)address, input, bytes);
}

/*
 * Volatile read for memory-mapped I/O (danger! only)
 */
void volatile_read_bytes(uaddr address, void* output, uaddr bytes)
{
    if (address == 0 || output == NULL || bytes == 0)
    {
        return;
    }
    volatile char* src = (volatile char*)address;
    char* dst = (char*)output;
    for (uaddr i = 0; i < bytes; i++)
    {
        dst[i] = src[i];
    }
}

/*
 * Volatile write for memory-mapped I/O (danger! only)
 */
void volatile_write_bytes(uaddr address, const void* input, uaddr bytes)
{
    if (address == 0 || input == NULL || bytes == 0)
    {
        return;
    }
    volatile char* dst = (volatile char*)address;
    const char* src = (const char*)input;
    for (uaddr i = 0; i < bytes; i++)
    {
        dst[i] = src[i];
    }
}

/*
 * Get address of any object (danger! only)
 */
uaddr address_of(const void* object)
{
    return (uaddr)object;
}

/*
 * Force invalidate memory (danger! only)
 */
void invalidate_memory(uaddr address)
{
    if (address != 0)
    {
        free((void*)address);
    }
}

/*
 * Memory fill pattern operation
 */
void memory_fill(uaddr address, uaddr pattern_byte, uaddr bytes)
{
    if (address == 0 || bytes == 0)
    {
        return;
    }
    memset((void*)address, (int)(pattern_byte & 0xFF), bytes);
}

/*
 * Memory zero operation
 */
void memory_zero(uaddr address, uaddr bytes)
{
    if (address == 0 || bytes == 0)
    {
        return;
    }
    memset((void*)address, 0, bytes);
}

/*
 * Debug functions for memory slice inspection
 */
void debug_print_slice_info(uaddr address, uaddr bytes, uaddr length, const char* type_name)
{
    printf("Slice<%s> @ 0x%zx: %zu elements, %zu bytes\n",
           type_name, (size_t)address, (size_t)length, (size_t)bytes);
}

/*
 * Reference counting utilities
 */
uaddr* create_ref_counter(uaddr initial_count)
{
    uaddr* counter = (uaddr*)heap_alloc(sizeof(uaddr));
    if (counter)
    {
        *counter = initial_count;
    }
    return counter;
}

uaddr increment_ref_count(uaddr* counter)
{
    if (!counter) return 0;
    return ++(*counter);
}

uaddr decrement_ref_count(uaddr* counter)
{
    if (!counter) return 0;
    return --(*counter);
}

void free_ref_counter(uaddr* counter)
{
    if (counter)
    {
        heap_free((uaddr)counter);
    }
}

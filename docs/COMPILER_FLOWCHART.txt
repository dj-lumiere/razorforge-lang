# RazorForge Compiler - Visual Flow Diagrams
# Use these ASCII diagrams to understand compilation flow

================================================================================
                         MAIN COMPILATION PIPELINE
================================================================================

    â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
    â”ƒ                        SOURCE CODE INPUT                          â”ƒ
    â”ƒ                     (.rf files, .sf files)                        â”ƒ
    â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”¯â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›
                                   â”‚
                                   â”‚ File.ReadAllText()
                                   â–¼
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘            PHASE 1: TOKENIZATION (Lexer)                         â•‘
    â•‘                 src/Lexer/Tokenizer.cs                           â•‘
    â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
    â•‘  â€¢ Converts text â†’ List<Token>                                   â•‘
    â•‘  â€¢ Recognizes keywords, operators, literals                      â•‘
    â•‘  â€¢ Tracks source locations for errors                            â•‘
    â•‘                                                                  â•‘
    â•‘  Input:  "entity List<T> { ... }"                               â•‘
    â•‘  Output: [Entity, Identifier("List"), Less, Identifier("T"), ...]â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                   â”‚
                                   â”‚ Token stream
                                   â–¼
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘            PHASE 2: PARSING (Parser)                             â•‘
    â•‘            src/Parser/RazorForgeParser.cs                        â•‘
    â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
    â•‘  â€¢ Builds Abstract Syntax Tree (AST)                             â•‘
    â•‘  â€¢ Validates syntax structure                                    â•‘
    â•‘  â€¢ Handles generic syntax: entity List<T>          âœ…            â•‘
    â•‘  â€¢ Parses imports: import Collections/List         âœ…            â•‘
    â•‘                                                                  â•‘
    â•‘  Key Methods:                                                    â•‘
    â•‘    - ParseDeclaration()        (Line 45)                         â•‘
    â•‘    - ParseGenericParameters()  (Line 425)                        â•‘
    â•‘    - ParseImportDeclaration()  (Line 269)                        â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                   â”‚
                                   â”‚ AST
                                   â–¼
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘         PHASE 3: SEMANTIC ANALYSIS (Type Checking)               â•‘
    â•‘         src/Analysis/SemanticAnalyzer.cs                         â•‘
    â•‘         src/Analysis/SymbolTable.cs                              â•‘
    â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
    â•‘  â€¢ Type checking and inference                                   â•‘
    â•‘  â€¢ Symbol resolution                                             â•‘
    â•‘  â€¢ Generic type resolution                        âš ï¸ Partial     â•‘
    â•‘  â€¢ Import resolution                              âŒ TODO        â•‘
    â•‘  â€¢ Memory safety analysis                         âœ…             â•‘
    â•‘                                                                  â•‘
    â•‘  Key Methods:                                                    â•‘
    â•‘    - ResolveGenericType()      (Line 1353)                       â•‘
    â•‘    - VisitImportDeclaration()  (Line 523) â† TODO!               â•‘
    â•‘    - BindGenericArguments()    (Line 1389)                       â•‘
    â•‘                                                                  â•‘
    â•‘  Errors collected in: SemanticAnalyzer.Errors                    â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                   â”‚
                                   â”‚ Validated AST
                                   â”‚
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚                                   â”‚
                 â–¼                                   â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  PHASE 4A: SIMPLE CODEGENâ”‚      â”‚  PHASE 4B: LLVM CODEGEN  â”‚
    â”‚  SimpleCodeGenerator.cs  â”‚      â”‚  LLVMCodeGenerator.cs    â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ â€¢ Readable output        â”‚      â”‚ â€¢ LLVM IR generation     â”‚
    â”‚ â€¢ For debugging          â”‚      â”‚ â€¢ Generic monomorphizationâ”‚
    â”‚ â€¢ .out file              â”‚      â”‚ â€¢ .ll file               â”‚
    â”‚                          â”‚      â”‚                          â”‚
    â”‚ Example:                 â”‚      â”‚ Example:                 â”‚
    â”‚ routine add(a, b) {      â”‚      â”‚ define i32 @add(i32, i32)â”‚
    â”‚   return a + b            â”‚      â”‚ {                        â”‚
    â”‚ }                        â”‚      â”‚   %1 = add i32 %0, %1    â”‚
    â”‚                          â”‚      â”‚   ret i32 %1             â”‚
    â”‚                          â”‚      â”‚ }                        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                 â”‚
                                                 â”‚ LLVM IR
                                                 â–¼
                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                    â”‚   PHASE 5: COMPILATION  â”‚
                                    â”‚   (clang)               â”‚
                                    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                                    â”‚ â€¢ Compiles LLVM IR      â”‚
                                    â”‚ â€¢ Optimizes code        â”‚
                                    â”‚ â€¢ Links libraries       â”‚
                                    â”‚ â€¢ Generates executable  â”‚
                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                               â”‚
                                               â–¼
                                    â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
                                    â”ƒ  EXECUTABLE OUTPUT  â”ƒ
                                    â”ƒ    (.exe / .out)    â”ƒ
                                    â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

================================================================================
                       GENERIC TYPE PROCESSING FLOW
================================================================================

Source Code:
    entity List<T> {
        routine push(value: T) { ... }
    }

    let list: List<s32> = List<s32>()


Step 1: PARSING
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ RazorForgeParser.ParseClassDeclaration() - Line 425           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                â”‚
â”‚  Sees: entity List<T>                                          â”‚
â”‚                                                                â”‚
â”‚  1. Consume "entity" keyword                                   â”‚
â”‚  2. Read identifier "List"                                     â”‚
â”‚  3. See '<' token â†’ ParseGenericParameters()                   â”‚
â”‚  4. Extract parameter names: ["T"]                             â”‚
â”‚  5. Consume '>' token                                          â”‚
â”‚  6. Parse body {...}                                           â”‚
â”‚                                                                â”‚
â”‚  Creates:                                                      â”‚
â”‚    ClassDeclaration(                                           â”‚
â”‚      Name: "List",                                             â”‚
â”‚      GenericParameters: ["T"],  âœ…                              â”‚
â”‚      Members: [...]                                            â”‚
â”‚    )                                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â”‚ AST with generic declaration
                            â–¼
Step 2: SEMANTIC ANALYSIS (Declaration Phase)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SemanticAnalyzer.VisitClassDeclaration() - Line 678           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                â”‚
â”‚  1. Create ClassSymbol:                                        â”‚
â”‚       ClassSymbol(                                             â”‚
â”‚         Name: "List",                                          â”‚
â”‚         GenericParameters: ["T"],  âœ…                           â”‚
â”‚         IsGeneric: true            âœ…                           â”‚
â”‚       )                                                        â”‚
â”‚                                                                â”‚
â”‚  2. Add to symbol table                                        â”‚
â”‚  3. Enter new scope for class body                             â”‚
â”‚  4. Add "T" as type parameter in scope                         â”‚
â”‚  5. Visit members (push method sees "T" as valid type)         â”‚
â”‚                                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â”‚ Symbol table populated
                            â–¼
Step 3: SEMANTIC ANALYSIS (Usage Phase)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SemanticAnalyzer - Resolve List<s32>                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                â”‚
â”‚  Sees: List<s32>                                               â”‚
â”‚                                                                â”‚
â”‚  1. Look up "List" â†’ finds ClassSymbol                         â”‚
â”‚  2. Check IsGeneric â†’ true âœ…                                   â”‚
â”‚  3. GenericParameters count â†’ 1                                â”‚
â”‚  4. GenericArguments count â†’ 1 âœ…                               â”‚
â”‚  5. Bind: T â†’ s32                                              â”‚
â”‚                                                                â”‚
â”‚  Creates:                                                      â”‚
â”‚    TypeInfo(                                                   â”‚
â”‚      Name: "List",                                             â”‚
â”‚      GenericArguments: [TypeInfo("s32")],  âœ…                   â”‚
â”‚      IsReference: true                                         â”‚
â”‚    )                                                           â”‚
â”‚                                                                â”‚
â”‚  âš ï¸ TODO: Validate constraints on T                            â”‚
â”‚  âš ï¸ TODO: Cache instantiated types                             â”‚
â”‚                                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â”‚ Resolved generic type
                            â–¼
Step 4: CODE GENERATION
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LLVMCodeGenerator.MangleGenericName() - Line 201              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                â”‚
â”‚  Input: TypeInfo("List", [TypeInfo("s32")])                   â”‚
â”‚                                                                â”‚
â”‚  1. Start with base name: "List"                               â”‚
â”‚  2. For each generic argument:                                 â”‚
â”‚     - Append "_"                                               â”‚
â”‚     - Append argument name: "s32"                              â”‚
â”‚  3. Result: "List_s32"                                         â”‚
â”‚                                                                â”‚
â”‚  Generates LLVM IR:                                            â”‚
â”‚    %struct.List_s32 = type {                                   â”‚
â”‚      ptr,    ; data: DynamicSlice                              â”‚
â”‚      i64,    ; len: u64                                        â”‚
â”‚      i64     ; capacity: u64                                   â”‚
â”‚    }                                                           â”‚
â”‚                                                                â”‚
â”‚    define void @List_s32_push(                                 â”‚
â”‚      ptr %self, i32 %value) { ... }                           â”‚
â”‚                                                                â”‚
â”‚  âš ï¸ Currently only generates code for explicitly used types    â”‚
â”‚  âš ï¸ Full monomorphization not implemented                      â”‚
â”‚                                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


================================================================================
                        IMPORT/MODULE SYSTEM FLOW
================================================================================

Current Implementation (Partial):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Source Code:
    import Collections/List

    routine main() {
        let list = List<s32>()  â† Error: "List" not found!
    }


Step 1: PARSING âœ…
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ RazorForgeParser.ParseImportDeclaration() - Line 269          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                â”‚
â”‚  1. Consume "import" keyword                                   â”‚
â”‚  2. Read path segments:                                        â”‚
â”‚     - Read "Collections" (identifier)                          â”‚
â”‚     - See '/' â†’ append to path                                 â”‚
â”‚     - Read "List" (identifier)                                 â”‚
â”‚  3. Check for "as" alias (optional)                            â”‚
â”‚  4. Check for "{...}" selective imports (not implemented)      â”‚
â”‚                                                                â”‚
â”‚  Creates:                                                      â”‚
â”‚    ImportDeclaration(                                          â”‚
â”‚      ModulePath: "Collections/List",  âœ…                        â”‚
â”‚      Alias: null,                                              â”‚
â”‚      SpecificImports: null                                     â”‚
â”‚    )                                                           â”‚
â”‚                                                                â”‚
â”‚  âš ï¸ Issue: Can't handle keywords in path                       â”‚
â”‚     import Collections/entity/List â† fails                     â”‚
â”‚     ("entity" is keyword, not identifier)                      â”‚
â”‚                                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â”‚ AST node created
                            â–¼
Step 2: SEMANTIC ANALYSIS âŒ
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SemanticAnalyzer.VisitImportDeclaration() - Line 523          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                â”‚
â”‚  public object? VisitImportDeclaration(                        â”‚
â”‚      ImportDeclaration node)                                   â”‚
â”‚  {                                                             â”‚
â”‚      // TODO: Module system                                    â”‚
â”‚      return null;  â† DOES NOTHING!                             â”‚
â”‚  }                                                             â”‚
â”‚                                                                â”‚
â”‚  âŒ No file resolution                                         â”‚
â”‚  âŒ No symbol population                                       â”‚
â”‚  âŒ No transitive imports                                      â”‚
â”‚                                                                â”‚
â”‚  Result: "List" symbol never added to symbol table!            â”‚
â”‚                                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â”‚ Symbol not found!
                            â–¼
                   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
                   â”ƒ  COMPILATION ERROR â”ƒ
                   â”ƒ "Undefined: List" â”ƒ
                   â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›


Target Implementation (Needed):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Step 2: MODULE RESOLUTION (NEW)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ModuleResolver.Resolve() - To Be Implemented                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                â”‚
â”‚  Input: "Collections/List"                                     â”‚
â”‚                                                                â”‚
â”‚  1. Build search paths:                                        â”‚
â”‚     - Current directory                                        â”‚
â”‚     - stdlib directory                                         â”‚
â”‚     - Configured library paths                                 â”‚
â”‚                                                                â”‚
â”‚  2. Try paths:                                                 â”‚
â”‚     - ./Collections/List.rf         (not found)                â”‚
â”‚     - stdlib/Collections/List.rf    (FOUND!) âœ…                â”‚
â”‚                                                                â”‚
â”‚  3. Check cache: Has this module been loaded?                  â”‚
â”‚     - Yes â†’ return cached module                               â”‚
â”‚     - No â†’ continue to parsing                                 â”‚
â”‚                                                                â”‚
â”‚  4. Read file: stdlib/Collections/List.rf                      â”‚
â”‚  5. Parse file â†’ get AST                                       â”‚
â”‚  6. Create Module object:                                      â”‚
â”‚       Module(                                                  â”‚
â”‚         Path: "Collections/List",                              â”‚
â”‚         SourcePath: "stdlib/Collections/List.rf",              â”‚
â”‚         AST: [...],                                            â”‚
â”‚         Symbols: SymbolTable()                                 â”‚
â”‚       )                                                        â”‚
â”‚                                                                â”‚
â”‚  7. Process imports in that file (recursive)                   â”‚
â”‚     - List.rf imports memory/DynamicSlice                      â”‚
â”‚     - Resolve that import first                                â”‚
â”‚                                                                â”‚
â”‚  8. Cache module for reuse                                     â”‚
â”‚  9. Return Module object                                       â”‚
â”‚                                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â”‚ Module loaded
                            â–¼
Step 3: SYMBOL POPULATION (NEW)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SemanticAnalyzer.VisitImportDeclaration() - Enhanced          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                â”‚
â”‚  1. Get module from resolver                                   â”‚
â”‚     Module module = ModuleResolver.Resolve("Collections/List")â”‚
â”‚                                                                â”‚
â”‚  2. Extract exported symbols:                                  â”‚
â”‚     - Public entity List<T>       â†’ Add to symbol table        â”‚
â”‚     - Private members             â†’ Skip                       â”‚
â”‚                                                                â”‚
â”‚  3. Handle alias:                                              â”‚
â”‚     import Collections/List as CL                              â”‚
â”‚     â†’ Symbol accessible as "CL.List" or just "List"            â”‚
â”‚                                                                â”‚
â”‚  4. Handle selective imports:                                  â”‚
â”‚     import Collections { List, Dict }                          â”‚
â”‚     â†’ Only add List and Dict symbols                           â”‚
â”‚                                                                â”‚
â”‚  5. Track dependencies:                                        â”‚
â”‚     - For incremental compilation                              â”‚
â”‚     - For circular import detection                            â”‚
â”‚                                                                â”‚
â”‚  6. Symbol table now has:                                      â”‚
â”‚     ClassSymbol(                                               â”‚
â”‚       Name: "List",                                            â”‚
â”‚       GenericParameters: ["T"],                                â”‚
â”‚       IsImported: true,                                        â”‚
â”‚       SourceModule: "Collections/List"                         â”‚
â”‚     )                                                          â”‚
â”‚                                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â”‚ Symbols available!
                            â–¼
                   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
                   â”ƒ COMPILATION SUCCESSâ”ƒ
                   â”ƒ "List" resolved!  â”ƒ
                   â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›


================================================================================
                    SYMBOL TABLE SCOPE MANAGEMENT
================================================================================

Global Scope
â””â”€â”€ import Collections/List
    â”‚
    â”œâ”€â”€ Symbol: List<T> (imported)
    â”‚
    â””â”€â”€ routine main()
        â””â”€â”€ Local Scope (main)
            â”œâ”€â”€ Variable: list (List<s32>)
            â”‚   â””â”€â”€ Type resolved from imported symbol âœ…
            â”‚
            â””â”€â”€ Method call: list.push(42)
                â””â”€â”€ Resolved to: List<T>.push where T=s32 âœ…


Current Issue:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Global Scope
â””â”€â”€ import Collections/List  â† Parsed but ignored!
    â”‚
    â””â”€â”€ routine main()
        â””â”€â”€ Local Scope (main)
            â”œâ”€â”€ Variable: list (List<s32>)  â† Error!
            â”‚   â””â”€â”€ Symbol "List" not found âŒ
            â””â”€â”€ ...


================================================================================
                         DATA FLOW DIAGRAM
================================================================================

Program.cs
   â”‚
   â”œâ”€â”€> Tokenizer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> List<Token>
   â”‚                                         â”‚
   â”‚                                         â”‚
   â”œâ”€â”€> Parser â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> AST
   â”‚       â”‚                                 â”‚
   â”‚       â”‚ ParseGenericParameters() âœ…      â”‚
   â”‚       â”‚ ParseImportDeclaration() âœ…      â”‚
   â”‚       â”‚                                 â”‚
   â”‚                                         â”‚
   â”œâ”€â”€> SemanticAnalyzer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Validated AST + Errors
   â”‚       â”‚                                 â”‚
   â”‚       â”œâ”€> SymbolTable                   â”‚
   â”‚       â”‚    â”‚                            â”‚
   â”‚       â”‚    â”œâ”€> FunctionSymbol           â”‚
   â”‚       â”‚    â”‚    â””â”€> GenericParameters âœ…â”‚
   â”‚       â”‚    â”‚                            â”‚
   â”‚       â”‚    â””â”€> ClassSymbol              â”‚
   â”‚       â”‚         â””â”€> GenericParameters âœ…â”‚
   â”‚       â”‚                                 â”‚
   â”‚       â”œâ”€> ResolveGenericType() âš ï¸       â”‚
   â”‚       â”‚                                 â”‚
   â”‚       â””â”€> VisitImportDeclaration() âŒ   â”‚
   â”‚            (TODO: Module system)        â”‚
   â”‚                                         â”‚
   â”‚                                         â”‚
   â”œâ”€â”€> LLVMCodeGenerator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> LLVM IR (.ll)
   â”‚       â”‚                                 â”‚
   â”‚       â”œâ”€> MangleGenericName() âœ…        â”‚
   â”‚       â”‚    List<s32> â†’ List_s32         â”‚
   â”‚       â”‚                                 â”‚
   â”‚       â””â”€> Generic instantiation         â”‚
   â”‚            tracking âš ï¸                  â”‚
   â”‚                                         â”‚
   â”‚                                         â”‚
   â””â”€â”€> clang â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Executable


================================================================================
                         FEATURE CHECKLIST
================================================================================

GENERICS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Feature                â”‚ Status   â”‚ Location                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Parse entity<T>        â”‚ âœ… DONE  â”‚ RazorForgeParser.cs:425       â”‚
â”‚ Parse List<s32>        â”‚ âœ… DONE  â”‚ RazorForgeParser.cs:1098      â”‚
â”‚ Parse method<T>()      â”‚ âœ… DONE  â”‚ RazorForgeParser.cs:1685      â”‚
â”‚ Parse call<T>!()       â”‚ âœ… DONE  â”‚ RazorForgeParser.cs:2405      â”‚
â”‚ Store in AST           â”‚ âœ… DONE  â”‚ Declarations.cs, Expressions  â”‚
â”‚ Symbol table support   â”‚ âœ… DONE  â”‚ SymbolTable.cs                â”‚
â”‚ Type resolution        â”‚ âš ï¸ PART  â”‚ SemanticAnalyzer.cs:1353      â”‚
â”‚ Constraint checking    â”‚ âš ï¸ TODO  â”‚ SemanticAnalyzer.cs:1429      â”‚
â”‚ Code generation        â”‚ âš ï¸ PART  â”‚ LLVMCodeGenerator.cs:201      â”‚
â”‚ Monomorphization       â”‚ âš ï¸ TODO  â”‚ LLVMCodeGenerator.cs:60       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

IMPORTS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Feature                â”‚ Status   â”‚ Location                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Parse import a/b/c     â”‚ âœ… DONE  â”‚ RazorForgeParser.cs:269       â”‚
â”‚ Parse import as alias  â”‚ âœ… DONE  â”‚ RazorForgeParser.cs:294       â”‚
â”‚ Parse import {a, b}    â”‚ âŒ TODO  â”‚ Parser (not implemented)      â”‚
â”‚ Store in AST           â”‚ âœ… DONE  â”‚ Declarations.cs:339           â”‚
â”‚ Module resolution      â”‚ âŒ TODO  â”‚ (needs new class)             â”‚
â”‚ File lookup            â”‚ âŒ TODO  â”‚ (needs new class)             â”‚
â”‚ Symbol population      â”‚ âŒ TODO  â”‚ SemanticAnalyzer.cs:523       â”‚
â”‚ Circular detection     â”‚ âŒ TODO  â”‚ (needs new logic)             â”‚
â”‚ Transitive imports     â”‚ âŒ TODO  â”‚ (needs new logic)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


================================================================================
                            LEGEND
================================================================================

âœ… DONE     - Feature fully implemented and working
âš ï¸ PARTIAL  - Feature partially implemented, needs more work
âŒ TODO     - Feature not implemented yet
ğŸ”§ WIP      - Currently being worked on

Symbols in diagrams:
  â”Œâ”€â”  Box (component)
  â•‘â•â•‘  Double box (important component)
  â”â”â”“  Heavy box (input/output)
  â”‚    Vertical line (flow)
  â”œâ”€â”¤  Branch point
  â†’    Arrow (direction)
  â–¼    Down arrow (flow continues)


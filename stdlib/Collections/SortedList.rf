# RazorForge SortedList<T> - B-tree based sorted list with duplicates
# Entity type with heap allocation
# O(log n) insert, delete, search, and indexing
# Elements are always in sorted order, duplicates allowed
#
# Usage:
#   let grades = SortedList<f64>()
#   grades.insert(85.5)
#   grades.insert(85.5)    # Duplicates allowed
#   grades.insert(92.0)
#   let median = grades[grades.count() / 2]  # O(log n) access

import memory/DynamicSlice
import memory/MemorySize
import errors/IndexOutOfBoundsError
import core/Integral
import core/BackIndex
import Collections/List

# B-tree order (max children per node)
preset B_LIST: uaddr = 32uaddr

# B-tree node for SortedList
entity BTreeListNode<T> {
    keys: List<T>                        # Keys in this node
    children: List<BTreeListNode<T>>     # Child pointers (empty for leaf)
    subtree_size: uaddr                  # Total elements in this subtree
    is_leaf: bool
}

entity SortedList<T> {
    private root: BTreeListNode<T>
    private count: uaddr
}

# ============================================================================
# Node Constructors
# ============================================================================

routine BTreeListNode<T>.__create__(is_leaf: bool) -> BTreeListNode<T> {
    return BTreeListNode<T>(
        keys: List<T>(),
        children: List<BTreeListNode<T>>(),
        subtree_size: 0uaddr,
        is_leaf: is_leaf
    )
}

# ============================================================================
# SortedList Constructors
# ============================================================================

routine SortedList<T>.__create__() -> SortedList<T> {
    return SortedList<T>(
        root: None,
        count: 0uaddr
    )
}

# ============================================================================
# Core Operations
# ============================================================================

routine SortedList<T>.count(me: SortedList<T>) -> uaddr {
    return me.count
}

routine SortedList<T>.is_empty(me: SortedList<T>) -> bool {
    return me.count == 0uaddr
}

routine SortedList<T>.clear(me: SortedList<T>) {
    me.root = None
    me.count = 0uaddr
}

# ============================================================================
# Search
# ============================================================================

routine SortedList<T>.contains(me: SortedList<T>, value: T) -> bool {
    if me.root is None {
        return false
    }
    return me.search_node(me.root!, value)
}

routine SortedList<T>.search_node(me: SortedList<T>, node: BTreeListNode<T>, value: T) -> bool {
    var i = 0uaddr
    while i < node.keys.count() and value > node.keys[i] {
        i = i + 1uaddr
    }

    if i < node.keys.count() and value == node.keys[i] {
        return true
    }

    if node.is_leaf {
        return false
    }

    return me.search_node(node.children[i], value)
}

routine SortedList<T>.count_of(me: SortedList<T>, value: T) -> uaddr {
    # Count occurrences of value
    if me.root is None {
        return 0uaddr
    }
    return me.count_in_node(me.root!, value)
}

routine SortedList<T>.count_in_node(me: SortedList<T>, node: BTreeListNode<T>, value: T) -> uaddr {
    var count = 0uaddr
    var i = 0uaddr

    while i < node.keys.count() {
        if not node.is_leaf {
            count = count + me.count_in_node(node.children[i], value)
        }
        if node.keys[i] == value {
            count = count + 1uaddr
        }
        i = i + 1uaddr
    }

    if not node.is_leaf {
        count = count + me.count_in_node(node.children[node.children.count() - 1uaddr], value)
    }

    return count
}

# ============================================================================
# Insert (allows duplicates)
# ============================================================================

routine SortedList<T>.insert(me: SortedList<T>, value: T) {
    if me.root is None {
        me.root = BTreeListNode<T>(is_leaf: true)
        me.root!.keys.push(value)
        me.root!.subtree_size = 1uaddr
        me.count = 1uaddr
        return
    }

    # If root is full, split it
    if me.root!.keys.count() >= B_LIST - 1uaddr {
        let old_root = me.root!
        let new_root = BTreeListNode<T>(is_leaf: false)
        new_root.children.push(old_root)
        me.split_child(new_root, 0uaddr)
        me.root = new_root
        me.update_subtree_size(new_root)
    }

    me.insert_non_full(me.root!, value)
    me.count = me.count + 1uaddr
}

routine SortedList<T>.insert_non_full(me: SortedList<T>, node: BTreeListNode<T>, value: T) {
    var i = node.keys.count()

    if node.is_leaf {
        # Find position and insert (allow duplicates - use <=)
        while i > 0uaddr and value < node.keys[i - 1uaddr] {
            i = i - 1uaddr
        }
        # Insert at position i
        let keys_copy = List<T>()
        var j = 0uaddr
        while j < i {
            keys_copy.push(node.keys[j])
            j = j + 1uaddr
        }
        keys_copy.push(value)
        while j < node.keys.count() {
            keys_copy.push(node.keys[j])
            j = j + 1uaddr
        }
        node.keys = keys_copy
        node.subtree_size = node.subtree_size + 1uaddr
    } else {
        # Find child to descend into
        while i > 0uaddr and value < node.keys[i - 1uaddr] {
            i = i - 1uaddr
        }

        # Split child if full
        if node.children[i].keys.count() >= B_LIST - 1uaddr {
            me.split_child(node, i)
            if value > node.keys[i] {
                i = i + 1uaddr
            }
        }

        me.insert_non_full(node.children[i], value)
        node.subtree_size = node.subtree_size + 1uaddr
    }
}

routine SortedList<T>.split_child(me: SortedList<T>, parent_node: BTreeListNode<T>, child_idx: uaddr) {
    let child = parent_node.children[child_idx]
    let mid = (B_LIST - 1uaddr) / 2uaddr

    let new_node = BTreeListNode<T>(is_leaf: child.is_leaf)

    # Move upper keys to new node
    var i = mid + 1uaddr
    while i < child.keys.count() {
        new_node.keys.push(child.keys[i])
        i = i + 1uaddr
    }

    # Move children if not leaf
    if not child.is_leaf {
        i = mid + 1uaddr
        while i < child.children.count() {
            new_node.children.push(child.children[i])
            i = i + 1uaddr
        }
    }

    let mid_key = child.keys[mid]

    # Truncate child's keys
    let left_keys = List<T>()
    i = 0uaddr
    while i < mid {
        left_keys.push(child.keys[i])
        i = i + 1uaddr
    }
    child.keys = left_keys

    # Truncate child's children if not leaf
    if not child.is_leaf {
        let left_children = List<BTreeListNode<T>>()
        i = 0uaddr
        while i <= mid {
            left_children.push(child.children[i])
            i = i + 1uaddr
        }
        child.children = left_children
    }

    me.update_subtree_size(child)
    me.update_subtree_size(new_node)

    # Insert mid_key and new_node into parent
    let new_keys = List<T>()
    let new_children = List<BTreeListNode<T>>()

    i = 0uaddr
    while i < child_idx {
        new_keys.push(parent_node.keys[i])
        new_children.push(parent_node.children[i])
        i = i + 1uaddr
    }
    new_keys.push(mid_key)
    new_children.push(child)
    new_children.push(new_node)
    while i < parent_node.keys.count() {
        new_keys.push(parent_node.keys[i])
        i = i + 1uaddr
    }
    i = child_idx + 1uaddr
    while i < parent_node.children.count() {
        new_children.push(parent_node.children[i])
        i = i + 1uaddr
    }

    parent_node.keys = new_keys
    parent_node.children = new_children
}

routine SortedList<T>.update_subtree_size(me: SortedList<T>, node: BTreeListNode<T>) {
    if node.is_leaf {
        node.subtree_size = node.keys.count()
    } else {
        var size = node.keys.count()
        var i = 0uaddr
        while i < node.children.count() {
            size = size + node.children[i].subtree_size
            i = i + 1uaddr
        }
        node.subtree_size = size
    }
}

# ============================================================================
# Remove (removes first occurrence)
# ============================================================================

routine SortedList<T>.remove(me: SortedList<T>, value: T) -> bool {
    if me.root is None {
        return false
    }

    if not me.contains(value) {
        return false
    }

    me.remove_from_node(me.root!, value)
    me.count = me.count - 1uaddr

    if me.root!.keys.count() == 0uaddr and not me.root!.is_leaf {
        me.root = me.root!.children[0]
    }

    if me.root!.keys.count() == 0uaddr {
        me.root = None
    }

    return true
}

routine SortedList<T>.remove_from_node(me: SortedList<T>, node: BTreeListNode<T>, value: T) {
    var i = 0uaddr
    while i < node.keys.count() and value > node.keys[i] {
        i = i + 1uaddr
    }

    if i < node.keys.count() and value == node.keys[i] {
        if node.is_leaf {
            let new_keys = List<T>()
            var j = 0uaddr
            while j < node.keys.count() {
                if j != i {
                    new_keys.push(node.keys[j])
                }
                j = j + 1uaddr
            }
            node.keys = new_keys
            node.subtree_size = node.subtree_size - 1uaddr
        } else {
            let pred = me.get_predecessor(node, i)
            node.keys[i] = pred
            me.remove_from_node(node.children[i], pred)
            node.subtree_size = node.subtree_size - 1uaddr
        }
    } else {
        if node.is_leaf {
            return
        }

        me.remove_from_node(node.children[i], value)
        node.subtree_size = node.subtree_size - 1uaddr
    }
}

routine SortedList<T>.get_predecessor(me: SortedList<T>, node: BTreeListNode<T>, idx: uaddr) -> T {
    var current = node.children[idx]
    while not current.is_leaf {
        current = current.children[current.children.count() - 1uaddr]
    }
    return current.keys[current.keys.count() - 1uaddr]
}

routine SortedList<T>.remove_all(me: SortedList<T>, value: T) -> uaddr {
    # Remove all occurrences of value, return count removed
    var removed = 0uaddr
    while me.remove(value) {
        removed = removed + 1uaddr
    }
    return removed
}

# ============================================================================
# Indexing - O(log n) access by position
# ============================================================================

routine SortedList<T>.__getitem__!<I>(me: SortedList<T>, index: I) -> T
    where I follows Integral {
    let idx = index.to_uaddr()
    if idx >= me.count {
        throw IndexOutOfBoundsError(index: idx, count: me.count)
    }
    return me.get_by_rank(me.root!, idx)
}

routine SortedList<T>.__getitem__!<I>(me: SortedList<T>, index: BackIndex<I>) -> T
    where I follows Integral {
    let idx = index.resolve(me.count)
    return me.get_by_rank(me.root!, idx)
}

routine SortedList<T>.get_by_rank(me: SortedList<T>, node: BTreeListNode<T>, rank: uaddr) -> T {
    if node.is_leaf {
        return node.keys[rank]
    }

    var remaining = rank
    var i = 0uaddr

    while i < node.children.count() {
        let child_size = node.children[i].subtree_size

        if remaining < child_size {
            return me.get_by_rank(node.children[i], remaining)
        }

        remaining = remaining - child_size

        if i < node.keys.count() {
            if remaining == 0uaddr {
                return node.keys[i]
            }
            remaining = remaining - 1uaddr
        }

        i = i + 1uaddr
    }

    return node.keys[0]
}

routine SortedList<T>.get!<I>(me: SortedList<T>, index: I) -> T
    where I follows Integral {
    return me.__getitem__!(index)
}

# ============================================================================
# Range Queries
# ============================================================================

routine SortedList<T>.range(me: SortedList<T>, min_val: T, max_val: T) -> List<T> {
    let result = List<T>()
    if me.root is None {
        return result
    }
    me.range_collect(me.root!, min_val, max_val, result)
    return result
}

routine SortedList<T>.range_collect(me: SortedList<T>, node: BTreeListNode<T>, min_val: T, max_val: T, result: List<T>) {
    var i = 0uaddr

    while i < node.keys.count() {
        if not node.is_leaf and (i == 0uaddr or node.keys[i - 1uaddr] >= min_val) {
            me.range_collect(node.children[i], min_val, max_val, result)
        }

        let key = node.keys[i]
        if key >= min_val and key <= max_val {
            result.push(key)
        }

        i = i + 1uaddr
    }

    if not node.is_leaf {
        me.range_collect(node.children[node.children.count() - 1uaddr], min_val, max_val, result)
    }
}

# ============================================================================
# Min/Max
# ============================================================================

routine SortedList<T>.min!(me: SortedList<T>) -> T {
    if me.is_empty() {
        absent
    }
    var node = me.root!
    while not node.is_leaf {
        node = node.children[0]
    }
    return node.keys[0]
}

routine SortedList<T>.max!(me: SortedList<T>) -> T {
    if me.is_empty() {
        absent
    }
    var node = me.root!
    while not node.is_leaf {
        node = node.children[node.children.count() - 1uaddr]
    }
    return node.keys[node.keys.count() - 1uaddr]
}

routine SortedList<T>.first!(me: SortedList<T>) -> T {
    return me.min!()
}

routine SortedList<T>.last!(me: SortedList<T>) -> T {
    return me.max!()
}

# ============================================================================
# Iteration
# ============================================================================

routine SortedList<T>.iter(me: SortedList<T>) -> SortedListIterator<T> {
    return SortedListIterator<T>(list: me, index: 0uaddr)
}

routine SortedList<T>.to_list(me: SortedList<T>) -> List<T> {
    let result = List<T>(me.count)
    if me.root is None {
        return result
    }
    me.collect_inorder(me.root!, result)
    return result
}

routine SortedList<T>.collect_inorder(me: SortedList<T>, node: BTreeListNode<T>, result: List<T>) {
    var i = 0uaddr
    while i < node.keys.count() {
        if not node.is_leaf {
            me.collect_inorder(node.children[i], result)
        }
        result.push(node.keys[i])
        i = i + 1uaddr
    }
    if not node.is_leaf {
        me.collect_inorder(node.children[node.children.count() - 1uaddr], result)
    }
}

record SortedListIterator<T> {
    list: SortedList<T>
    index: uaddr
}

routine SortedListIterator<T>.next!(me: SortedListIterator<T>) -> T {
    if me.index >= me.list.count() {
        absent
    }
    let value = me.list[me.index]
    me.index = me.index + 1uaddr
    return value
}

# ============================================================================
# Comparison
# ============================================================================

routine SortedList<T>.__eq__(me: SortedList<T>, other: SortedList<T>) -> bool {
    if me.count != other.count {
        return false
    }
    var i = 0uaddr
    while i < me.count {
        if me[i] != other[i] {
            return false
        }
        i = i + 1uaddr
    }
    return true
}

routine SortedList<T>.__ne__(me: SortedList<T>, other: SortedList<T>) -> bool {
    return not (me == other)
}

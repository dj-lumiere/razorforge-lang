# RazorForge Integral - Protocol for all integer types
#
# All integer types follow this protocol:
# - Signed: s8, s16, s32, s64, s128, saddr
# - Unsigned: u8, u16, u32, u64, u128, uaddr
#
# This enables generic indexing and numeric operations.
namespace core
protocol Integral {
    # Convert to address-sized integers for indexing
    routine to_uaddr(me) -> uaddr
    routine to_saddr(me) -> saddr

    # Size information
    routine bit_width(me) -> u8
    routine is_signed(me) -> bool
}

# ============================================================================
# u8 follows Integral
# ============================================================================

routine u8.to_uaddr(me: u8) -> uaddr {
    return uaddr(me)
}

routine u8.to_saddr(me: u8) -> saddr {
    return saddr(me)
}

routine u8.bit_width(me: u8) -> u8 {
    return 8u8
}

routine u8.is_signed(me: u8) -> bool {
    return false
}

# ============================================================================
# u16 follows Integral
# ============================================================================

routine u16.to_uaddr(me: u16) -> uaddr {
    return uaddr(me)
}

routine u16.to_saddr(me: u16) -> saddr {
    return saddr(me)
}

routine u16.bit_width(me: u16) -> u8 {
    return 16u8
}

routine u16.is_signed(me: u16) -> bool {
    return false
}

# ============================================================================
# u32 follows Integral
# ============================================================================

routine u32.to_uaddr(me: u32) -> uaddr {
    return uaddr(me)
}

routine u32.to_saddr(me: u32) -> saddr {
    return saddr(me)
}

routine u32.bit_width(me: u32) -> u8 {
    return 32u8
}

routine u32.is_signed(me: u32) -> bool {
    return false
}

# ============================================================================
# u64 follows Integral
# ============================================================================

routine u64.to_uaddr(me: u64) -> uaddr {
    return uaddr(me)
}

routine u64.to_saddr(me: u64) -> saddr {
    return saddr(me)
}

routine u64.bit_width(me: u64) -> u8 {
    return 64u8
}

routine u64.is_signed(me: u64) -> bool {
    return false
}

# ============================================================================
# u128 follows Integral
# ============================================================================

routine u128.to_uaddr(me: u128) -> uaddr {
    return uaddr(me)
}

routine u128.to_saddr(me: u128) -> saddr {
    return saddr(me)
}

routine u128.bit_width(me: u128) -> u8 {
    return 128u8
}

routine u128.is_signed(me: u128) -> bool {
    return false
}

# ============================================================================
# uaddr follows Integral
# ============================================================================

routine uaddr.to_uaddr(me: uaddr) -> uaddr {
    return me
}

routine uaddr.to_saddr(me: uaddr) -> saddr {
    return saddr(me)
}

routine uaddr.bit_width(me: uaddr) -> u8 {
    # Platform dependent: 32 or 64
    return @intrinsic.sizeof<uaddr>() * 8u8
}

routine uaddr.is_signed(me: uaddr) -> bool {
    return false
}

# ============================================================================
# s8 follows Integral
# ============================================================================

routine s8.to_uaddr(me: s8) -> uaddr {
    return uaddr(me)
}

routine s8.to_saddr(me: s8) -> saddr {
    return saddr(me)
}

routine s8.bit_width(me: s8) -> u8 {
    return 8u8
}

routine s8.is_signed(me: s8) -> bool {
    return true
}

# ============================================================================
# s16 follows Integral
# ============================================================================

routine s16.to_uaddr(me: s16) -> uaddr {
    return uaddr(me)
}

routine s16.to_saddr(me: s16) -> saddr {
    return saddr(me)
}

routine s16.bit_width(me: s16) -> u8 {
    return 16u8
}

routine s16.is_signed(me: s16) -> bool {
    return true
}

# ============================================================================
# s32 follows Integral
# ============================================================================

routine s32.to_uaddr(me: s32) -> uaddr {
    return uaddr(me)
}

routine s32.to_saddr(me: s32) -> saddr {
    return saddr(me)
}

routine s32.bit_width(me: s32) -> u8 {
    return 32u8
}

routine s32.is_signed(me: s32) -> bool {
    return true
}

# ============================================================================
# s64 follows Integral
# ============================================================================

routine s64.to_uaddr(me: s64) -> uaddr {
    return uaddr(me)
}

routine s64.to_saddr(me: s64) -> saddr {
    return saddr(me)
}

routine s64.bit_width(me: s64) -> u8 {
    return 64u8
}

routine s64.is_signed(me: s64) -> bool {
    return true
}

# ============================================================================
# s128 follows Integral
# ============================================================================

routine s128.to_uaddr(me: s128) -> uaddr {
    return uaddr(me)
}

routine s128.to_saddr(me: s128) -> saddr {
    return saddr(me)
}

routine s128.bit_width(me: s128) -> u8 {
    return 128u8
}

routine s128.is_signed(me: s128) -> bool {
    return true
}

# ============================================================================
# saddr follows Integral
# ============================================================================

routine saddr.to_uaddr(me: saddr) -> uaddr {
    return uaddr(me)
}

routine saddr.to_saddr(me: saddr) -> saddr {
    return me
}

routine saddr.bit_width(me: saddr) -> u8 {
    # Platform dependent: 32 or 64
    return @intrinsic.sizeof<saddr>() * 8u8
}

routine saddr.is_signed(me: saddr) -> bool {
    return true
}

# RazorForge Hijacked<T> - Fundamental memory wrapper
# Raw memory management with manual control over lifetime

public struct Hijacked<T> {
    private address: sysuint
}

# Constants for memory management
preset HIJACKED_NULL: sysuint = 0_sysuint

# Create new hijacked memory allocation
recipe Hijacked.new<T>(data: T) -> Hijacked<T> {
    danger! {
        # Allocate memory on heap and store the data
        let addr = allocate_heap_memory<T>(data)
        return Hijacked<T> {
            address: addr
        }
    }
}

# Create hijacked wrapper from existing address (unsafe)
recipe Hijacked.from_address<T>(addr: sysuint) -> Hijacked<T> {
    return Hijacked<T> {
        address: addr
    }
}

# Get the raw address
recipe Hijacked.get_address<T>(my: Hijacked<T>) -> sysuint {
    return my.address
}

# Check if hijacked reference is null
recipe Hijacked.is_null<T>(my: Hijacked<T>) -> bool {
    return my.address == HIJACKED_NULL
}

# Check if hijacked reference is valid (non-null)
recipe Hijacked.is_valid<T>(my: Hijacked<T>) -> bool {
    return my.address != HIJACKED_NULL
}

# Get immutable access to the data
recipe Hijacked.get<T>(my: Hijacked<T>) -> T {
    when (my.is_null()) {
        true => throw panic("Attempted to access null hijacked memory"),
        false => {
            danger {
                return read_from_address<T>(my.address)
            }
        }
    }
}

# Get mutable access to the data
recipe Hijacked.get_mut<T>(my: Hijacked<T>) -> T {
    when (my.is_null()) {
        true => throw panic("Attempted to access null hijacked memory"),
        false => {
            danger {
                return read_from_address<T>(my.address)
            }
        }
    }
}

# Update the data at the address
recipe Hijacked.set<T>(my: Hijacked<T>, new_data: T) {
    when (my.is_null()) {
        true => throw panic("Attempted to write to null hijacked memory"),
        false => {
            danger {
                write_to_address<T>(my.address, new_data)
            }
        }
    }
}

# Clone the hijacked reference (shares same memory address)
recipe Hijacked.clone<T>(my: Hijacked<T>) -> Hijacked<T> {
    return Hijacked<T> {
        address: my.address
    }
}

# Create a deep copy (allocates new memory with copied data)
recipe Hijacked.deep_copy<T>(my: Hijacked<T>) -> Hijacked<T> where T: Clone {
    when (my.is_null()) {
        true => return Hijacked<T> { address: HIJACKED_NULL },
        false => {
            let data = my.get()
            let copied_data = data.clone()
            return Hijacked.new(copied_data)
        }
    }
}

# Release/deallocate the memory (dangerous - only call once!)
recipe Hijacked.release<T>(my: Hijacked<T>) {
    when (my.is_null()) {
        false => {
            danger {
                deallocate_heap_memory<T>(my.address)
            }
        },
        true => pass  # Already null, nothing to release
    }
}

# Reset to null (does not deallocate - use release() first if needed)
recipe Hijacked.nullify<T>(my: Hijacked<T>) -> Hijacked<T> {
    return Hijacked<T> {
        address: HIJACKED_NULL
    }
}

# Swap data between two hijacked references
recipe Hijacked.swap<T>(a: Hijacked<T>, b: Hijacked<T>) {
    when (a.is_null() or b.is_null()) {
        true => throw panic("Cannot swap with null hijacked memory"),
        false => {
            danger {
                let temp_data = read_from_address<T>(a.address)
                let b_data = read_from_address<T>(b.address)
                write_to_address<T>(a.address, b_data)
                write_to_address<T>(b.address, temp_data)
            }
        }
    }
}

# Comparison operations (compare addresses, not contents)
recipe Hijacked.ptr_eq<T>(a: Hijacked<T>, b: Hijacked<T>) -> bool {
    return a.address == b.address
}

recipe Hijacked.ptr_ne<T>(a: Hijacked<T>, b: Hijacked<T>) -> bool {
    return a.address != b.address
}

# Content comparison (requires accessing the data)
recipe Hijacked.eq<T>(a: Hijacked<T>, b: Hijacked<T>) -> bool where T: Eq {
    when {
        a.is_null() and b.is_null() => return true,
        a.is_null() or b.is_null() => return false,
        _ => return a.get() == b.get()
    }
}

# Convert to string representation
recipe Text<T>(from_hijacked: Hijacked<T>) -> Text where T: ToString {
    when (from_hijacked.is_null()) {
        true => return "Hijacked(null)",
        false => {
            let data = from_hijacked.get()
            let data_text = Text(data)
            return "Hijacked({data_text})"
        }
    }
}

# Transform the data in place
recipe Hijacked.transform<T>(my: Hijacked<T>, transform: recipe(T) -> T) {
    when (my.is_null()) {
        true => throw panic("Cannot transform null hijacked memory"),
        false => {
            let current_data = my.get()
            let new_data = transform(current_data)
            my.set(new_data)
        }
    }
}

# Apply a function to the data and return result
recipe Hijacked.map<T, U>(my: Hijacked<T>, transform: recipe(T) -> U) -> U {
    when (my.is_null()) {
        true => throw panic("Cannot map over null hijacked memory"),
        false => {
            let data = my.get()
            return transform(data)
        }
    }
}

# Utility function for ergonomic creation
recipe hijacked<T>(data: T) -> Hijacked<T> {
    return Hijacked.new(data)
}

# Create null hijacked reference
recipe hijacked_null<T>() -> Hijacked<T> {
    return Hijacked<T> {
        address: HIJACKED_NULL
    }
}

/*
Usage examples:

```razorforge
# Create hijacked memory
let data = hijacked("Hello, World!")

# Clone creates another reference to SAME memory
let alias = data.clone()

# Both point to same memory location
assert(data.ptr_eq(alias))

# Modifications through either reference affect both
data.set("Modified!")
display_line(alias.get())  # "Modified!" - same memory!

# Deep copy creates separate memory
let copy = data.deep_copy()
data.set("Changed again")
display_line(copy.get())   # "Modified!" - different memory

# Manual memory management
data.release()  # Deallocate memory
# data.get()   # Would panic - memory freed

# Null handling
let null_ref = hijacked_null<Text>()
assert(null_ref.is_null())
```

Memory safety warnings:
- Hijacked provides RAW memory management
- You must manually call release() to free memory
- Multiple hijacked references can point to same memory
- No protection against use-after-free or double-free
- This is the foundation for safer abstractions like Shared<T>

Integration with higher-level types:
- Shared<T> uses Hijacked<T> + reference counting
- Watched<T> uses Hijacked<T> + weak reference tracking
- ThreadShared<T> adds thread safety to the mix

This provides the raw building blocks that other memory management
types build upon for automatic and safe memory management.
*/
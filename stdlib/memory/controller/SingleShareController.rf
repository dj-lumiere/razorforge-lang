# RazorForge Single-threaded Share Controller
# Core reference counting mechanism for single-threaded Shared<T> memory management

entity SingleShareController {
    private strong_count: s32
    private weak_count: s32
}

# Create new reference count controller with initial counts of 0
routine SingleShareController.__create__() -> SingleShareController {
    return SingleShareController(
        strong_count: 0,
        weak_count: 0
    )
}

# Simple non-atomic operations (single-threaded)
routine SingleShareController.increase_strong_count(me: SingleShareController) {
    me.strong_count = me.strong_count + 1
}

routine SingleShareController.decrease_strong_count(me: SingleShareController) {
    me.strong_count = me.strong_count - 1
}

routine SingleShareController.increase_weak_count(me: SingleShareController) {
    me.weak_count = me.weak_count + 1
}

routine SingleShareController.decrease_weak_count(me: SingleShareController) {
    me.weak_count = me.weak_count - 1
}

# Read-only access to counts
routine SingleShareController.strong_count(me: SingleShareController) -> s32 {
    return me.strong_count
}

routine SingleShareController.weak_count(me: SingleShareController) -> s32 {
    return me.weak_count
}

# Check if the controller should be deallocated
routine SingleShareController.should_deallocate_data(me: SingleShareController) -> bool {
    return me.strong_count() == 0
}

routine SingleShareController.should_deallocate_controller(me: SingleShareController) -> bool {
    return me.strong_count() == 0 and me.weak_count() == 0
}

# RazorForge Standard Library - Memory Management
# DynamicSlice: Non-generic heap-allocated contiguous memory slice
namespace core
import memory/MemorySize
import memory/wrapper/Snatched
import errors/MemoryError

#
# Heap-allocated memory slice for dynamic data storage.
# Non-generic structure that can hold any type of data.
# Reference counting is handled separately by the wrapper type system.
#
record DynamicSlice {
    private starting_address: uaddr
    private allocated_bytes: uaddr
}

# Creates a new heap slice with specified byte size
# @param size - MemorySize specifying bytes to allocate on heap
# @return New DynamicSlice instance
routine DynamicSlice.__create__(size: MemorySize) -> DynamicSlice {
    let bytes = size.size()
    if bytes == 0 {
        me.starting_address = 0
        me.allocated_bytes = 0
        return me
    }

    me.allocated_bytes = bytes

    # Allocate heap memory
    me.starting_address = @native.rf_claim_dynamic_uaddr(bytes)

    if me.starting_address == 0 {
        throw MemoryAllocationError(requested_bytes: bytes)
    }

    return me
}

# Creates a copy of another DynamicSlice (shallow copy of data)
# @param other - Source DynamicSlice to copy from
# @return New DynamicSlice with copied data
routine DynamicSlice.copy(other: DynamicSlice) -> DynamicSlice {
    if other.allocated_bytes == 0 {
        return DynamicSlice(0b)
    }

    var new_slice = DynamicSlice(MemorySize(other.allocated_bytes))
    @native.rf_memory_copy_uaddr(other.starting_address, new_slice.starting_address, other.allocated_bytes)
    return new_slice
}

# Destructor that frees heap memory
routine DynamicSlice.__destroy__() {
    if me.starting_address != 0 {
        @native.rf_release_dynamic_uaddr(me.starting_address)
        me.starting_address = 0
        me.allocated_bytes = 0
    }
}

# Gets the total allocated bytes
# @return Number of bytes allocated for this slice
routine DynamicSlice.size() -> uaddr {
    return me.allocated_bytes
}

# Gets the starting memory address
# @return Memory address where slice data begins
routine DynamicSlice.address() -> uaddr {
    return me.starting_address
}

# Checks if this slice is valid (has allocated memory)
# @return true if slice has valid memory allocation
routine DynamicSlice.is_valid() -> bool {
    return me.starting_address != 0
}

# Reads raw bytes from the slice
# @param offset - Byte offset within the slice
# @param dest - Destination address to copy bytes to
# @param count - Number of bytes to read
routine DynamicSlice.read_bytes!(offset: uaddr, dest: uaddr, count: uaddr) {
    if offset + count > me.allocated_bytes {
        throw MemoryBoundsError(offset: offset, size: count, allocated: me.allocated_bytes)
    }

    let src_addr = me.starting_address + offset
    @native.rf_memory_copy_uaddr(src_addr, dest, count)
}

# Writes raw bytes to the slice
# @param offset - Byte offset within the slice
# @param src - Source address to copy bytes from
# @param count - Number of bytes to write
routine DynamicSlice.write_bytes!(offset: uaddr, src: uaddr, count: uaddr) {
    if offset + count > me.allocated_bytes {
        throw MemoryBoundsError(offset: offset, size: count, allocated: me.allocated_bytes)
    }

    let dest_addr = me.starting_address + offset
    @native.rf_memory_copy_uaddr(src, dest_addr, count)
}

# Reads a typed value from the slice at given offset
# @param offset - Byte offset within the slice
# @return Value of type T read from the slice
routine DynamicSlice.read!<T>(offset: uaddr) -> T {
    let type_size = @native.rf_sizeof<T>()

    if offset + type_size > me.allocated_bytes {
        throw MemoryBoundsError(offset: offset, size: type_size, allocated: me.allocated_bytes)
    }

    let addr = me.starting_address + offset
    return @native.rf_memory_read<T>(addr)
}

# Writes a typed value to the slice at given offset
# @param offset - Byte offset within the slice
# @param value - Value of type T to write to the slice
routine DynamicSlice.write!<T>(offset: uaddr, value: T) {
    let type_size = @native.rf_sizeof<T>()

    if offset + type_size > me.allocated_bytes {
        throw MemoryBoundsError(offset: offset, size: type_size, allocated: me.allocated_bytes)
    }

    let addr = me.starting_address + offset
    return @native.rf_memory_write<T>(addr, value)
}

# Gets unsafe pointer to data at offset
# @param offset - Byte offset within the slice
# @return Raw memory address at the specified offset
routine DynamicSlice.snatch!(offset: uaddr) -> uaddr {
    return me.starting_address + offset
}

# Creates a sub-slice view of this slice (shares same memory)
# @param offset - Starting byte offset for sub-slice
# @param bytes - Number of bytes in sub-slice
# @return New DynamicSlice representing the sub-range
routine DynamicSlice.slice!(offset: uaddr, bytes: uaddr) -> DynamicSlice {
    if offset + bytes > me.allocated_bytes {
        throw SliceBoundsError(offset: offset, length: bytes, allocated: me.allocated_bytes)
    }

    var sub_slice: DynamicSlice
    sub_slice.starting_address = me.starting_address + offset
    sub_slice.allocated_bytes = bytes
    return sub_slice
}

# Resizes the heap slice (may reallocate memory)
# @param new_bytes - New size in bytes for the slice
# @return Reference to this slice after resizing
routine DynamicSlice.resize!(new_bytes: uaddr) -> DynamicSlice {
    if new_bytes == 0 {
        me.__destroy__()
        return me
    }

    if me.starting_address == 0 {
        # Was empty, allocate new
        me.starting_address = @native.rf_claim_dynamic_uaddr(new_bytes)
        me.allocated_bytes = new_bytes
    } else {
        # Reallocate existing
        me.starting_address = @native.rf_resize_dynamic(me.starting_address, new_bytes)
        me.allocated_bytes = new_bytes
    }

    if me.starting_address == 0 {
        throw MemoryAllocationError(requested_bytes: new_bytes)
    }

    return me
}

# Fills the slice with a byte pattern
# @param pattern - Byte value to fill the entire slice with
routine DynamicSlice.fill!(pattern: u8) {
    @native.rf_memory_fill(me.starting_address, pattern, me.allocated_bytes)
}

# Copies data from another DynamicSlice
# @param source - Source DynamicSlice to copy from
# @param src_offset - Starting offset in source slice
# @param dest_offset - Starting offset in destination slice
# @param count - Number of bytes to copy
routine DynamicSlice.copy_from!(source: DynamicSlice, src_offset: uaddr,
                       dest_offset: uaddr, count: uaddr) {
    if src_offset + count > source.allocated_bytes {
        throw MemoryBoundsError(offset: src_offset, size: count, allocated: source.allocated_bytes)
    }

    if dest_offset + count > me.allocated_bytes {
        throw MemoryBoundsError(offset: dest_offset, size: count, allocated: me.allocated_bytes)
    }

    let src_addr = source.starting_address + src_offset
    let dest_addr = me.starting_address + dest_offset
    @native.rf_memory_copy_uaddr(src_addr, dest_addr, count)
}

# Zeros out all memory in the slice
routine DynamicSlice.zero!() {
    @native.rf_memory_zero_uaddr(me.starting_address, me.allocated_bytes)
}

# Transfers ownership from another DynamicSlice (moves data)
# @param other - Source DynamicSlice to take ownership from
# @return Reference to this slice after hijacking
routine DynamicSlice.hijack!(other: DynamicSlice) -> DynamicSlice {
    # Free our current memory
    me.__destroy__()

    # Take ownership from other
    me.starting_address = other.starting_address
    me.allocated_bytes = other.allocated_bytes

    # Clear other to prevent double-free
    other.starting_address = 0
    other.allocated_bytes = 0

    return me
}

# Gets a reference to the raw memory (for wrapper type system)
# @return Raw memory address for wrapper type operations
routine DynamicSlice.refer!() -> uaddr {
    return me.starting_address
}

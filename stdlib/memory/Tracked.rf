# RazorForge Tracked<T> - Weak reference implementation
# Allows checking if data is still alive without preventing deallocation
# Works with both Retained<T> and Shared<T, Policy>
# Zero-cost: Type parameter T encodes whether single or multi-threaded

# Base generic record - works for Tracked<Retained<T>> (2 fields)
record Tracked<T> {
    private controller_address: sysuint
    private data_address: sysuint
}

# Specialized for Tracked<Shared<T, Policy>> (3 fields needed)
record Tracked<Shared<T, Policy>> {
    private controller_address: sysuint
    private data_address: sysuint
    private lock_address: sysuint
}

# Create weak reference from Retained<T>
routine Retained<T>.track(me: Retained<T>) -> Tracked<Retained<T>> {
    danger! {
        var controller = read_as<RefCountController>(controller_address)
        controller.increase_weak_count!()

        return Tracked<Retained<T>>(
            controller_address: me.controller_address,
            data_address: me.data_address
        )
    }
}

# Create weak reference from Shared<T, Policy>
routine Shared<T, Policy>.track(me: Shared<T, Policy>) -> Tracked<Shared<T, Policy>> {
    danger! {
        var controller = read_as<ThreadReferenceCounter>(controller_address)
        controller.increase_weak_count!()

        return Tracked<Shared<T, Policy>>(
            controller_address: me.controller_address,
            data_address: me.data_address,
            lock_address: me.lock_address
        )
    }
}

# Constructor for Tracked<Retained<T>>
routine Tracked<Retained<T>>.Tracked<Retained<T>>(controller_address: sysuint, data_address: sysuint) -> Tracked<Retained<T>> {
    me.controller_address = controller_address
    me.data_address = data_address
    return me
}

# Constructor for Tracked<Shared<T, Policy>>
routine Tracked<Shared<T, Policy>>.Tracked<Shared<T, Policy>>(controller_address: sysuint, data_address: sysuint, lock_address: sysuint) -> Tracked<Shared<T, Policy>> {
    me.controller_address = controller_address
    me.data_address = data_address
    me.lock_address = lock_address
    return me
}

# Check if the tracked data is still alive
routine Tracked<T>.is_alive(me: Tracked<T>) -> bool {
    danger! {
        var controller = read_as<RefCountController>(controller_address)
        return controller.strong_count() > 0
    }
}

# Recover Tracked<Retained<T>> to Retained<T> (crashes if dead)
routine Tracked<Retained<T>>.recover!(me: Tracked<Retained<T>>) -> Retained<T> {
    danger! {
        var controller = read_as<RefCountController>(controller_address)

        when controller.strong_count() {
            > 0 => {
                controller.increase_strong_count!()
                return Retained<T>(
                    controller_address: me.controller_address,
                    data_address: me.data_address
                )
            },
            _ => panic("Tracked reference is dead")
        }
    }
}

# Recover Tracked<Retained<T>> to Retained<T> (returns Maybe)
routine Tracked<Retained<T>>.try_recover(me: Tracked<Retained<T>>) -> Maybe<Retained<T>> {
    danger! {
        var controller = read_as<RefCountController>(controller_address)

        when controller.strong_count() {
            > 0 => {
                controller.increase_strong_count!()
                return Retained<T>(
                    controller_address: me.controller_address,
                    data_address: me.data_address
                )
            },
            _ => return None
        }
    }
}

# Recover Tracked<Shared<T, Policy>> to Shared<T, Policy> (crashes if dead)
routine Tracked<Shared<T, Policy>>.recover!(me: Tracked<Shared<T, Policy>>) -> Shared<T, Policy> {
    danger! {
        var controller = read_as<ThreadReferenceCounter>(controller_address)

        when controller.strong_count() {
            > 0 => {
                controller.increase_strong_count!()
                return Shared<T, Policy>(
                    controller_address: me.controller_address,
                    data_address: me.data_address,
                    lock_address: me.lock_address
                )
            },
            _ => panic("Tracked reference is dead")
        }
    }
}

# Recover Tracked<Shared<T, Policy>> to Shared<T, Policy> (returns Maybe)
routine Tracked<Shared<T, Policy>>.try_recover(me: Tracked<Shared<T, Policy>>) -> Maybe<Shared<T, Policy>> {
    danger! {
        var controller = read_as<ThreadReferenceCounter>(controller_address)

        when controller.strong_count() {
            > 0 => {
                controller.increase_strong_count!()
                return Shared<T, Policy>(
                    controller_address: me.controller_address,
                    data_address: me.data_address,
                    lock_address: me.lock_address
                )
            },
            _ => return None
        }
    }
}

# Clone the weak reference
routine Tracked<T>.track(me: Tracked<T>) -> Tracked<T> {
    danger! {
        var controller = read_as<RefCountController>(controller_address)
        controller.increase_weak_count!()

        return Tracked<T>(
            controller_address: me.controller_address,
            data_address: me.data_address
        )
    }
}

# Release the weak reference
routine Tracked<T>.release!(me: Tracked<T>) {
    danger! {
        var controller = read_as<RefCountController>(controller_address)
        controller.decrease_weak_count!()

        # If both strong and weak counts are 0, deallocate controller
        when (controller.strong_count() == 0 and controller.weak_count() == 0) {
            true => invalidate!(controller_address),
            false => pass
        }
    }
}

# Get reference counts for debugging
routine Tracked<T>.strong_count(me: Tracked<T>) -> s32 {
    danger! {
        var controller = read_as<RefCountController>(controller_address)
        return controller.strong_count()
    }
}

routine Tracked<T>.weak_count(me: Tracked<T>) -> s32 {
    danger! {
        var controller = read_as<RefCountController>(controller_address)
        return controller.weak_count()
    }
}

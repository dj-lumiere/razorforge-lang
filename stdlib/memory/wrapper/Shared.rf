# RazorForge Shared<T, Policy> - Thread-safe reference counting with locking policy
# Supports Mutex, MultiReadLock, and RejectEdit policies

record Shared<T, Policy> {
    private controller_address: uaddr
    private data_address: uaddr
    private lock_address: uaddr
}

# Create thread-safe shared reference with policy (default: Mutex)
routine T.share() -> Shared<T, Mutex> {
    danger! {
        # Allocate control block with atomic ref counting
        let controller = ThreadReferenceCounter()
        controller.increase_strong_count!()

        # Allocate Mutex lock
        let lock = Mutex()

        # Create Shared record
        return Shared<T, Mutex>(
            controller_address: address_of(controller),
            data_address: address_of(me),
            lock_address: address_of(lock)
        )
    }
}

# Create thread-safe shared reference with explicit policy
routine T.share(policy: Policy) -> Shared<T, Policy> {
    danger! {
        # Allocate control block with atomic ref counting
        let controller = ThreadReferenceCounter()
        controller.increase_strong_count!()

        # Allocate policy-specific lock
        let lock = Policy()

        # Create Shared record
        return Shared<T, Policy>(
            controller_address: address_of(controller),
            data_address: address_of(me),
            lock_address: address_of(lock)
        )
    }
}

# Constructor for Shared<T, Policy>
routine Shared<T, Policy>.Shared<T, Policy>(controller_address: uaddr, data_address: uaddr, lock_address: uaddr) {
    me.controller_address = controller_address
    me.data_address = data_address
    me.lock_address = lock_address
    return me
}

# Clone the shared reference (increment atomic ref count)
routine Shared<T, Policy>.share!() -> Shared<T, Policy> {
    danger! {
        var controller = read_as<ThreadReferenceCounter>(controller_address)
        controller.increase_strong_count!()  # Atomic increment
    }
    return me
}

# Release the shared reference (decrement atomic ref count)
routine Shared<T, Policy>.release!() {
    danger! {
        var controller = read_as<ThreadReferenceCounter>(controller_address)
        controller.decrease_strong_count!()  # Atomic decrement

        when (controller.strong_count() == 0) {
            true => {
                # Deallocate the data
                invalidate!(data_address)

                # Deallocate the lock
                invalidate!(lock_address)

                # Check if we should also deallocate the controller
                when (controller.weak_count() == 0) {
                    true => invalidate!(controller_address),
                    false => pass  # Keep controller alive for weak references
                }
            },
            false => pass  # Still has strong references
        }
    }
}

# Get atomic reference counts for debugging
routine Shared<T, Policy>.strong_count(me: Shared<T, Policy>) -> s32 {
    danger! {
        var controller = read_as<ThreadReferenceCounter>(controller_address)
        return controller.strong_count()
    }
}

routine Shared<T, Policy>.weak_count(me: Shared<T, Policy>) -> s32 {
    danger! {
        var controller = read_as<ThreadReferenceCounter>(controller_address)
        return controller.weak_count()
    }
}

# Access to data is done through observing/seizing scoped blocks
# which handle lock acquisition and release automatically

# RazorForge Standard Library - Memory Management
# HeapSlice: Non-generic heap-allocated contiguous memory slice

import system/memory/native

###
Heap-allocated memory slice for dynamic data storage.
Non-generic structure that can hold any type of data.
Reference counting is handled separately by the wrapper type system.
###
record HeapSlice {
    private starting_address: sysuint
    private allocated_bytes: sysuint

    ###
    Creates a new heap slice with specified byte size
    @param bytes - Number of bytes to allocate on heap
    @return New HeapSlice instance
    ###
    public recipe __init__(bytes: sysuint) -> HeapSlice {
        if bytes == 0 {
            me.starting_address = 0
            me.allocated_bytes = 0
            return me
        }

        me.allocated_bytes = bytes

        # Allocate heap memory
        me.starting_address = heap_alloc!(bytes)

        if me.starting_address == 0 {
            crash!("Failed to allocate heap memory")
        }

        return me
    }

    ###
    Creates a copy of another HeapSlice (shallow copy of data)
    @param other - Source HeapSlice to copy from
    @return New HeapSlice with copied data
    ###
    public recipe __copy__(other: HeapSlice) -> HeapSlice {
        if other.allocated_bytes == 0 {
            return HeapSlice(0)
        }

        var new_slice = HeapSlice(other.allocated_bytes)
        memory_copy!(other.starting_address, new_slice.starting_address, other.allocated_bytes)
        return new_slice
    }

    ###
    Destructor that frees heap memory
    ###
    public recipe __destroy__() {
        if me.starting_address != 0 {
            heap_free!(me.starting_address)
            me.starting_address = 0
            me.allocated_bytes = 0
        }
    }

    ###
    Gets the total allocated bytes
    @return Number of bytes allocated for this slice
    ###
    public recipe size() -> sysuint {
        return me.allocated_bytes
    }

    ###
    Gets the starting memory address
    @return Memory address where slice data begins
    ###
    public recipe address() -> sysuint {
        return me.starting_address
    }

    ###
    Checks if this slice is valid (has allocated memory)
    @return true if slice has valid memory allocation
    ###
    public recipe is_valid() -> bool {
        return me.starting_address != 0
    }

    ###
    Reads raw bytes from the slice
    @param offset - Byte offset within the slice
    @param dest - Destination address to copy bytes to
    @param count - Number of bytes to read
    ###
    public recipe read_bytes!(offset: sysuint, dest: sysuint, count: sysuint) {
        if offset + count > me.allocated_bytes {
            crash!(f"Read operation would exceed slice bounds")
        }

        let src_addr = me.starting_address + offset
        memory_copy!(src_addr, dest, count)
    }

    ###
    Writes raw bytes to the slice
    @param offset - Byte offset within the slice
    @param src - Source address to copy bytes from
    @param count - Number of bytes to write
    ###
    public recipe write_bytes!(offset: sysuint, src: sysuint, count: sysuint) {
        if offset + count > me.allocated_bytes {
            crash!(f"Write operation would exceed slice bounds")
        }

        let dest_addr = me.starting_address + offset
        memory_copy!(src, dest_addr, count)
    }

    ###
    Reads a typed value from the slice at given offset
    @param offset - Byte offset within the slice
    @return Value of type T read from the slice
    ###
    public recipe read<T>!(offset: sysuint) -> T {
        let type_size = sizeof<T>()

        if offset + type_size > me.allocated_bytes {
            crash!(f"Read would exceed slice bounds")
        }

        let addr = me.starting_address + offset
        return memory_read<T>!(addr)
    }

    ###
    Writes a typed value to the slice at given offset
    @param offset - Byte offset within the slice
    @param value - Value of type T to write to the slice
    ###
    public recipe write<T>!(offset: sysuint, value: T) {
        let type_size = sizeof<T>()

        if offset + type_size > me.allocated_bytes {
            crash!(f"Write would exceed slice bounds")
        }

        let addr = me.starting_address + offset
        memory_write<T>!(addr, value)
    }

    ###
    Gets unsafe pointer to data at offset
    @param offset - Byte offset within the slice
    @return Raw memory address at the specified offset
    ###
    public recipe unsafe_ptr!(offset: sysuint) -> sysuint {
        return me.starting_address + offset
    }

    ###
    Creates a sub-slice view of this slice (shares same memory)
    @param offset - Starting byte offset for sub-slice
    @param bytes - Number of bytes in sub-slice
    @return New HeapSlice representing the sub-range
    ###
    public recipe slice!(offset: sysuint, bytes: sysuint) -> HeapSlice {
        if offset + bytes > me.allocated_bytes {
            crash!(f"Slice range exceeds bounds")
        }

        var sub_slice: HeapSlice
        sub_slice.starting_address = me.starting_address + offset
        sub_slice.allocated_bytes = bytes
        return sub_slice
    }

    ###
    Resizes the heap slice (may reallocate memory)
    @param new_bytes - New size in bytes for the slice
    @return Reference to this slice after resizing
    ###
    public recipe resize!(new_bytes: sysuint) -> HeapSlice {
        if new_bytes == 0 {
            me.__destroy__()
            return me
        }

        if me.starting_address == 0 {
            # Was empty, allocate new
            me.starting_address = heap_alloc!(new_bytes)
            me.allocated_bytes = new_bytes
        } else {
            # Reallocate existing
            me.starting_address = heap_realloc!(me.starting_address, new_bytes)
            me.allocated_bytes = new_bytes
        }

        if me.starting_address == 0 {
            crash!("Failed to resize heap slice")
        }

        return me
    }

    ###
    Fills the slice with a byte pattern
    @param pattern - Byte value to fill the entire slice with
    ###
    public recipe fill!(pattern: u8) {
        memory_fill!(me.starting_address, pattern, me.allocated_bytes)
    }

    ###
    Copies data from another HeapSlice
    @param source - Source HeapSlice to copy from
    @param src_offset - Starting offset in source slice
    @param dest_offset - Starting offset in destination slice
    @param count - Number of bytes to copy
    ###
    public recipe copy_from!(source: HeapSlice, src_offset: sysuint,
                           dest_offset: sysuint, count: sysuint) {
        if src_offset + count > source.allocated_bytes {
            crash!("Source range exceeds bounds")
        }

        if dest_offset + count > me.allocated_bytes {
            crash!("Destination range exceeds bounds")
        }

        let src_addr = source.starting_address + src_offset
        let dest_addr = me.starting_address + dest_offset
        memory_copy!(src_addr, dest_addr, count)
    }

    ###
    Copies from StackSlice to this HeapSlice
    @param source - Source StackSlice to copy from
    @param src_offset - Starting offset in source slice
    @param dest_offset - Starting offset in destination slice
    @param count - Number of bytes to copy
    ###
    public recipe copy_from_stack!(source: StackSlice, src_offset: sysuint,
                                 dest_offset: sysuint, count: sysuint) {
        if src_offset + count > source.size() {
            crash!("Source range exceeds bounds")
        }

        if dest_offset + count > me.allocated_bytes {
            crash!("Destination range exceeds bounds")
        }

        let src_addr = source.address() + src_offset
        let dest_addr = me.starting_address + dest_offset
        memory_copy!(src_addr, dest_addr, count)
    }

    ###
    Zeros out all memory in the slice
    ###
    public recipe zero!() {
        memory_zero!(me.starting_address, me.allocated_bytes)
    }

    ###
    Transfers ownership from another HeapSlice (moves data)
    @param other - Source HeapSlice to take ownership from
    @return Reference to this slice after hijacking
    ###
    public recipe hijack!(other: HeapSlice) -> HeapSlice {
        # Free our current memory
        me.__destroy__()

        # Take ownership from other
        me.starting_address = other.starting_address
        me.allocated_bytes = other.allocated_bytes

        # Clear other to prevent double-free
        other.starting_address = 0
        other.allocated_bytes = 0

        return me
    }

    ###
    Gets a reference to the raw memory (for wrapper type system)
    @return Raw memory address for wrapper type operations
    ###
    public recipe refer!() -> sysuint {
        return me.starting_address
    }
}

# Native runtime functions for heap operations
external recipe heap_alloc!(bytes: sysuint) -> sysuint
external recipe heap_free!(address: sysuint)
external recipe heap_realloc!(address: sysuint, new_bytes: sysuint) -> sysuint
external recipe memory_copy!(src: sysuint, dest: sysuint, bytes: sysuint)
external recipe memory_fill!(address: sysuint, pattern: u8, bytes: sysuint)
external recipe memory_zero!(address: sysuint, bytes: sysuint)
external recipe memory_read<T>!(address: sysuint) -> T
external recipe memory_write<T>!(address: sysuint, value: T)
external recipe sizeof<T>() -> sysuint

# Danger zone operations - raw memory access without safety checks
external recipe read_as<T>!(address: sysuint) -> T
external recipe write_as<T>!(address: sysuint, value: T)
external recipe volatile_read<T>!(address: sysuint) -> T
external recipe volatile_write<T>!(address: sysuint, value: T)
external recipe obtain_as<T>!(object: auto) -> sysuint
external recipe reveal_as<T>!(address: sysuint) -> T
external recipe addr_of!(object: auto) -> sysuint
external recipe invalidate<T>!(object: T)
external recipe crash!(message: text)
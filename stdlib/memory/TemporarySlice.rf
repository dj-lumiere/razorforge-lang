# RazorForge Standard Library - Memory Management
# TemporarySlice: Non-generic stack-allocated contiguous memory slice

import system/memory/native

### Stack-allocated memory slice with automatic lifetime management.
### Non-generic structure that can hold any type of data.
record TemporarySlice {
    private address: uaddr
    private allocated_bytes: uaddr

    ### Creates a new stack slice with specified byte size
    ### @param bytes - Number of bytes to allocate on stack
    ### @return New TemporarySlice instance
    public routine __create__(bytes: uaddr) -> TemporarySlice {
        if bytes == 0 {
            me.starting_address = 0
            me.allocated_bytes = 0
            return me
        }

        me.allocated_bytes = bytes

        # LLVM alloca instruction for stack allocation
        me.starting_address = claim_temporary!(bytes)

        if me.starting_address == 0 {
            crash!("Failed to allocate stack memory")
        }

        return me
    }

    ### Gets the total allocated bytes
    ### @return Number of bytes allocated for this slice
    public routine size() -> uaddr {
        return me.allocated_bytes
    }

    ### Gets the starting memory address
    ### @return Memory address where slice data begins
    public routine address() -> uaddr {
        return me.starting_address
    }

    ### Checks if this slice is valid (has allocated memory)
    ### @return true if slice has valid memory allocation
    public routine is_valid() -> bool {
        return me.starting_address != 0
    }

    ### Reads raw bytes from the slice
    ### @param offset - Byte offset within the slice
    ### @param dest - Destination address to copy bytes to
    ### @param count - Number of bytes to read
    public routine read_bytes!(offset: uaddr, dest: uaddr, count: uaddr) {
        if offset + count > me.allocated_bytes {
            crash!(f"Read operation would exceed slice bounds")
        }

        let src_addr = me.starting_address + offset
        memory_copy!(src_addr, dest, count)
    }

    ### Writes raw bytes to the slice
    ### @param offset - Byte offset within the slice
    ### @param src - Source address to copy bytes from
    ### @param count - Number of bytes to write
    public routine write_bytes!(offset: uaddr, src: uaddr, count: uaddr) {
        if offset + count > me.allocated_bytes {
            crash!(f"Write operation would exceed slice bounds")
        }

        let dest_addr = me.starting_address + offset
        memory_copy!(src, dest_addr, count)
    }

    ### Reads a typed value from the slice at given offset
    ### @param offset - Byte offset within the slice
    ### @return Value of type T read from the slice
    public routine read<T>!(offset: uaddr) -> T {
        let type_size = sizeof<T>()

        if offset + type_size > me.allocated_bytes {
            crash!(f"Read would exceed slice bounds")
        }

        let addr = me.starting_address + offset
        return memory_read<T>!(addr)
    }

    ### Writes a typed value to the slice at given offset
    ### @param offset - Byte offset within the slice
    ### @param value - Value of type T to write to the slice
    public routine write<T>!(offset: uaddr, value: T) {
        let type_size = sizeof<T>()

        if offset + type_size > me.allocated_bytes {
            crash!(f"Write would exceed slice bounds")
        }

        let addr = me.starting_address + offset
        return memory_write<T>!(addr, value)
    }

    ### Gets unsafe pointer to data at offset
    ### @param offset - Byte offset within the slice
    ### @return Raw memory address at the specified offset
    public routine snatch!(offset: uaddr) -> uaddr {
        return me.starting_address + offset
    }

    ### Creates a sub-slice view of this slice
    ### @param offset - Starting byte offset for sub-slice
    ### @param bytes - Number of bytes in sub-slice
    ### @return New TemporarySlice representing the sub-range
    public routine slice!(offset: uaddr, bytes: uaddr) -> TemporarySlice {
        if offset + bytes > me.allocated_bytes {
            crash!(f"Slice range exceeds bounds")
        }

        var sub_slice: TemporarySlice
        sub_slice.starting_address = me.starting_address + offset
        sub_slice.allocated_bytes = bytes
        return sub_slice
    }

    ### Fills the slice with a byte pattern
    ### @param pattern - Byte value to fill the entire slice with
    public routine fill!(pattern: u8) {
        memory_fill!(me.starting_address, pattern, me.allocated_bytes)
    }

    ### Copies data from another slice
    ### @param source - Source TemporarySlice to copy from
    ### @param src_offset - Starting offset in source slice
    ### @param dest_offset - Starting offset in destination slice
    ### @param count - Number of bytes to copy
    public routine copy_from!(source: TemporarySlice, src_offset: uaddr,
                           dest_offset: uaddr, count: uaddr) {
        if src_offset + count > source.allocated_bytes {
            crash!("Source range exceeds bounds")
        }

        if dest_offset + count > me.allocated_bytes {
            crash!("Destination range exceeds bounds")
        }

        let src_addr = source.starting_address + src_offset
        let dest_addr = me.starting_address + dest_offset
        memory_copy!(src_addr, dest_addr, count)
    }

    ### Zeros out all memory in the slice
    public routine zero!() {
        memory_zero!(me.starting_address, me.allocated_bytes)
    }
}

# Native runtime functions for temporary (stack) operations
external("C") routine claim_temporary!(bytes: uaddr) -> uaddr
external("C") routine memory_copy!(src: uaddr, dest: uaddr, bytes: uaddr)
external("C") routine memory_fill!(address: uaddr, pattern: u8, bytes: uaddr)
external("C") routine memory_zero!(address: uaddr, bytes: uaddr)
external("C") routine memory_read<T>!(address: uaddr) -> T
external("C") routine memory_write<T>!(address: uaddr, value: T)
external("C") routine sizeof<T>() -> uaddr

# Danger zone operations - raw memory access without safety checks
external("C") routine read_as<T>!(address: uaddr) -> T
external("C") routine write_as<T>!(address: uaddr, value: T)
external("C") routine volatile_read<T>!(address: uaddr) -> T
external("C") routine volatile_write<T>!(address: uaddr, value: T)
external("C") routine obtain_as<T>!(object: auto) -> uaddr
external("C") routine reveal_as<T>!(address: uaddr) -> T
external("C") routine address_of!(object: auto) -> uaddr
external("C") routine invalidate<T>!(object: T)
external("C") routine crash!(message: text)

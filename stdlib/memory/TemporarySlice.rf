# RazorForge Standard Library - Memory Management
# TemporarySlice: Non-generic stack-allocated contiguous memory slice

import system/memory/native

###
Stack-allocated memory slice with automatic lifetime management.
Non-generic structure that can hold any type of data.
###
record TemporarySlice {
    private address: sysuint
    private allocated_bytes: sysuint

    ###
    Creates a new stack slice with specified byte size
    @param bytes - Number of bytes to allocate on stack
    @return New TemporarySlice instance
    ###
    public routine __create__(bytes: sysuint) -> TemporarySlice {
        if bytes == 0 {
            me.starting_address = 0
            me.allocated_bytes = 0
            return me
        }

        me.allocated_bytes = bytes

        # LLVM alloca instruction for stack allocation
        me.starting_address = claim_temporary!(bytes)

        if me.starting_address == 0 {
            crash!("Failed to allocate stack memory")
        }

        return me
    }

    ###
    Gets the total allocated bytes
    @return Number of bytes allocated for this slice
    ###
    public routine size() -> sysuint {
        return me.allocated_bytes
    }

    ###
    Gets the starting memory address
    @return Memory address where slice data begins
    ###
    public routine address() -> sysuint {
        return me.starting_address
    }

    ###
    Checks if this slice is valid (has allocated memory)
    @return true if slice has valid memory allocation
    ###
    public routine is_valid() -> bool {
        return me.starting_address != 0
    }

    ###
    Reads raw bytes from the slice
    @param offset - Byte offset within the slice
    @param dest - Destination address to copy bytes to
    @param count - Number of bytes to read
    ###
    public routine read_bytes!(offset: sysuint, dest: sysuint, count: sysuint) {
        if offset + count > me.allocated_bytes {
            crash!(f"Read operation would exceed slice bounds")
        }

        let src_addr = me.starting_address + offset
        memory_copy!(src_addr, dest, count)
    }

    ###
    Writes raw bytes to the slice
    @param offset - Byte offset within the slice
    @param src - Source address to copy bytes from
    @param count - Number of bytes to write
    ###
    public routine write_bytes!(offset: sysuint, src: sysuint, count: sysuint) {
        if offset + count > me.allocated_bytes {
            crash!(f"Write operation would exceed slice bounds")
        }

        let dest_addr = me.starting_address + offset
        memory_copy!(src, dest_addr, count)
    }

    ###
    Reads a typed value from the slice at given offset
    @param offset - Byte offset within the slice
    @return Value of type T read from the slice
    ###
    public routine read<T>!(offset: sysuint) -> T {
        let type_size = sizeof<T>()

        if offset + type_size > me.allocated_bytes {
            crash!(f"Read would exceed slice bounds")
        }

        let addr = me.starting_address + offset
        return memory_read<T>!(addr)
    }

    ###
    Writes a typed value to the slice at given offset
    @param offset - Byte offset within the slice
    @param value - Value of type T to write to the slice
    ###
    public routine write<T>!(offset: sysuint, value: T) {
        let type_size = sizeof<T>()

        if offset + type_size > me.allocated_bytes {
            crash!(f"Write would exceed slice bounds")
        }

        let addr = me.starting_address + offset
        return memory_write<T>!(addr, value)
    }

    ###
    Gets unsafe pointer to data at offset
    @param offset - Byte offset within the slice
    @return Raw memory address at the specified offset
    ###
    public routine snatch!(offset: sysuint) -> sysuint {
        return me.starting_address + offset
    }

    ###
    Creates a sub-slice view of this slice
    @param offset - Starting byte offset for sub-slice
    @param bytes - Number of bytes in sub-slice
    @return New TemporarySlice representing the sub-range
    ###
    public routine slice!(offset: sysuint, bytes: sysuint) -> TemporarySlice {
        if offset + bytes > me.allocated_bytes {
            crash!(f"Slice range exceeds bounds")
        }

        var sub_slice: TemporarySlice
        sub_slice.starting_address = me.starting_address + offset
        sub_slice.allocated_bytes = bytes
        return sub_slice
    }

    ###
    Fills the slice with a byte pattern
    @param pattern - Byte value to fill the entire slice with
    ###
    public routine fill!(pattern: u8) {
        memory_fill!(me.starting_address, pattern, me.allocated_bytes)
    }

    ###
    Copies data from another slice
    @param source - Source TemporarySlice to copy from
    @param src_offset - Starting offset in source slice
    @param dest_offset - Starting offset in destination slice
    @param count - Number of bytes to copy
    ###
    public routine copy_from!(source: TemporarySlice, src_offset: sysuint,
                           dest_offset: sysuint, count: sysuint) {
        if src_offset + count > source.allocated_bytes {
            crash!("Source range exceeds bounds")
        }

        if dest_offset + count > me.allocated_bytes {
            crash!("Destination range exceeds bounds")
        }

        let src_addr = source.starting_address + src_offset
        let dest_addr = me.starting_address + dest_offset
        memory_copy!(src_addr, dest_addr, count)
    }

    ###
    Zeros out all memory in the slice
    ###
    public routine zero!() {
        memory_zero!(me.starting_address, me.allocated_bytes)
    }
}

# Native runtime functions for temporary (stack) operations
external("C") routine claim_temporary!(bytes: sysuint) -> sysuint
external("C") routine memory_copy!(src: sysuint, dest: sysuint, bytes: sysuint)
external("C") routine memory_fill!(address: sysuint, pattern: u8, bytes: sysuint)
external("C") routine memory_zero!(address: sysuint, bytes: sysuint)
external("C") routine memory_read<T>!(address: sysuint) -> T
external("C") routine memory_write<T>!(address: sysuint, value: T)
external("C") routine sizeof<T>() -> sysuint

# Danger zone operations - raw memory access without safety checks
external("C") routine read_as<T>!(address: sysuint) -> T
external("C") routine write_as<T>!(address: sysuint, value: T)
external("C") routine volatile_read<T>!(address: sysuint) -> T
external("C") routine volatile_write<T>!(address: sysuint, value: T)
external("C") routine obtain_as<T>!(object: auto) -> sysuint
external("C") routine reveal_as<T>!(address: sysuint) -> T
external("C") routine address_of!(object: auto) -> sysuint
external("C") routine invalidate<T>!(object: T)
external("C") routine crash!(message: text)

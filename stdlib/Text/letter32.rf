# RazorForge letter32 - Unicode codepoint (UTF-32 code unit)
#
# Represents a full Unicode codepoint (U+0000 to U+10FFFF).
# In UTF-32, every character is exactly 4 bytes, providing O(1) indexing.
#
# This is the recommended type for text editing and manipulation
# because character boundaries are trivial to find.
#
# For I/O and storage, convert to Text<letter8> (UTF-8).
# For Windows API interop, use cwstr with Text<letter16>.
#
# For legacy 32-bit encodings, use List<u32> instead.

import Text/LetterType
import core/Integral

record letter32 follows LetterType {
    private value: u32
}

# Unicode constants
preset LETTER32_NULL: letter32 = letter32(value: 0x0000)
preset LETTER32_SPACE: letter32 = letter32(value: 0x0020)
preset LETTER32_NEWLINE: letter32 = letter32(value: 0x000A)
preset LETTER32_TAB: letter32 = letter32(value: 0x0009)
preset LETTER32_REPLACEMENT: letter32 = letter32(value: 0xFFFD)
preset LETTER32_MAX_UNICODE: letter32 = letter32(value: 0x10FFFF)

# Surrogate range (invalid for standalone codepoints)
preset LETTER32_SURROGATE_START: u32 = 0xD800
preset LETTER32_SURROGATE_END: u32 = 0xDFFF

# ============================================================================
# LetterType protocol implementation
# ============================================================================

routine letter32.codepoint(me: letter32) -> u32 {
    return me.value
}

routine letter32.is_valid(me: letter32) -> bool {
    let cp = me.value
    # Valid if within Unicode range and not a surrogate
    return cp <= 0x10FFFFu32 and not (LETTER32_SURROGATE_START <= cp <= LETTER32_SURROGATE_END)
}

routine letter32.is_ascii(me: letter32) -> bool {
    return me.value <= 0x007Fu32
}

routine letter32.is_alphabetic(me: letter32) -> bool {
    let v = me.value
    return (0x0041u32 <= v <= 0x005Au32) or    # A-Z
           (0x0061u32 <= v <= 0x007Au32) or    # a-z
           (0x00C0u32 <= v <= 0x00FFu32) or    # Latin Extended
           (0x0100u32 <= v <= 0x017Fu32) or    # Latin Extended-A
           (0x0180u32 <= v <= 0x024Fu32)       # Latin Extended-B
}

routine letter32.is_numeric(me: letter32) -> bool {
    let v = me.value
    return 0x0030u32 <= v <= 0x0039u32  # 0-9
}

routine letter32.is_alphanumeric(me: letter32) -> bool {
    return me.is_alphabetic() or me.is_numeric()
}

routine letter32.is_uppercase(me: letter32) -> bool {
    let v = me.value
    return 0x0041u32 <= v <= 0x005Au32  # A-Z (ASCII only)
}

routine letter32.is_lowercase(me: letter32) -> bool {
    let v = me.value
    return 0x0061u32 <= v <= 0x007Au32  # a-z (ASCII only)
}

routine letter32.is_whitespace(me: letter32) -> bool {
    let v = me.value
    return v == 0x0020u32 or    # Space
           v == 0x0009u32 or    # Tab
           v == 0x000Au32 or    # Line feed
           v == 0x000Du32 or    # Carriage return
           v == 0x000Cu32 or    # Form feed
           v == 0x00A0u32 or    # Non-breaking space
           v == 0x2000u32 or    # En quad
           v == 0x2001u32 or    # Em quad
           v == 0x2002u32 or    # En space
           v == 0x2003u32       # Em space
}

routine letter32.is_control(me: letter32) -> bool {
    let v = me.value
    return (v <= 0x001Fu32) or (0x007Fu32 <= v <= 0x009Fu32)
}

routine letter32.to_uppercase(me: letter32) -> letter32 {
    if me.is_lowercase() {
        return letter32(value: me.value - 32u32)
    }
    return me
}

routine letter32.to_lowercase(me: letter32) -> letter32 {
    if me.is_uppercase() {
        return letter32(value: me.value + 32u32)
    }
    return me
}

# ============================================================================
# UTF-16 surrogate pair helpers
# ============================================================================

routine letter32.needs_surrogate_pair(me: letter32) -> bool {
    return me.value > 0xFFFFu32
}

routine letter32.to_high_surrogate(me: letter32) -> letter16 {
    if me.needs_surrogate_pair() {
        let cp = me.value - 0x10000u32
        return letter16(codepoint: u16((cp >> 10u32) + 0xD800u32))
    }
    return letter16(codepoint: u16(me.value))
}

routine letter32.to_low_surrogate(me: letter32) -> letter16 {
    if me.needs_surrogate_pair() {
        let cp = me.value - 0x10000u32
        return letter16(codepoint: u16((cp & 0x3FFu32) + 0xDC00u32))
    }
    return letter16(codepoint: 0u16)
}

# ============================================================================
# Comparison operations
# ============================================================================

routine letter32.__eq__(me: letter32, other: letter32) -> bool {
    return me.value == other.value
}

routine letter32.__ne__(me: letter32, other: letter32) -> bool {
    return me.value != other.value
}

routine letter32.__lt__(me: letter32, other: letter32) -> bool {
    return me.value < other.value
}

routine letter32.__le__(me: letter32, other: letter32) -> bool {
    return me.value <= other.value
}

routine letter32.__gt__(me: letter32, other: letter32) -> bool {
    return me.value > other.value
}

routine letter32.__ge__(me: letter32, other: letter32) -> bool {
    return me.value >= other.value
}

# ============================================================================
# Type conversions
# ============================================================================

routine letter32.to_u32(me: letter32) -> u32 {
    return me.value
}

routine letter32.to_letter8(me: letter32) -> letter8 {
    # Only valid for ASCII range - truncates
    return letter8(codepoint: u8(me.value & 0x7Fu32))
}

routine letter32.to_letter16(me: letter32) -> letter16 {
    # Only valid for BMP - truncates supplementary characters
    return letter16(codepoint: u16(me.value & 0xFFFFu32))
}

# ============================================================================
# Utility methods
# ============================================================================

routine letter32.is_digit(me: letter32) -> bool {
    return me.is_numeric()
}

routine letter32.is_letter(me: letter32) -> bool {
    return me.is_alphabetic()
}

routine letter32.digit_value(me: letter32) -> s32 {
    if me.is_numeric() {
        return s32(me.value - 0x0030u32)
    }
    return -1s32
}

routine letter32.is_printable(me: letter32) -> bool {
    return me.is_valid() and not me.is_control()
}

routine letter32.is_bmp(me: letter32) -> bool {
    # Basic Multilingual Plane: U+0000 to U+FFFF (excluding surrogates)
    return me.value <= 0xFFFFu32 and not (LETTER32_SURROGATE_START <= me.value <= LETTER32_SURROGATE_END)
}

routine letter32.is_supplementary(me: letter32) -> bool {
    # Supplementary planes: U+10000 to U+10FFFF
    return 0x10000u32 <= me.value <= 0x10FFFFu32
}

routine letter32.is_cjk(me: letter32) -> bool {
    let v = me.value
    return (0x4E00u32 <= v <= 0x9FFFu32) or    # CJK Unified Ideographs
           (0x3400u32 <= v <= 0x4DBFu32) or    # CJK Extension A
           (0x20000u32 <= v <= 0x2A6DFu32) or  # CJK Extension B
           (0x2A700u32 <= v <= 0x2B73Fu32)     # CJK Extension C
}

routine letter32.is_latin(me: letter32) -> bool {
    let v = me.value
    return (0x0000u32 <= v <= 0x007Fu32) or    # Basic Latin
           (0x0080u32 <= v <= 0x00FFu32) or    # Latin-1 Supplement
           (0x0100u32 <= v <= 0x017Fu32) or    # Latin Extended-A
           (0x0180u32 <= v <= 0x024Fu32)       # Latin Extended-B
}

routine letter32.is_emoji(me: letter32) -> bool {
    let v = me.value
    return (0x1F600u32 <= v <= 0x1F64Fu32) or  # Emoticons
           (0x1F300u32 <= v <= 0x1F5FFu32) or  # Misc Symbols and Pictographs
           (0x1F680u32 <= v <= 0x1F6FFu32) or  # Transport and Map
           (0x1F1E0u32 <= v <= 0x1F1FFu32)     # Flags
}

# ============================================================================
# Codepoint offset
# ============================================================================

routine letter32.offset!<I: Integral>(me: letter32, delta: I) -> letter32 {
    let new_value = saddr(me.value) + delta.to_saddr()
    return letter32(value: u32(new_value))
}

# RazorForge letter16 (16-bit Unicode character) implementation
# Basic Multilingual Plane Unicode support for text processing

struct letter16 {
    private value: u16
}

# Unicode constants for BMP
preset LETTER16_NULL: letter16 = letter16(codepoint: 0x0000)
preset LETTER16_MAX_BMP: letter16 = letter16(codepoint: 0xFFFF)
preset LETTER16_REPLACEMENT_CHAR: letter16 = letter16(codepoint: 0xFFFD)
preset LETTER16_SPACE: letter16 = letter16(codepoint: 0x20)
preset LETTER16_NEWLINE: letter16 = letter16(codepoint: 0x0A)
preset LETTER16_TAB: letter16 = letter16(codepoint: 0x09)

# UTF-16 surrogate constants
preset LETTER16_HIGH_SURROGATE_START: letter16 = letter16(codepoint: 0xD800)
preset LETTER16_HIGH_SURROGATE_END: letter16 = letter16(codepoint: 0xDBFF)
preset LETTER16_LOW_SURROGATE_START: letter16 = letter16(codepoint: 0xDC00)
preset LETTER16_LOW_SURROGATE_END: letter16 = letter16(codepoint: 0xDFFF)

# Core character properties
recipe letter16.codepoint(my: letter16) -> u16 {
    return my.value
}

recipe letter16(codepoint: u16) -> letter16 {
    return letter16 { value: codepoint }
}

recipe letter16.is_ascii(my: letter16) -> bool {
    return my.codepoint() <= 127
}

recipe letter16.is_bmp(my: letter16) -> bool {
    return true  # All letter16 are in BMP by definition
}

# UTF-16 surrogate handling
recipe letter16.is_surrogate(my: letter16) -> bool {
    let cp = my.codepoint()
    return cp >= 0xD800 and cp <= 0xDFFF
}

recipe letter16.is_high_surrogate(my: letter16) -> bool {
    let cp = my.codepoint()
    return cp >= 0xD800 and cp <= 0xDBFF
}

recipe letter16.is_low_surrogate(my: letter16) -> bool {
    let cp = my.codepoint()
    return cp >= 0xDC00 and cp <= 0xDFFF
}

recipe letter16.combine_surrogates(high: letter16, low: letter16) -> letter {
    when (high.is_high_surrogate() and low.is_low_surrogate()) {
        true => {
            let high_bits = (high.codepoint() - 0xD800) as u32
            let low_bits = (low.codepoint() - 0xDC00) as u32
            let combined = ((high_bits << 10) | low_bits) + 0x10000
            return letter(codepoint: combined)
        },
        false => return letter(codepoint: 0xFFFD)  # Replacement character
    }
}

# Character classification (Basic Multilingual Plane)
recipe letter16.is_alphabetic(my: letter16) -> bool {
    let cp = my.codepoint()
    return (cp >= 0x41 and cp <= 0x5A) or      # A-Z
           (cp >= 0x61 and cp <= 0x7A) or      # a-z
           (cp >= 0xC0 and cp <= 0xFF) or      # Latin Extended
           (cp >= 0x100 and cp <= 0x17F) or    # Latin Extended-A
           (cp >= 0x180 and cp <= 0x24F)       # Latin Extended-B (partial)
}

recipe letter16.is_numeric(my: letter16) -> bool {
    let cp = my.codepoint()
    return cp >= 0x30 and cp <= 0x39  # 0-9 (ASCII digits)
}

recipe letter16.is_alphanumeric(my: letter16) -> bool {
    return my.is_alphabetic() or my.is_numeric()
}

recipe letter16.is_uppercase(my: letter16) -> bool {
    let cp = my.codepoint()
    return cp >= 0x41 and cp <= 0x5A  # A-Z (ASCII only, simplified)
}

recipe letter16.is_lowercase(my: letter16) -> bool {
    let cp = my.codepoint()
    return cp >= 0x61 and cp <= 0x7A  # a-z (ASCII only, simplified)
}

recipe letter16.is_whitespace(my: letter16) -> bool {
    let cp = my.codepoint()
    return cp == 0x20 or      # Space
           cp == 0x09 or      # Tab
           cp == 0x0A or      # Line feed
           cp == 0x0D or      # Carriage return
           cp == 0x0C or      # Form feed
           cp == 0xA0 or      # Non-breaking space
           cp == 0x2000 or    # En quad
           cp == 0x2001 or    # Em quad
           cp == 0x2002 or    # En space
           cp == 0x2003       # Em space (partial Unicode whitespace)
}

recipe letter16.is_control(my: letter16) -> bool {
    let cp = my.codepoint()
    return (cp <= 0x1F) or (cp >= 0x7F and cp <= 0x9F)
}

# Case conversions (ASCII only, simplified)
recipe letter16.to_uppercase(my: letter16) -> letter16 {
    when (my.is_lowercase()) {
        true => return letter16(codepoint: my.codepoint() - 32),
        false => return my
    }
}

recipe letter16.to_lowercase(my: letter16) -> letter16 {
    when (my.is_uppercase()) {
        true => return letter16(codepoint: my.codepoint() + 32),
        false => return my
    }
}

# Comparison operations
recipe letter16.eq(my: letter16, other: letter16) -> bool {
    return my.codepoint() == other.codepoint()
}

recipe letter16.ne(my: letter16, other: letter16) -> bool {
    return my.codepoint() != other.codepoint()
}

recipe letter16.lt(my: letter16, other: letter16) -> bool {
    return my.codepoint() < other.codepoint()
}

recipe letter16.le(my: letter16, other: letter16) -> bool {
    return my.codepoint() <= other.codepoint()
}

recipe letter16.gt(my: letter16, other: letter16) -> bool {
    return my.codepoint() > other.codepoint()
}

recipe letter16.ge(my: letter16, other: letter16) -> bool {
    return my.codepoint() >= other.codepoint()
}

# Type conversions
recipe letter(from_letter16: letter16) -> letter {
    # Extend to full Unicode letter
    return letter(codepoint: from_letter16.codepoint() as u32)
}

recipe letter8(from_letter16: letter16) -> letter8 {
    # Truncate to ASCII (may lose information)
    return letter8(codepoint: from_letter16.codepoint() as u8)
}

recipe u16(from_letter16: letter16) -> u16 {
    return from_letter16.codepoint()
}

recipe s16(from_letter16: letter16) -> s16 {
    return from_letter16.codepoint() as s16
}

# Text conversion
recipe Text16(from_letter16: letter16) -> Text16 {
    # Convert single BMP character to Text16 string
    return ""  # Placeholder - would create single-char UTF-16 string
}

recipe letter16(from_text16: Text16) -> letter16 {
    # Extract first character from Text16 string
    return LETTER16_NULL  # Placeholder - would extract first UTF-16 char
}

# Utility recipes
recipe letter16.is_digit(my: letter16) -> bool {
    return my.is_numeric()
}

recipe letter16.is_letter(my: letter16) -> bool {
    return my.is_alphabetic()
}

recipe letter16.digit_value(my: letter16) -> s16 {
    when (my.is_numeric()) {
        true => return (my.codepoint() - 0x30) as s16,
        false => return -1
    }
}

recipe letter16.is_printable(my: letter16) -> bool {
    return not my.is_control() and not my.is_surrogate()
}

recipe letter16.is_cjk(my: letter16) -> bool {
    # Basic CJK Unified Ideographs detection (simplified)
    let cp = my.codepoint()
    return (cp >= 0x4E00 and cp <= 0x9FFF) or    # CJK Unified Ideographs
           (cp >= 0x3400 and cp <= 0x4DBF)       # CJK Extension A
}

recipe letter16.is_latin(my: letter16) -> bool {
    let cp = my.codepoint()
    return (cp >= 0x0000 and cp <= 0x007F) or    # Basic Latin
           (cp >= 0x0080 and cp <= 0x00FF) or    # Latin-1 Supplement
           (cp >= 0x0100 and cp <= 0x017F) or    # Latin Extended-A
           (cp >= 0x0180 and cp <= 0x024F)       # Latin Extended-B
}
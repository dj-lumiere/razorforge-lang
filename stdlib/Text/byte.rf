# RazorForge byte - UTF-8 code unit
#
# Represents a single byte in UTF-8 encoded text.
# In UTF-8, characters are encoded as 1-4 bytes:
# - ASCII (0x00-0x7F): 1 byte
# - Most Latin/Greek/Cyrillic: 2 bytes
# - Most CJK: 3 bytes
# - Emoji and rare characters: 4 bytes
#
# For character-level operations, use letter (Unicode codepoint).
# byte is primarily for UTF-8 I/O and storage.
#
# For legacy encodings (Latin-1, etc.), use List<u8> instead.
namespace core
import Text/Letter


record byte {
    private value: u8
}

# UTF-8 constants
preset byte_NULL: byte = byte(value: 0x00)
preset byte_SPACE: byte = byte(value: 0x20)
preset byte_NEWLINE: byte = byte(value: 0x0A)
preset byte_TAB: byte = byte(value: 0x09)

# ============================================================================
# Letter trait implementation
# ============================================================================

routine byte.codepoint(me: byte) -> u32 {
    return u32(me.value)
}

routine byte.is_valid(me: byte) -> bool {
    # In UTF-8 context, check if this is a valid lead byte or continuation byte
    let v = me.value
    # Invalid: 0xC0, 0xC1 (overlong), 0xF5-0xFF (out of Unicode range)
    return v <= 0xF4 and v != 0xC0 and v != 0xC1
}

routine byte.is_ascii(me: byte) -> bool {
    return me.value <= 0x7F
}

routine byte.is_alphabetic(me: byte) -> bool {
    let v = me.value
    return (0x41u8 <= v <= 0x5Au8) or    # A-Z
           (0x61u8 <= v <= 0x7Au8)       # a-z
}

routine byte.is_numeric(me: byte) -> bool {
    let v = me.value
    return 0x30u8 <= v <= 0x39u8  # 0-9
}

routine byte.is_alphanumeric(me: byte) -> bool {
    return me.is_alphabetic() or me.is_numeric()
}

routine byte.is_uppercase(me: byte) -> bool {
    let v = me.value
    return 0x41u8 <= v <= 0x5Au8  # A-Z
}

routine byte.is_lowercase(me: byte) -> bool {
    let v = me.value
    return 0x61u8 <= v <= 0x7Au8  # a-z
}

routine byte.is_whitespace(me: byte) -> bool {
    let v = me.value
    return v == 0x20 or    # Space
           v == 0x09 or    # Tab
           v == 0x0A or    # Line feed
           v == 0x0D or    # Carriage return
           v == 0x0C       # Form feed
}

routine byte.is_control(me: byte) -> bool {
    let v = me.value
    return v <= 0x1F or v == 0x7F
}

routine byte.to_uppercase(me: byte) -> byte {
    if me.is_lowercase() {
        return byte(value: me.value - 32u8)
    }
    return me
}

routine byte.to_lowercase(me: byte) -> byte {
    if me.is_uppercase() {
        return byte(value: me.value + 32u8)
    }
    return me
}

# ============================================================================
# UTF-8 specific methods
# ============================================================================

# Check if this byte is a UTF-8 lead byte (starts a multi-byte sequence)
routine byte.is_lead_byte(me: byte) -> bool {
    let v = me.value
    return v < 0x80u8 or (0xC2u8 <= v <= 0xF4u8)
}

# Check if this byte is a UTF-8 continuation byte
routine byte.is_continuation_byte(me: byte) -> bool {
    let v = me.value
    return (v & 0xC0) == 0x80  # 10xxxxxx pattern
}

# Get the number of bytes in the UTF-8 sequence starting with this byte
# Returns 0 if this is not a valid lead byte
routine byte.sequence_length(me: byte) -> u8 {
    let v = me.value
    when true {
        v < 0x80 => return 1u8,           # ASCII
        v < 0xC2 => return 0u8,           # Invalid lead byte
        v < 0xE0 => return 2u8,           # 2-byte sequence
        v < 0xF0 => return 3u8,           # 3-byte sequence
        v <= 0xF4 => return 4u8,          # 4-byte sequence
        _ => return 0u8                    # Invalid
    }
}

# ============================================================================
# Comparison operations
# ============================================================================

routine byte.__eq__(me: byte, other: byte) -> bool {
    return me.value == other.value
}

routine byte.__ne__(me: byte, other: byte) -> bool {
    return me.value != other.value
}

routine byte.__lt__(me: byte, other: byte) -> bool {
    return me.value < other.value
}

routine byte.__le__(me: byte, other: byte) -> bool {
    return me.value <= other.value
}

routine byte.__gt__(me: byte, other: byte) -> bool {
    return me.value > other.value
}

routine byte.__ge__(me: byte, other: byte) -> bool {
    return me.value >= other.value
}

# ============================================================================
# Type conversions
# ============================================================================

routine byte.to_u8(me: byte) -> u8 {
    return me.value
}

routine byte.to_letter16(me: byte) -> letter16 {
    # Only valid for ASCII range
    return letter16(codepoint: u16(me.value))
}

routine byte.to_letter(me: byte) -> letter {
    # Only valid for ASCII range - for multi-byte UTF-8, use Text conversion
    return letter(codepoint: u32(me.value))
}

# ============================================================================
# Utility methods
# ============================================================================

routine byte.is_digit(me: byte) -> bool {
    return me.is_numeric()
}

routine byte.is_letter(me: byte) -> bool {
    return me.is_alphabetic()
}

routine byte.digit_value(me: byte) -> s8 {
    if me.is_numeric() {
        return s8(me.value - 0x30u8)
    }
    return -1s8
}

routine byte.is_printable(me: byte) -> bool {
    let v = me.value
    return 0x20u8 <= v <= 0x7Eu8
}

routine byte.is_hex_digit(me: byte) -> bool {
    let v = me.value
    return (0x30u8 <= v <= 0x39u8) or    # 0-9
           (0x41u8 <= v <= 0x46u8) or    # A-F
           (0x61u8 <= v <= 0x66u8)       # a-f
}

routine byte.hex_value(me: byte) -> s8 {
    let v = me.value
    when true {
        0x30u8 <= v <= 0x39u8 => return s8(v - 0x30u8),  # 0-9
        0x41u8 <= v <= 0x46u8 => return s8(v - 0x37u8),  # A-F (10-15)
        0x61u8 <= v <= 0x66u8 => return s8(v - 0x57u8),  # a-f (10-15)
        _ => return -1s8
    }
}

# ============================================================================
# Codepoint offset
# ============================================================================

routine byte.offset!<I follows Integral>(me: byte, delta: I) -> byte {
    let new_value = saddr(me.value) + delta.to_saddr()
    return byte(value: u8(new_value))
}

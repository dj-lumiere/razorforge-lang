# RazorForge Text and Bytes - Immutable text types
#
# Text  - UTF-32 encoded, uses `letter` (32-bit codepoints)
#       - O(1) indexing, ideal for text manipulation
#       - Use for in-memory text editing
#
# Bytes - UTF-8 encoded, uses `byte` (8-bit code units)
#       - Compact storage, ideal for I/O
#       - Use for file/network operations
#
# Both are immutable - use TextBuffer/BytesBuffer for mutable text

import Collections/List
import memory/DynamicSlice
import memory/MemorySize
import FFI/ctypes
import FFI/cstr

# ============================================================================
# Text - UTF-32 immutable text
# ============================================================================

entity Text {
    private letters: List<letter>
}

# Constructors

routine Text.__create__() -> Text {
    return Text(letters: List<letter>())
}

routine Text.__create__(from_list: List<letter>) -> Text {
    return Text(letters: from_list)
}

routine Text.__create__(from_letter: letter) -> Text {
    let list = List<letter>()
    list.push(from_letter)
    return Text(letters: list)
}

# Core operations

routine Text.count(me: Text) -> u64 {
    return me.letters.count()
}

routine Text.is_empty(me: Text) -> bool {
    return me.letters.is_empty()
}

# Indexing

routine Text.__getitem__<I follows Integral>(me: Text, index: I) -> letter {
    return me.letters[index]
}

routine Text.__getitem__<I follows Integral>(me: Text, index: BackIndex<I>) -> letter {
    return me.letters[index]
}

routine Text.__getitem__<I follows Integral>(me: Text, range: Range<I>) -> Text {
    let sliced_list = me.letters[range]
    return Text(from_list: sliced_list)
}

routine Text.__getitem__<I follows Integral>(me: Text, range: Range<BackIndex<I>>) -> Text {
    let sliced_list = me.letters[range]
    return Text(from_list: sliced_list)
}

# String operations

routine Text.concat(me: Text, other: Text) -> Text {
    let result = List<letter>()
    var i: u64 = 0u64
    loop {
        if i >= me.count() {
            break
        }
        result.push(me[i])
        i += 1u64
    }
    i = 0u64
    loop {
        if i >= other.count() {
            break
        }
        result.push(other[i])
        i += 1u64
    }
    return Text(from_list: result)
}

routine Text.__add__(me: Text, other: Text) -> Text {
    return me.concat(other)
}

routine Text.slice(me: Text, start: u64, end: u64) -> Text {
    if start >= end or end > me.count() {
        stop!("Invalid slice range")
    }
    let result = List<letter>()
    var i = start
    loop {
        if i >= end {
            break
        }
        result.push(me[i])
        i += 1u64
    }
    return Text(from_list: result)
}

routine Text.__eq__(me: Text, other: Text) -> bool {
    if me.count() != other.count() {
        return false
    }
    var i: u64 = 0u64
    loop {
        if i >= me.count() {
            break
        }
        if me[i] != other[i] {
            return false
        }
        i += 1u64
    }
    return true
}

# Conversion to mutable

routine Text.to_buffer(me: Text) -> TextBuffer {
    let buffer = TextBuffer()
    var i: u64 = 0u64
    loop {
        if i >= me.count() {
            break
        }
        buffer.append(me[i])
        i += 1u64
    }
    return buffer
}

# Iteration

entity TextIterator {
    text: Text
    index: u64
}

routine Text.iter(me: Text) -> TextIterator {
    return TextIterator(text: me, index: 0u64)
}

routine TextIterator.next!(me: TextIterator) -> letter {
    if me.index >= me.text.count() {
        absent
    }
    let value = me.text[me.index]
    me.index = me.index + 1u64
    return value
}

# ============================================================================
# Bytes - UTF-8 immutable text
# ============================================================================

entity Bytes {
    private letters: List<byte>
}

# Constructors

routine Bytes.__create__() -> Bytes {
    return Bytes(letters: List<byte>())
}

routine Bytes.__create__(from_list: List<byte>) -> Bytes {
    return Bytes(letters: from_list)
}

routine Bytes.__create__(from_byte: byte) -> Bytes {
    let list = List<byte>()
    list.push(from_byte)
    return Bytes(letters: list)
}

routine Bytes.__create__(ptr: Snatched<byte>) -> Bytes {
    danger! {
        var len: u64 = 0u64
        loop {
            if ptr.offset(len).read() == byte_NULL {
                break
            }
            len += 1u64
        }
        let list = List<byte>(len)
        var i: u64 = 0u64
        loop {
            if i >= len {
                break
            }
            list.push(ptr.offset(i).read())
            i += 1u64
        }
        return Bytes(letters: list)
    }
}

routine Bytes.__create__(ptr: cstr) -> Bytes {
    danger! {
        let len = @native.rf_cstr_len(ptr)
        if len == 0uaddr {
            return Bytes()
        }
        let list = List<byte>(len)
        var i: uaddr = 0uaddr
        loop {
            if i >= len {
                break
            }
            let byte_ptr = ptr + i
            let byte_val = read_as!<byte>(byte_ptr)
            list.push(byte_val)
            i += 1uaddr
        }
        return Bytes(from_list: list)
    }
}

# Core operations

routine Bytes.count(me: Bytes) -> u64 {
    return me.letters.count()
}

routine Bytes.is_empty(me: Bytes) -> bool {
    return me.letters.is_empty()
}

# Indexing

routine Bytes.__getitem__<I follows Integral>(me: Bytes, index: I) -> byte {
    return me.letters[index]
}

routine Bytes.__getitem__<I follows Integral>(me: Bytes, index: BackIndex<I>) -> byte {
    return me.letters[index]
}

routine Bytes.__getitem__<I follows Integral>(me: Bytes, range: Range<I>) -> Bytes {
    let sliced_list = me.letters[range]
    return Bytes(from_list: sliced_list)
}

routine Bytes.__getitem__<I follows Integral>(me: Bytes, range: Range<BackIndex<I>>) -> Bytes {
    let sliced_list = me.letters[range]
    return Bytes(from_list: sliced_list)
}

# String operations

routine Bytes.concat(me: Bytes, other: Bytes) -> Bytes {
    let result = List<byte>()
    var i: u64 = 0u64
    loop {
        if i >= me.count() {
            break
        }
        result.push(me[i])
        i += 1u64
    }
    i = 0u64
    loop {
        if i >= other.count() {
            break
        }
        result.push(other[i])
        i += 1u64
    }
    return Bytes(from_list: result)
}

routine Bytes.__add__(me: Bytes, other: Bytes) -> Bytes {
    return me.concat(other)
}

routine Bytes.slice(me: Bytes, start: u64, end: u64) -> Bytes {
    if start >= end or end > me.count() {
        stop!("Invalid slice range")
    }
    let result = List<byte>()
    var i = start
    loop {
        if i >= end {
            break
        }
        result.push(me[i])
        i += 1u64
    }
    return Bytes(from_list: result)
}

routine Bytes.__eq__(me: Bytes, other: Bytes) -> bool {
    if me.count() != other.count() {
        return false
    }
    var i: u64 = 0u64
    loop {
        if i >= me.count() {
            break
        }
        if me[i] != other[i] {
            return false
        }
        i += 1u64
    }
    return true
}

# Conversion to mutable

routine Bytes.to_buffer(me: Bytes) -> BytesBuffer {
    let buffer = BytesBuffer()
    var i: u64 = 0u64
    loop {
        if i >= me.count() {
            break
        }
        buffer.append(me[i])
        i += 1u64
    }
    return buffer
}

# Iteration

entity BytesIterator {
    bytes: Bytes
    index: u64
}

routine Bytes.iter(me: Bytes) -> BytesIterator {
    return BytesIterator(bytes: me, index: 0u64)
}

routine BytesIterator.next!(me: BytesIterator) -> byte {
    if me.index >= me.bytes.count() {
        absent
    }
    let value = me.bytes[me.index]
    me.index = me.index + 1u64
    return value
}

# ============================================================================
# Encoding Conversions
# ============================================================================

# Text (UTF-32) -> Bytes (UTF-8)
routine Text.to_utf8(me: Text) -> Bytes {
    let result = List<byte>()
    let len = me.count()
    var i: u64 = 0u64
    loop {
        if i >= len {
            break
        }
        let current_letter = me[i]
        let codepoint = current_letter.codepoint()
        when {
            codepoint <= 0x7Fu32 => {
                result.push(byte(codepoint: u8(codepoint)))
            }
            codepoint <= 0x7FFu32 => {
                result.push(byte(codepoint: u8!(0xC0u32 | (codepoint >> 6u32))))
                result.push(byte(codepoint: u8!(0x80u32 | (codepoint & 0x3Fu32))))
            }
            codepoint <= 0xFFFFu32 => {
                result.push(byte(codepoint: u8!(0xE0u32 | (codepoint >> 12u32))))
                result.push(byte(codepoint: u8!(0x80u32 | ((codepoint >> 6u32) & 0x3Fu32))))
                result.push(byte(codepoint: u8!(0x80u32 | (codepoint & 0x3Fu32))))
            }
            _ => {
                result.push(byte(codepoint: u8!(0xF0u32 | (codepoint >> 18u32))))
                result.push(byte(codepoint: u8!(0x80u32 | ((codepoint >> 12u32) & 0x3Fu32))))
                result.push(byte(codepoint: u8!(0x80u32 | ((codepoint >> 6u32) & 0x3Fu32))))
                result.push(byte(codepoint: u8!(0x80u32 | (codepoint & 0x3Fu32))))
            }
        }
        i += 1u64
    }
    return Bytes(from_list: result)
}

# Bytes (UTF-8) -> Text (UTF-32)
routine Bytes.to_text(me: Bytes) -> Text {
    let result = List<letter>()
    let len = me.count()
    var i: u64 = 0u64
    loop {
        if i >= len {
            break
        }
        let b0 = u32(me[i].codepoint())
        var codepoint: u32 = 0u32
        when {
            (b0 & 0x80u32) == 0u32 => {
                codepoint = b0
                i += 1u64
            }
            (b0 & 0xE0u32) == 0xC0u32 => {
                if i + 1u64 < len {
                    let b1 = u32(me[i + 1u64].codepoint())
                    codepoint = ((b0 & 0x1Fu32) << 6u32) | (b1 & 0x3Fu32)
                    i += 2u64
                } else {
                    codepoint = 0xFFFDu32
                    i += 1u64
                }
            }
            (b0 & 0xF0u32) == 0xE0u32 => {
                if i + 2u64 < len {
                    let b1 = u32(me[i + 1u64].codepoint())
                    let b2 = u32(me[i + 2u64].codepoint())
                    codepoint = ((b0 & 0x0Fu32) << 12u32) | ((b1 & 0x3Fu32) << 6u32) | (b2 & 0x3Fu32)
                    i += 3u64
                } else {
                    codepoint = 0xFFFDu32
                    i += 1u64
                }
            }
            (b0 & 0xF8u32) == 0xF0u32 => {
                if i + 3u64 < len {
                    let b1 = u32(me[i + 1u64].codepoint())
                    let b2 = u32(me[i + 2u64].codepoint())
                    let b3 = u32(me[i + 3u64].codepoint())
                    codepoint = ((b0 & 0x07u32) << 18u32) | ((b1 & 0x3Fu32) << 12u32) | ((b2 & 0x3Fu32) << 6u32) | (b3 & 0x3Fu32)
                    i += 4u64
                } else {
                    codepoint = 0xFFFDu32
                    i += 1u64
                }
            }
            _ => {
                codepoint = 0xFFFDu32
                i += 1u64
            }
        }
        result.push(letter(codepoint: codepoint))
    }
    return Text(from_list: result)
}

# ============================================================================
# C-String Interop
# ============================================================================

# Bytes -> null-terminated C string (UTF-8)
routine Bytes.to_cstr(me: Bytes) -> uaddr {
    let len = me.count()
    let buffer = DynamicSlice(MemorySize(len + 1u64))
    var i: u64 = 0u64
    loop {
        if i >= len {
            break
        }
        buffer.write!<byte>(i, me[i])
        i += 1u64
    }
    buffer.write!<byte>(len, byte_NULL)
    return buffer.snatch(0u64)
}

# Text -> null-terminated C string (UTF-8 encoded)
routine Text.to_cstr(me: Text) -> uaddr {
    let bytes = me.to_utf8()
    return bytes.to_cstr()
}

# ============================================================================
# UTF-16 Conversion (for Windows interop)
# ============================================================================

# Text (UTF-32) -> List<u16> (UTF-16)
routine Text.to_utf16(me: Text) -> List<u16> {
    let result = List<u16>()
    let len = me.count()
    var i: u64 = 0u64
    loop {
        if i >= len {
            break
        }
        let codepoint = me[i].codepoint()
        if codepoint <= 0xFFFFu32 {
            result.push(u16(codepoint))
        } else {
            let cp = codepoint - 0x10000u32
            result.push(u16((cp >> 10u32) + 0xD800u32))
            result.push(u16((cp & 0x3FFu32) + 0xDC00u32))
        }
        i += 1u64
    }
    return result
}

# List<u16> (UTF-16) -> Text (UTF-32)
routine Text.from_utf16(utf16: List<u16>) -> Text {
    let result = List<letter>()
    let len = utf16.count()
    var i: u64 = 0u64
    loop {
        if i >= len {
            break
        }
        let w1 = u32(utf16[i])
        if w1 < 0xD800u32 or w1 > 0xDFFFu32 {
            result.push(letter(codepoint: w1))
            i += 1u64
        } else if 0xD800u32 <= w1 <= 0xDBFFu32 and i + 1u64 < len {
            let w2 = u32(utf16[i + 1u64])
            if 0xDC00u32 <= w2 <= 0xDFFFu32 {
                let codepoint = ((w1 - 0xD800u32) << 10u32) + (w2 - 0xDC00u32) + 0x10000u32
                result.push(letter(codepoint: codepoint))
                i += 2u64
            } else {
                result.push(letter(codepoint: 0xFFFDu32))
                i += 1u64
            }
        } else {
            result.push(letter(codepoint: 0xFFFDu32))
            i += 1u64
        }
    }
    return Text(from_list: result)
}

# RazorForge Text<T> - Generic immutable text type
# Entity type with heap allocation
# T can be letter (32-bit), letter8 (8-bit), or letter16 (16-bit)
# Immutable - use TextBuffer<T> for mutable text

import Collections/List
import memory/DynamicSlice
import memory/MemorySize

entity Text<T> {
    private letters: List<T>  # Dynamic array of letters
}

# Constructors

routine Text<T>.__create__() -> Text<T> {
    # Create empty text
    return Text<T>(letters: List<T>())
}

routine Text<T>.__create__(from_list: List<T>) -> Text<T> {
    # Create text from list of letters
    return Text<T>(letters: from_list)
}


routine Text<T>.__create__(from_letter: T) -> Text<T> {
    # Create text from single letter
    let list = List<T>()
    list.push(from_letter)
    return Text<T>(letters: list)
}

# Core operations

routine Text<T>.length(me: Text<T>) -> u64 {
    # Get length in characters (letters/codepoints)
    return me.letters.len()
}

routine Text<T>.is_empty(me: Text<T>) -> bool {
    return me.letters.is_empty()
}

routine Text<T>.get(me: Text<T>, index: u64) -> T {
    # Get letter at index - O(1)
    # Text is immutable so this is read-only
    return me.letters.get(index)
}

# String operations (all create new Text - immutable!)

routine Text<T>.concat(me: Text<T>, other: Text<T>) -> Text<T> {
    # Concatenate two texts - creates NEW text
    let result = List<T>()

    # Copy first text
    var i: u64 = 0u64
    loop {
        if i >= me.length() {
            break
        }
        result.push(me.get(i))
        i = i + 1u64
    }

    # Copy second text
    i = 0u64
    loop {
        if i >= other.length() {
            break
        }
        result.push(other.get(i))
        i = i + 1u64
    }

    return Text<T>(from_list: result)
}

routine Text<T>.slice(me: Text<T>, start: u64, end: u64) -> Text<T> {
    # Get substring [start, end) - creates NEW text
    if start >= end or end > me.length() {
        crash("Invalid slice range")
    }

    let result = List<T>()
    var i = start
    loop {
        if i >= end {
            break
        }
        result.push(me.get(i))
        i = i + 1u64
    }

    return Text<T>(from_list: result)
}

routine Text<T>.__eq__(me: Text<T>, other: Text<T>) -> bool {
    # Compare texts for equality
    if me.length() != other.length() {
        return false
    }

    var i: u64 = 0u64
    loop {
        if i >= me.length() {
            break
        }

        if me.get(i) != other.get(i) {
            return false
        }

        i = i + 1u64
    }

    return true
}

# Conversion

routine Text<T>.to_buffer(me: Text<T>) -> TextBuffer<T> {
    # Convert immutable Text to mutable TextBuffer
    let buffer = TextBuffer<T>()

    var i: u64 = 0u64
    loop {
        if i >= me.length() {
            break
        }
        buffer.append(me.get(i))
        i = i + 1u64
    }

    return buffer
}

# Iteration support

routine Text<T>.iter(me: Text<T>) -> TextIterator<T> {
    return TextIterator<T> {
        text: me,
        index: 0u64
    }
}

record TextIterator<T> {
    text: Text<T>
    index: u64
}

routine TextIterator<T>.next(me: TextIterator<T>) -> T? {
    if me.index >= me.text.length() {
        return none
    }
    let value = me.text.get(me.index)
    me.index = me.index + 1u64
    return some(value)
}

# C-String Conversion (for runtime interop)

routine Text<letter8>.to_cstr(me: Text<letter8>) -> uaddr {
    # Convert Text<letter8> to null-terminated C string
    # Returns pointer to newly allocated memory (caller must free)
    let len = me.length()
    let buffer = DynamicSlice(MemorySize(len + 1u64))  # +1 for null terminator

    # Copy characters
    var i: u64 = 0u64
    loop {
        if i >= len {
            break
        }
        buffer.write<letter8>!(i, me.get(i))
        i = i + 1u64
    }

    # Add null terminator
    buffer.write<letter8>!(len, 0u8)

    # Return raw pointer (caller owns the memory)
    return buffer.snatch!(0u64)
}

routine Text<letter32>.to_cstr(me: Text<letter>) -> uaddr {
    # Convert Text<letter32> (UTF-32) to null-terminated UTF-8 C string
    # Returns pointer to newly allocated memory (caller must free)
    # Note: Each letter (u32 codepoint) may need 1-4 bytes in UTF-8
    let len = me.length()

    # Worst case: 4 bytes per codepoint + null terminator
    let max_size = (len * 4u64) + 1u64
    let buffer = DynamicSlice(MemorySize(max_size))

    var write_pos: u64 = 0u64
    var i: u64 = 0u64
    loop {
        if i >= len {
            break
        }
        let codepoint = u32!(me.get(i))

        when true {
            codepoint <= 0x7Fu32 => {
                # 1-byte UTF-8 (ASCII)
                buffer.write<u8>!(write_pos, u8!(codepoint))
                write_pos = write_pos + 1u64
            }
            codepoint <= 0x7FFu32 => {
                # 2-byte UTF-8
                buffer.write<u8>!(write_pos, u8!(0xC0u32 | (codepoint >> 6u32)))
                buffer.write<u8>!(write_pos + 1u64, u8!(0x80u32 | (codepoint & 0x3Fu32)))
                write_pos = write_pos + 2u64
            }
            codepoint <= 0xFFFFu32 => {
                # 3-byte UTF-8
                buffer.write<u8>!(write_pos, u8!(0xE0u32 | (codepoint >> 12u32)))
                buffer.write<u8>!(write_pos + 1u64, u8!(0x80u32 | ((codepoint >> 6u32) & 0x3Fu32)))
                buffer.write<u8>!(write_pos + 2u64, u8!(0x80u32 | (codepoint & 0x3Fu32)))
                write_pos = write_pos + 3u64
            }
            _ => {
                # 4-byte UTF-8
                buffer.write<u8>!(write_pos, u8!(0xF0u32 | (codepoint >> 18u32)))
                buffer.write<u8>!(write_pos + 1u64, u8!(0x80u32 | ((codepoint >> 12u32) & 0x3Fu32)))
                buffer.write<u8>!(write_pos + 2u64, u8!(0x80u32 | ((codepoint >> 6u32) & 0x3Fu32)))
                buffer.write<u8>!(write_pos + 3u64, u8!(0x80u32 | (codepoint & 0x3Fu32)))
                write_pos = write_pos + 4u64
            }
        }

        i = i + 1u64
    }

    # Add null terminator
    buffer.write<u8>!(write_pos, 0u8)

    # Return raw pointer (caller owns the memory)
    return buffer.snatch!(0u64)
}

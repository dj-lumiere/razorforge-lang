# RazorForge u128 (unsigned 128-bit integer) native type implementation
# Maps directly to LLVM i128 type using compiler intrinsics

# Core u128 type definition - maps to LLVM i128
record u128 {
    public value: LlvmNativeI128
}

# Constants for u128 limits
preset U128_MIN: u128 = 0_u128
preset U128_MAX: u128 = 340282366920938463463374607431768211455_u128
preset U128_ZERO: u128 = 0_u128
preset U128_ONE: u128 = 1_u128

# ============================================================================
# Checked Constructors (crash on overflow)
# ============================================================================

# Failable constructor from Text - called as u128!(text)
# Compiler automatically generates try_u128.__create__(text) -> Maybe<u128>
routine u128.__create__!(from_text: Text<Letterlikes>) -> u128 {
    danger! {
        return @parse_u128(from_text)
    }
}

# From s8 - crashes if value is negative
routine u128.__create__!(from: s8) -> u128 {
    if from < 0_s8 {
        throw IntegerOverflowError(f"Cannot convert {from} to u128: value out of range [{U128_MIN}, {U128_MAX}]")
    }
    danger! {
        return @intrinsic.sext<i8, i128>(from)
    }
}

# From s16 - crashes if value is negative
routine u128.__create__!(from: s16) -> u128 {
    if from < 0_s16 {
        throw IntegerOverflowError(f"Cannot convert {from} to u128: value out of range [{U128_MIN}, {U128_MAX}]")
    }
    danger! {
        return @intrinsic.sext<i16, i128>(from)
    }
}

# From s32 - crashes if value is negative
routine u128.__create__!(from: s32) -> u128 {
    if from < 0_s32 {
        throw IntegerOverflowError(f"Cannot convert {from} to u128: value out of range [{U128_MIN}, {U128_MAX}]")
    }
    danger! {
        return @intrinsic.sext<i32, i128>(from)
    }
}

# From s64 - crashes if value is negative
routine u128.__create__!(from: s64) -> u128 {
    if from < 0_s64 {
        throw IntegerOverflowError(f"Cannot convert {from} to u128: value out of range [{U128_MIN}, {U128_MAX}]")
    }
    danger! {
        return @intrinsic.sext<i64, i128>(from)
    }
}

# From s128 - crashes if value is negative
routine u128.__create__!(from: s128) -> u128 {
    if from < 0_s128 {
        throw IntegerOverflowError(f"Cannot convert {from} to u128: value out of range [{U128_MIN}, {U128_MAX}]")
    }
    danger! {
        return @intrinsic.bitcast<i128, i128>(from)
    }
}

# ============================================================================
# Arithmetic Operations (trapping on overflow by default)
# ============================================================================

routine u128.__add__(other: u128) -> u128 {
    danger! {
        return @intrinsic.add<i128>(me, other)
    }
}

routine u128.__sub__(other: u128) -> u128 {
    danger! {
        return @intrinsic.sub<i128>(me, other)
    }
}

routine u128.__mul__(other: u128) -> u128 {
    danger! {
        return @intrinsic.mul<i128>(me, other)
    }
}

routine u128.__floordiv__(other: u128) -> u128 {
    danger! {
        return @intrinsic.udiv<i128>(me, other)
    }
}

routine u128.__mod__(other: u128) -> u128 {
    danger! {
        return @intrinsic.urem<i128>(me, other)
    }
}

# ============================================================================
# Wrapping Arithmetic (+%, -%, *%)
# ============================================================================

routine u128.__add_wrap__(other: u128) -> u128 {
    danger! {
        return @intrinsic.add.wrapping<i128>(me, other)
    }
}

routine u128.__sub_wrap__(other: u128) -> u128 {
    danger! {
        return @intrinsic.sub.wrapping<i128>(me, other)
    }
}

routine u128.__mul_wrap__(other: u128) -> u128 {
    danger! {
        return @intrinsic.mul.wrapping<i128>(me, other)
    }
}

# ============================================================================
# Saturating Arithmetic (+^, -^, *^)
# ============================================================================

routine u128.__add_sat__(other: u128) -> u128 {
    danger! {
        return @intrinsic.add.saturating<i128>(me, other)
    }
}

routine u128.__sub_sat__(other: u128) -> u128 {
    danger! {
        return @intrinsic.sub.saturating<i128>(me, other)
    }
}

routine u128.__mul_sat__(other: u128) -> u128 {
    danger! {
        return @intrinsic.mul.saturating<i128>(me, other)
    }
}

# ============================================================================
# Checked Arithmetic (+?, -?, *?) - returns Maybe<T>
# ============================================================================

routine u128.__add_checked__(other: u128) -> Maybe<u128> {
    danger! {
        let (result, overflow) = @intrinsic.add.overflow<i128>(me, other)
        return if overflow { None } else { result }
    }
}

routine u128.__sub_checked__(other: u128) -> Maybe<u128> {
    danger! {
        let (result, overflow) = @intrinsic.sub.overflow<i128>(me, other)
        return if overflow { None } else { result }
    }
}

routine u128.__mul_checked__(other: u128) -> Maybe<u128> {
    danger! {
        let (result, overflow) = @intrinsic.mul.overflow<i128>(me, other)
        return if overflow { None } else { result }
    }
}

# ============================================================================
# Bitwise Operations
# ============================================================================

routine u128.__and__(other: u128) -> u128 {
    danger! {
        return @intrinsic.and<i128>(me, other)
    }
}

routine u128.__or__(other: u128) -> u128 {
    danger! {
        return @intrinsic.or<i128>(me, other)
    }
}

routine u128.__xor__(other: u128) -> u128 {
    danger! {
        return @intrinsic.xor<i128>(me, other)
    }
}

routine u128.__not__() -> u128 {
    danger! {
        return @intrinsic.not<i128>(me)
    }
}

routine u128.__shl__(bits: u32) -> u128 {
    danger! {
        return @intrinsic.shl<i128>(me, bits)
    }
}

routine u128.__shr__(bits: u32) -> u128 {
    danger! {
        return @intrinsic.lshr<i128>(me, bits)
    }
}

# ============================================================================
# Comparison Operations
# ============================================================================

routine u128.__eq__(other: u128) -> bool {
    danger! {
        return @intrinsic.icmp.eq<i128>(me, other)
    }
}

routine u128.__ne__(other: u128) -> bool {
    danger! {
        return @intrinsic.icmp.ne<i128>(me, other)
    }
}

routine u128.__lt__(other: u128) -> bool {
    danger! {
        return @intrinsic.icmp.ult<i128>(me, other)
    }
}

routine u128.__le__(other: u128) -> bool {
    danger! {
        return @intrinsic.icmp.ule<i128>(me, other)
    }
}

routine u128.__gt__(other: u128) -> bool {
    danger! {
        return @intrinsic.icmp.ugt<i128>(me, other)
    }
}

routine u128.__ge__(other: u128) -> bool {
    danger! {
        return @intrinsic.icmp.uge<i128>(me, other)
    }
}

# ============================================================================
# Math Operations
# ============================================================================

routine u128.min(other: u128) -> u128 {
    return if me <= other then me else other
}

routine u128.max(other: u128) -> u128 {
    return if me >= other then me else other
}

routine u128.clamp(min_val: u128, max_val: u128) -> u128 {
    return me.min(max_val).max(min_val)
}

# ============================================================================
# Bit Manipulation
# ============================================================================

routine u128.count_ones() -> u128 {
    danger! {
        return @intrinsic.ctpop<i128>(me)
    }
}

routine u128.count_zeros() -> u128 {
    return 128_u128 - me.count_ones()
}

routine u128.leading_zeros() -> u128 {
    danger! {
        return @intrinsic.ctlz<i128>(me)
    }
}

routine u128.trailing_zeros() -> u128 {
    danger! {
        return @intrinsic.cttz<i128>(me)
    }
}

routine u128.leading_ones() -> u128 {
    return me.__not__().leading_zeros()
}

routine u128.trailing_ones() -> u128 {
    return me.__not__().trailing_zeros()
}

routine u128.reverse_bits() -> u128 {
    danger! {
        return @intrinsic.bitreverse<i128>(me)
    }
}

routine u128.swap_bytes() -> u128 {
    danger! {
        return @intrinsic.bswap<i128>(me)
    }
}

routine u128.is_power_of_two() -> bool {
    return me != 0_u128 and (me & (me - 1_u128)) == 0_u128
}

# ============================================================================
# Type Conversions (constructor syntax)
# ============================================================================

# Bitcast to signed
routine s128(from: u128) -> s128 {
    danger! {
        return @intrinsic.bitcast<i128, i128>(from)
    }
}

# Truncate to smaller types
routine u64(from: u128) -> u64 {
    danger! {
        return @intrinsic.trunc<i128, i64>(from)
    }
}

routine u32(from: u128) -> u32 {
    danger! {
        return @intrinsic.trunc<i128, i32>(from)
    }
}

routine u16(from: u128) -> u16 {
    danger! {
        return @intrinsic.trunc<i128, i16>(from)
    }
}

routine u8(from: u128) -> u8 {
    danger! {
        return @intrinsic.trunc<i128, i8>(from)
    }
}

# Convert to floating point
routine f32(from: u128) -> f32 {
    danger! {
        return @intrinsic.uitofp<i128, float>(from)
    }
}

routine f64(from: u128) -> f64 {
    danger! {
        return @intrinsic.uitofp<i128, double>(from)
    }
}

# Convert to boolean
routine bool(from: u128) -> bool {
    danger! {
        return @intrinsic.icmp.ne<i128>(from, 0_u128)
    }
}

# ============================================================================
# Utility Methods
# ============================================================================

routine u128.is_zero() -> bool {
    return me == 0_u128
}

routine u128.is_even() -> bool {
    danger! {
        let result = @intrinsic.and<i128>(me, 1_u128)
        return @intrinsic.icmp.eq<i128>(result, 0_u128)
    }
}

routine u128.is_odd() -> bool {
    return not me.is_even()
}

# High/low 64-bit extraction utilities
routine u128.high64() -> u64 {
    danger! {
        let shifted = @intrinsic.lshr<i128>(me, 64_u32)
        return @intrinsic.trunc<i128, i64>(shifted)
    }
}

routine u128.low64() -> u64 {
    danger! {
        return @intrinsic.trunc<i128, i64>(me)
    }
}

# ============================================================================
# String Conversion
# ============================================================================

routine u128.to_text() -> Text {
    danger! {
        return @format_u128(me)
    }
}

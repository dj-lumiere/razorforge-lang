# RazorForge uaddr (system-sized unsigned integer) native type implementation
# Maps to LLVM pointer-sized integer - u32 on 32-bit, u64 on 64-bit platforms
# Used for array indices, sizes, and pointer arithmetic

# Core uaddr type definition - maps to LLVM iptr/usize
record uaddr {
    public value: LlvmNativePtrSizedUInt
}

# ============================================================================
# Arithmetic Operations (system types use wrapping by default)
# ============================================================================

# Default operators use wrapping arithmetic for system types
routine uaddr.__add__(other: uaddr) -> uaddr {
    danger! {
        return @intrinsic.add.wrapping<uptr>(me, other)
    }
}

routine uaddr.__sub__(other: uaddr) -> uaddr {
    danger! {
        return @intrinsic.sub.wrapping<uptr>(me, other)
    }
}

routine uaddr.__mul__(other: uaddr) -> uaddr {
    danger! {
        return @intrinsic.mul.wrapping<uptr>(me, other)
    }
}

routine uaddr.__floordiv__(other: uaddr) -> uaddr {
    danger! {
        return @intrinsic.udiv<uptr>(me, other)
    }
}

routine uaddr.__mod__(other: uaddr) -> uaddr {
    danger! {
        return @intrinsic.urem<uptr>(me, other)
    }
}

# ============================================================================
# Bitwise Operations
# ============================================================================

routine uaddr.__and__(other: uaddr) -> uaddr {
    danger! {
        return @intrinsic.and<uptr>(me, other)
    }
}

routine uaddr.__or__(other: uaddr) -> uaddr {
    danger! {
        return @intrinsic.or<uptr>(me, other)
    }
}

routine uaddr.__xor__(other: uaddr) -> uaddr {
    danger! {
        return @intrinsic.xor<uptr>(me, other)
    }
}

routine uaddr.__not__() -> uaddr {
    danger! {
        return @intrinsic.not<uptr>(me)
    }
}

routine uaddr.__shl__(bits: u32) -> uaddr {
    danger! {
        return @intrinsic.shl<uptr>(me, bits)
    }
}

routine uaddr.__shr__(bits: u32) -> uaddr {
    danger! {
        return @intrinsic.lshr<uptr>(me, bits)
    }
}

# ============================================================================
# Comparison Operations
# ============================================================================

routine uaddr.__eq__(other: uaddr) -> bool {
    danger! {
        return @intrinsic.icmp.eq<uptr>(me, other)
    }
}

routine uaddr.__ne__(other: uaddr) -> bool {
    danger! {
        return @intrinsic.icmp.ne<uptr>(me, other)
    }
}

routine uaddr.__lt__(other: uaddr) -> bool {
    danger! {
        return @intrinsic.icmp.ult<uptr>(me, other)
    }
}

routine uaddr.__le__(other: uaddr) -> bool {
    danger! {
        return @intrinsic.icmp.ule<uptr>(me, other)
    }
}

routine uaddr.__gt__(other: uaddr) -> bool {
    danger! {
        return @intrinsic.icmp.ugt<uptr>(me, other)
    }
}

routine uaddr.__ge__(other: uaddr) -> bool {
    danger! {
        return @intrinsic.icmp.uge<uptr>(me, other)
    }
}

# ============================================================================
# Math Operations
# ============================================================================

routine uaddr.min(other: uaddr) -> uaddr {
    return if me <= other then me else other
}

routine uaddr.max(other: uaddr) -> uaddr {
    return if me >= other then me else other
}

routine uaddr.is_power_of_two() -> bool {
    return me != 0 and (me & (me - 1)) == 0
}

# ============================================================================
# Type Conversions (constructor syntax)
# ============================================================================

routine saddr(from: uaddr) -> saddr {
    danger! {
        return @intrinsic.bitcast<iptr>(from)
    }
}

routine u64(from: uaddr) -> u64 {
    danger! {
        return @intrinsic.zext<i64>(from)
    }
}

routine bool(from: uaddr) -> bool {
    return from != 0
}

# ============================================================================
# String Conversion
# ============================================================================

routine uaddr.to_text() -> Text {
    danger! {
        return @format_uaddr(me)
    }
}

# Parsing constructors using compiler intrinsics

# Fallible constructor - crashes on invalid input
routine uaddr!(from_text: Text) -> uaddr {
    danger! {
        return @parse_uaddr(from_text)
    }
}

# Safe constructor - returns Maybe<uaddr>
routine uaddr?(from_text: Text) -> Maybe<uaddr> {
    danger! {
        return @try_parse_uaddr(from_text)
    }
}

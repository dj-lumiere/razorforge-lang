# RazorForge f32 (single precision floating point) native type implementation
# Maps directly to LLVM float type using compiler intrinsics

# Core f32 type definition - maps to LLVM float
record f32 {
    public value: LlvmNativeFloat
}

# IEEE 754 single precision constants
preset F32_EPSILON: f32 = 1.1920929e-7_f32
preset F32_MIN: f32 = -3.4028235e+38_f32
preset F32_MAX: f32 = 3.4028235e+38_f32
preset F32_MIN_POSITIVE: f32 = 1.1754944e-38_f32
preset F32_ZERO: f32 = 0.0_f32
preset F32_ONE: f32 = 1.0_f32

# Mathematical constants
preset F32_PI: f32 = 3.1415927_f32
preset F32_E: f32 = 2.7182817_f32
preset F32_SQRT_2: f32 = 1.4142135_f32
preset F32_LN_2: f32 = 0.6931472_f32
preset F32_LN_10: f32 = 2.3025851_f32

# Failable constructor from Text - called as f32!(text)
# Compiler automatically generates try_f32.__create__(text) -> Maybe<f32>
routine f32.__create__!(from_text: Text<Letterlikes>) -> f32 {
    danger! {
        return @parse_f32(from_text)
    }
}

# ============================================================================
# Arithmetic Operations (IEEE 754 semantics)
# ============================================================================

routine f32.__add__(other: f32) -> f32 {
    danger! {
        return @intrinsic.add.wrapping<float>(me, other)
    }
}

routine f32.__sub__(other: f32) -> f32 {
    danger! {
        return @intrinsic.sub.wrapping<float>(me, other)
    }
}

routine f32.__mul__(other: f32) -> f32 {
    danger! {
        return @intrinsic.mul.wrapping<float>(me, other)
    }
}

routine f32.__div__(other: f32) -> f32 {
    danger! {
        return @intrinsic.div.wrapping<float>(me, other)
    }
}

routine f32.__rem__(other: f32) -> f32 {
    danger! {
        return @intrinsic.rem.wrapping<float>(me, other)
    }
}

routine f32.__neg__() -> f32 {
    danger! {
        return @intrinsic.sub.wrapping<float>(0.0_f32, me)
    }
}

# ============================================================================
# Comparison Operations (ordered - false if NaN)
# ============================================================================

routine f32.__eq__(other: f32) -> bool {
    danger! {
        return @intrinsic.fcmp.oeq<float>(me, other)
    }
}

routine f32.__ne__(other: f32) -> bool {
    danger! {
        return @intrinsic.fcmp.one<float>(me, other)
    }
}

routine f32.__lt__(other: f32) -> bool {
    danger! {
        return @intrinsic.fcmp.olt<float>(me, other)
    }
}

routine f32.__le__(other: f32) -> bool {
    danger! {
        return @intrinsic.fcmp.ole<float>(me, other)
    }
}

routine f32.__gt__(other: f32) -> bool {
    danger! {
        return @intrinsic.fcmp.ogt<float>(me, other)
    }
}

routine f32.__ge__(other: f32) -> bool {
    danger! {
        return @intrinsic.fcmp.oge<float>(me, other)
    }
}

# ============================================================================
# Math Operations using intrinsics
# ============================================================================

routine f32.sqrt() -> f32 {
    danger! {
        return @intrinsic.sqrt<float>(me)
    }
}

routine f32.abs() -> f32 {
    danger! {
        return @intrinsic.fabs<float>(me)
    }
}

routine f32.floor() -> f32 {
    danger! {
        return @intrinsic.floor<float>(me)
    }
}

routine f32.ceil() -> f32 {
    danger! {
        return @intrinsic.ceil<float>(me)
    }
}

routine f32.round() -> f32 {
    danger! {
        return @intrinsic.round<float>(me)
    }
}

routine f32.trunc() -> f32 {
    danger! {
        return @intrinsic.trunc_float<float>(me)
    }
}

# Trigonometric functions
routine f32.sin() -> f32 {
    danger! {
        return @intrinsic.sin<float>(me)
    }
}

routine f32.cos() -> f32 {
    danger! {
        return @intrinsic.cos<float>(me)
    }
}

# Exponential and logarithmic
routine f32.exp() -> f32 {
    danger! {
        return @intrinsic.exp<float>(me)
    }
}

routine f32.log() -> f32 {
    danger! {
        return @intrinsic.log<float>(me)
    }
}

routine f32.log10() -> f32 {
    danger! {
        return @intrinsic.log10<float>(me)
    }
}

routine f32.pow(exp: f32) -> f32 {
    danger! {
        return @intrinsic.pow<float>(me, exp)
    }
}

routine f32.copysign(sign: f32) -> f32 {
    danger! {
        return @intrinsic.copysign<float>(me, sign)
    }
}

# ============================================================================
# Utility Methods
# ============================================================================

routine f32.min(other: f32) -> f32 {
    return if me <= other then me else other
}

routine f32.max(other: f32) -> f32 {
    return if me >= other then me else other
}

routine f32.clamp(min_val: f32, max_val: f32) -> f32 {
    return me.min(max_val).max(min_val)
}

routine f32.is_positive() -> bool {
    return me > 0.0_f32
}

routine f32.is_negative() -> bool {
    return me < 0.0_f32
}

routine f32.is_zero() -> bool {
    return me == 0.0_f32
}

routine f32.signum() -> f32 {
    when {
        me > 0.0_f32 => 1.0_f32,
        me < 0.0_f32 => -1.0_f32,
        _ => 0.0_f32
    }
}

# ============================================================================
# Type Conversions
# ============================================================================

routine f32.to_s32() -> s32 {
    danger! {
        return @intrinsic.fptosi<float, i32>(me)
    }
}

routine f32.to_u32() -> u32 {
    danger! {
        return @intrinsic.fptoui<float, i32>(me)
    }
}

routine f32.to_s64() -> s64 {
    danger! {
        return @intrinsic.fptosi<float, i64>(me)
    }
}

routine f32.to_u64() -> u64 {
    danger! {
        return @intrinsic.fptoui<float, i64>(me)
    }
}

routine f32.to_f16() -> f16 {
    danger! {
        return @intrinsic.fptrunc<float, half>(me)
    }
}

routine f32.to_f64() -> f64 {
    danger! {
        return @intrinsic.fpext<float, double>(me)
    }
}

# Reinterpret bits as u32 (type punning)
routine f32.to_bits() -> u32 {
    danger! {
        return @intrinsic.bitcast<float, i32>(me)
    }
}

# Create f32 from u32 bits (type punning)
routine f32.from_bits(bits: u32) -> f32 {
    danger! {
        return @intrinsic.bitcast<i32, float>(bits)
    }
}

# ============================================================================
# String Conversion
# ============================================================================

routine f32.to_text() -> Text {
    danger! {
        return @format_f32(me)
    }
}

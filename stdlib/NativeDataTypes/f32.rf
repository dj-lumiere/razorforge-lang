# RazorForge f32 (single precision floating point) native type implementation
# Maps directly to LLVM float type using compiler intrinsics
namespace core
# Core f32 type definition - maps to LLVM float
record f32 {
    public value: LlvmNativeFloat
}

# IEEE 754 single precision constants
preset F32_EPSILON: f32 = 1.1920929e-7_f32
preset F32_MIN: f32 = -3.4028235e+38_f32
preset F32_MAX: f32 = 3.4028235e+38_f32
preset F32_MIN_POSITIVE: f32 = 1.1754944e-38_f32
preset F32_ZERO: f32 = 0.0_f32
preset F32_ONE: f32 = 1.0_f32

# Mathematical constants
preset F32_PI: f32 = 3.1415927_f32
preset F32_E: f32 = 2.7182817_f32
preset F32_SQRT_2: f32 = 1.4142135_f32
preset F32_LN_2: f32 = 0.6931472_f32
preset F32_LN_10: f32 = 2.3025851_f32

imported routine rf_f32_to_d32(x: f32) -> u32
imported routine rf_f32_to_d64(x: f32) -> u64
imported routine rf_f32_to_d128(x: f32) -> d128
imported routine rf_d32_to_f32(x: u32) -> f32
imported routine rf_d64_to_f32(x: u64) -> f32
imported routine rf_d128_to_f32(low: u64, high: u64) -> f32

# Failable constructor from Text - called as f32!(text)
# Compiler automatically generates try_f32.__create__(text) -> Maybe<f32>
routine f32.__create__!(from_text: Text<Letterlikes>) -> f32 {
    danger! {
        return @parse_f32(from_text)
    }
}

routine f32.__create__(from: s8) -> f32 {
    danger! {
        return @intrinsic.sitofp<i8, float>(from)
    }
}

routine f32.__create__(from: u8) -> f32 {
    danger! {
        return @intrinsic.uitofp<i8, float>(from)
    }
}

routine f32.__create__(from: s16) -> f32 {
    danger! {
        return @intrinsic.sitofp<i16, float>(from)
    }
}

routine f32.__create__(from: u16) -> f32 {
    danger! {
        return @intrinsic.uitofp<i16, float>(from)
    }
}

routine f32.__create__(from: s32) -> f32 {
    danger! {
        return @intrinsic.sitofp<i32, float>(from)
    }
}

routine f32.__create__(from: u32) -> f32 {
    danger! {
        return @intrinsic.uitofp<i32, float>(from)
    }
}

routine f32.__create__(from: s64) -> f32 {
    danger! {
        return @intrinsic.sitofp<i64, float>(from)
    }
}

routine f32.__create__(from: u64) -> f32 {
    danger! {
        return @intrinsic.uitofp<i64, float>(from)
    }
}

routine f32.__create__(from: f64) -> f32 {
    danger! {
        return @intrinsic.fptrunc<double, float>(from)
    }
}

routine f32.__create__(from: d32) -> f32 {
    danger! {
        let bits = @intrinsic.bitcast<d32, u32>(from)
        return rf_d32_to_f32(bits)
    }
}

routine f32.__create__(from: d64) -> f32 {
    danger! {
        let bits = @intrinsic.bitcast<d64, u64>(from)
        return rf_d64_to_f32(bits)
    }
}

routine f32.__create__(from: d128) -> f32 {
    danger! {
        return rf_d128_to_f32(from.low_bits(), from.high_bits())
    }
}

# ============================================================================
# Arithmetic Operations (IEEE 754 semantics)
# ============================================================================

routine f32.__add__(other: f32) -> f32 {
    danger! {
        return @intrinsic.add.wrapping<float>(me, other)
    }
}

routine f32.__sub__(other: f32) -> f32 {
    danger! {
        return @intrinsic.sub.wrapping<float>(me, other)
    }
}

routine f32.__mul__(other: f32) -> f32 {
    danger! {
        return @intrinsic.mul.wrapping<float>(me, other)
    }
}

routine f32.__truediv__(other: f32) -> f32 {
    danger! {
        return @intrinsic.div.wrapping<float>(me, other)
    }
}

routine f32.__neg__() -> f32 {
    danger! {
        return @intrinsic.sub.wrapping<float>(0.0_f32, me)
    }
}

# ============================================================================
# Comparison Operations (ordered - false if NaN)
# ============================================================================

routine f32.__lt__(other: f32) -> bool {
    danger! {
        return @intrinsic.fcmp.olt<float>(me, other)
    }
}

routine f32.__le__(other: f32) -> bool {
    danger! {
        return @intrinsic.fcmp.ole<float>(me, other)
    }
}

routine f32.__gt__(other: f32) -> bool {
    danger! {
        return @intrinsic.fcmp.ogt<float>(me, other)
    }
}

routine f32.__ge__(other: f32) -> bool {
    danger! {
        return @intrinsic.fcmp.oge<float>(me, other)
    }
}

# ============================================================================
# Math Operations using intrinsics
# ============================================================================

routine f32.sqrt() -> f32 {
    danger! {
        return @intrinsic.sqrt<float>(me)
    }
}

routine f32.abs() -> f32 {
    danger! {
        return @intrinsic.fabs<float>(me)
    }
}

routine f32.floor() -> f32 {
    danger! {
        return @intrinsic.floor<float>(me)
    }
}

routine f32.ceil() -> f32 {
    danger! {
        return @intrinsic.ceil<float>(me)
    }
}

routine f32.round() -> f32 {
    danger! {
        return @intrinsic.round<float>(me)
    }
}

routine f32.trunc() -> f32 {
    danger! {
        return @intrinsic.trunc_float<float>(me)
    }
}

# Trigonometric functions
routine f32.sin() -> f32 {
    danger! {
        return @intrinsic.sin<float>(me)
    }
}

routine f32.cos() -> f32 {
    danger! {
        return @intrinsic.cos<float>(me)
    }
}

# Exponential and logarithmic
routine f32.exp() -> f32 {
    danger! {
        return @intrinsic.exp<float>(me)
    }
}

routine f32.log() -> f32 {
    danger! {
        return @intrinsic.log<float>(me)
    }
}

routine f32.log10() -> f32 {
    danger! {
        return @intrinsic.log10<float>(me)
    }
}

routine f32.pow(exp: f32) -> f32 {
    danger! {
        return @intrinsic.pow<float>(me, exp)
    }
}

routine f32.copysign(sign: f32) -> f32 {
    danger! {
        return @intrinsic.copysign<float>(me, sign)
    }
}

# ============================================================================
# Utility Methods
# ============================================================================

routine f32.min(other: f32) -> f32 {
    return if me <= other then me else other
}

routine f32.max(other: f32) -> f32 {
    return if me >= other then me else other
}

routine f32.clamp(min_val: f32, max_val: f32) -> f32 {
    return me.min(max_val).max(min_val)
}

routine f32.is_positive() -> bool {
    return me > 0.0_f32
}

routine f32.is_negative() -> bool {
    return me < 0.0_f32
}

routine f32.is_zero() -> bool {
    return me == 0.0_f32
}

routine f32.signum() -> f32 {
    when {
        me > 0.0_f32 => 1.0_f32,
        me < 0.0_f32 => -1.0_f32,
        _ => 0.0_f32
    }
}

# ============================================================================
# Type Conversions
# ============================================================================

routine f32.to_s32() -> s32 {
    danger! {
        return @intrinsic.fptosi<float, i32>(me)
    }
}

routine f32.to_u32() -> u32 {
    danger! {
        return @intrinsic.fptoui<float, i32>(me)
    }
}

routine f32.to_s64() -> s64 {
    danger! {
        return @intrinsic.fptosi<float, i64>(me)
    }
}

routine f32.to_u64() -> u64 {
    danger! {
        return @intrinsic.fptoui<float, i64>(me)
    }
}

routine f32.to_s16() -> s16 {
    return me.to_s32().to_s16()
}

routine f32.to_u16() -> u16 {
    return me.to_u32().to_u16()
}

routine f32.to_s8() -> s8 {
    return me.to_s32().to_s8()
}

routine f32.to_u8() -> u8 {
    return me.to_u32().to_u8()
}

routine f32.to_d32() -> d32 {
    danger! {
        let bits = rf_f32_to_d32(me)
        return @intrinsic.bitcast<u32, d32>(bits)
    }
}

routine f32.to_d64() -> d64 {
    danger! {
        let bits = rf_f32_to_d64(me)
        return @intrinsic.bitcast<u64, d64>(bits)
    }
}

routine f32.to_d128() -> d128 {
    danger! {
        return rf_f32_to_d128(me)
    }
}

routine f32.to_f16() -> f16 {
    danger! {
        return @intrinsic.fptrunc<float, half>(me)
    }
}

routine f32.to_f64() -> f64 {
    danger! {
        return @intrinsic.fpext<float, double>(me)
    }
}

# Reinterpret bits as u32 (type punning)
routine f32.to_bits() -> u32 {
    danger! {
        return @intrinsic.bitcast<float, i32>(me)
    }
}

# Create f32 from u32 bits (type punning)
routine f32.from_bits(bits: u32) -> f32 {
    danger! {
        return @intrinsic.bitcast<i32, float>(bits)
    }
}

# ============================================================================
# String Conversion
# ============================================================================

routine f32.to_text() -> Text {
    danger! {
        return @format_f32(me)
    }
}

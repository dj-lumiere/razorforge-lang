# RazorForge sysuint (system-sized unsigned integer) native type implementation
# Maps to LLVM pointer-sized integer - u32 on 32-bit, u64 on 64-bit platforms
# Used for array indices, sizes, and pointer arithmetic

# Core sysuint type definition - maps to LLVM iptr/usize
record sysuint {
    public value: LlvmNativePtrSizedUInt
}

# ============================================================================
# Arithmetic Operations (system types use wrapping by default)
# ============================================================================

# Default operators use wrapping arithmetic for system types
routine sysuint.__add__(other: sysuint) -> sysuint {
    danger! {
        return @intrinsic.add.wrapping<uptr>(me, other)
    }
}

routine sysuint.__sub__(other: sysuint) -> sysuint {
    danger! {
        return @intrinsic.sub.wrapping<uptr>(me, other)
    }
}

routine sysuint.__mul__(other: sysuint) -> sysuint {
    danger! {
        return @intrinsic.mul.wrapping<uptr>(me, other)
    }
}

routine sysuint.__floordiv__(other: sysuint) -> sysuint {
    danger! {
        return @intrinsic.udiv<uptr>(me, other)
    }
}

routine sysuint.__mod__(other: sysuint) -> sysuint {
    danger! {
        return @intrinsic.urem<uptr>(me, other)
    }
}

# ============================================================================
# Bitwise Operations
# ============================================================================

routine sysuint.__and__(other: sysuint) -> sysuint {
    danger! {
        return @intrinsic.and<uptr>(me, other)
    }
}

routine sysuint.__or__(other: sysuint) -> sysuint {
    danger! {
        return @intrinsic.or<uptr>(me, other)
    }
}

routine sysuint.__xor__(other: sysuint) -> sysuint {
    danger! {
        return @intrinsic.xor<uptr>(me, other)
    }
}

routine sysuint.__not__() -> sysuint {
    danger! {
        return @intrinsic.not<uptr>(me)
    }
}

routine sysuint.__shl__(bits: u32) -> sysuint {
    danger! {
        return @intrinsic.shl<uptr>(me, bits)
    }
}

routine sysuint.__shr__(bits: u32) -> sysuint {
    danger! {
        return @intrinsic.lshr<uptr>(me, bits)
    }
}

# ============================================================================
# Comparison Operations
# ============================================================================

routine sysuint.__eq__(other: sysuint) -> bool {
    danger! {
        return @intrinsic.icmp.eq<uptr>(me, other)
    }
}

routine sysuint.__ne__(other: sysuint) -> bool {
    danger! {
        return @intrinsic.icmp.ne<uptr>(me, other)
    }
}

routine sysuint.__lt__(other: sysuint) -> bool {
    danger! {
        return @intrinsic.icmp.ult<uptr>(me, other)
    }
}

routine sysuint.__le__(other: sysuint) -> bool {
    danger! {
        return @intrinsic.icmp.ule<uptr>(me, other)
    }
}

routine sysuint.__gt__(other: sysuint) -> bool {
    danger! {
        return @intrinsic.icmp.ugt<uptr>(me, other)
    }
}

routine sysuint.__ge__(other: sysuint) -> bool {
    danger! {
        return @intrinsic.icmp.uge<uptr>(me, other)
    }
}

# ============================================================================
# Math Operations
# ============================================================================

routine sysuint.min(other: sysuint) -> sysuint {
    return if me <= other then me else other
}

routine sysuint.max(other: sysuint) -> sysuint {
    return if me >= other then me else other
}

routine sysuint.is_power_of_two() -> bool {
    return me != 0 and (me & (me - 1)) == 0
}

# ============================================================================
# Type Conversions (constructor syntax)
# ============================================================================

routine syssint(from: sysuint) -> syssint {
    danger! {
        return @intrinsic.bitcast<iptr>(from)
    }
}

routine u64(from: sysuint) -> u64 {
    danger! {
        return @intrinsic.zext<i64>(from)
    }
}

routine bool(from: sysuint) -> bool {
    return from != 0
}

# ============================================================================
# String Conversion
# ============================================================================

routine sysuint.to_text() -> Text {
    danger! {
        return @format_sysuint(me)
    }
}

# Parsing constructors using compiler intrinsics

# Fallible constructor - crashes on invalid input
routine sysuint!(from_text: Text) -> sysuint {
    danger! {
        return @parse_sysuint(from_text)
    }
}

# Safe constructor - returns Maybe<sysuint>
routine sysuint?(from_text: Text) -> Maybe<sysuint> {
    danger! {
        return @try_parse_sysuint(from_text)
    }
}

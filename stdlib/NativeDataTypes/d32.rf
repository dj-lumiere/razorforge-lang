# RazorForge d32 (decimal32 floating point) native type implementation
# IEEE 754-2008 decimal floating point with 7 significant digits
# Uses Intel DFP library via external C functions
namespace core
import FFI/ctypes

# Core d32 type definition - stored as 32-bit value in BID encoding
record d32 {
    private value: u32
}

# Constants for d32
preset D32_ZERO: d32 = 0.0_d32
preset D32_ONE: d32 = 1.0_d32

# ============================================================================
# External C Functions (from decimal_functions.c)
# ============================================================================

external routine d32_add(a: u32, b: u32) -> u32
external routine d32_sub(a: u32, b: u32) -> u32
external routine d32_mul(a: u32, b: u32) -> u32
external routine d32_div(a: u32, b: u32) -> u32
external routine d32_cmp(a: u32, b: u32) -> s32
external routine d32_from_string(str: cstr) -> u32
external routine d32_to_string(val: u32) -> cstr
external routine d32_from_i32(val: s32) -> u32
external routine d32_from_u32(val: u32) -> u32
external routine d32_from_i64(val: s64) -> u32
external routine d32_from_u64(val: u64) -> u32
external routine d32_to_i32(val: u32) -> s32
external routine d32_to_i64(val: u32) -> s64
external routine rf_d32_sqrt(x: u32) -> u32
external routine rf_d32_abs(x: u32) -> u32
external routine rf_d32_ceil(x: u32) -> u32
external routine rf_d32_floor(x: u32) -> u32
external routine rf_d32_round(x: u32) -> u32
external routine rf_d32_trunc(x: u32) -> u32
external routine rf_d32_to_f32(x: u32) -> f32
external routine rf_d32_to_f64(x: u32) -> f64
external routine rf_d32_to_d64(x: u32) -> u64
external routine rf_f32_to_d32(x: f32) -> u32
external routine rf_f64_to_d32(x: f64) -> u32

# ============================================================================
# Constructors
# ============================================================================

routine d32.__create__!(from_text: Text<letter8>) -> d32 {
    danger! {
        let cstr_val = from_text.to_cstr()
        let bits = d32_from_string(cstr_val)
        return @intrinsic.bitcast<u32, d32>(bits)
    }
}

routine d32.__create__(from: f32) -> d32 {
    danger! {
        let bits = rf_f32_to_d32(from)
        return @intrinsic.bitcast<u32, d32>(bits)
    }
}

routine d32.__create__(from: f64) -> d32 {
    danger! {
        let bits = rf_f64_to_d32(from)
        return @intrinsic.bitcast<u32, d32>(bits)
    }
}

routine d32.__create__(from: s8) -> d32 {
    danger! {
        let bits = d32_to_s32(from.to_s32())
        return @intrinsic.bitcast<u32, d32>(bits)
    }
}

routine d32.__create__(from: u8) -> d32 {
    danger! {
        let bits = d32_from_u32(from.to_u32())
        return @intrinsic.bitcast<u32, d32>(bits)
    }
}

routine d32.__create__(from: s16) -> d32 {
    danger! {
        let bits = d32_to_s32(from.to_s32())
        return @intrinsic.bitcast<u32, d32>(bits)
    }
}

routine d32.__create__(from: u16) -> d32 {
    danger! {
        let bits = d32_from_u32(from.to_u32())
        return @intrinsic.bitcast<u32, d32>(bits)
    }
}

routine d32.__create__(from: s32) -> d32 {
    danger! {
        let bits = d32_to_s32(from)
        return @intrinsic.bitcast<u32, d32>(bits)
    }
}

routine d32.__create__(from: u32) -> d32 {
    danger! {
        let bits = d32_from_u32(from)
        return @intrinsic.bitcast<u32, d32>(bits)
    }
}

routine d32.__create__(from: s64) -> d32 {
    danger! {
        let bits = d32_from_s64(from)
        return @intrinsic.bitcast<u32, d32>(bits)
    }
}

routine d32.__create__(from: u64) -> d32 {
    danger! {
        let bits = d32_from_u64(from)
        return @intrinsic.bitcast<u32, d32>(bits)
    }
}

# ============================================================================
# Arithmetic Operations
# ============================================================================

routine d32.__add__(me: d32, other: d32) -> d32 {
    danger! {
        let a_bits = @intrinsic.bitcast<d32, u32>(me)
        let b_bits = @intrinsic.bitcast<d32, u32>(other)
        let result = d32_add(a_bits, b_bits)
        return @intrinsic.bitcast<u32, d32>(result)
    }
}

routine d32.__sub__(me: d32, other: d32) -> d32 {
    danger! {
        let a_bits = @intrinsic.bitcast<d32, u32>(me)
        let b_bits = @intrinsic.bitcast<d32, u32>(other)
        let result = d32_sub(a_bits, b_bits)
        return @intrinsic.bitcast<u32, d32>(result)
    }
}

routine d32.__mul__(me: d32, other: d32) -> d32 {
    danger! {
        let a_bits = @intrinsic.bitcast<d32, u32>(me)
        let b_bits = @intrinsic.bitcast<d32, u32>(other)
        let result = d32_mul(a_bits, b_bits)
        return @intrinsic.bitcast<u32, d32>(result)
    }
}

routine d32.__truediv__(me: d32, other: d32) -> d32 {
    danger! {
        let a_bits = @intrinsic.bitcast<d32, u32>(me)
        let b_bits = @intrinsic.bitcast<d32, u32>(other)
        let result = d32_div(a_bits, b_bits)
        return @intrinsic.bitcast<u32, d32>(result)
    }
}

routine d32.__neg__(me: d32) -> d32 {
    danger! {
        let zero_bits = @intrinsic.bitcast<d32, u32>(D32_ZERO)
        let me_bits = @intrinsic.bitcast<d32, u32>(me)
        let result = d32_sub(zero_bits, me_bits)
        return @intrinsic.bitcast<u32, d32>(result)
    }
}

# ============================================================================
# Comparison Operations
# ============================================================================

routine d32.__lt__(me: d32, other: d32) -> bool {
    danger! {
        let a_bits = @intrinsic.bitcast<d32, u32>(me)
        let b_bits = @intrinsic.bitcast<d32, u32>(other)
        return d32_cmp(a_bits, b_bits) < 0
    }
}

routine d32.__le__(me: d32, other: d32) -> bool {
    danger! {
        let a_bits = @intrinsic.bitcast<d32, u32>(me)
        let b_bits = @intrinsic.bitcast<d32, u32>(other)
        return d32_cmp(a_bits, b_bits) <= 0
    }
}

routine d32.__gt__(me: d32, other: d32) -> bool {
    danger! {
        let a_bits = @intrinsic.bitcast<d32, u32>(me)
        let b_bits = @intrinsic.bitcast<d32, u32>(other)
        return d32_cmp(a_bits, b_bits) > 0
    }
}

routine d32.__ge__(me: d32, other: d32) -> bool {
    danger! {
        let a_bits = @intrinsic.bitcast<d32, u32>(me)
        let b_bits = @intrinsic.bitcast<d32, u32>(other)
        return d32_cmp(a_bits, b_bits) >= 0
    }
}

routine d32.__eq__(me: d32, other: d32) -> bool {
    danger! {
        let a_bits = @intrinsic.bitcast<d32, u32>(me)
        let b_bits = @intrinsic.bitcast<d32, u32>(other)
        return d32_cmp(a_bits, b_bits) == 0
    }
}

routine d32.__ne__(me: d32, other: d32) -> bool {
    danger! {
        let a_bits = @intrinsic.bitcast<d32, u32>(me)
        let b_bits = @intrinsic.bitcast<d32, u32>(other)
        return d32_cmp(a_bits, b_bits) != 0
    }
}

# ============================================================================
# Math Operations
# ============================================================================

routine d32.sqrt(me: d32) -> d32 {
    danger! {
        let bits = @intrinsic.bitcast<d32, u32>(me)
        let result = rf_d32_sqrt(bits)
        return @intrinsic.bitcast<u32, d32>(result)
    }
}

routine d32.abs(me: d32) -> d32 {
    danger! {
        let bits = @intrinsic.bitcast<d32, u32>(me)
        let result = rf_d32_abs(bits)
        return @intrinsic.bitcast<u32, d32>(result)
    }
}

routine d32.ceil(me: d32) -> d32 {
    danger! {
        let bits = @intrinsic.bitcast<d32, u32>(me)
        let result = rf_d32_ceil(bits)
        return @intrinsic.bitcast<u32, d32>(result)
    }
}

routine d32.floor(me: d32) -> d32 {
    danger! {
        let bits = @intrinsic.bitcast<d32, u32>(me)
        let result = rf_d32_floor(bits)
        return @intrinsic.bitcast<u32, d32>(result)
    }
}

routine d32.round(me: d32) -> d32 {
    danger! {
        let bits = @intrinsic.bitcast<d32, u32>(me)
        let result = rf_d32_round(bits)
        return @intrinsic.bitcast<u32, d32>(result)
    }
}

routine d32.trunc(me: d32) -> d32 {
    danger! {
        let bits = @intrinsic.bitcast<d32, u32>(me)
        let result = rf_d32_trunc(bits)
        return @intrinsic.bitcast<u32, d32>(result)
    }
}

# ============================================================================
# Utility Methods
# ============================================================================

routine d32.min(me: d32, other: d32) -> d32 {
    danger! {
        let a_bits = @intrinsic.bitcast<d32, u32>(me)
        let b_bits = @intrinsic.bitcast<d32, u32>(other)
        return (if d32_cmp(a_bits, b_bits) <= 0 then me else other)
    }
}

routine d32.max(me: d32, other: d32) -> d32 {
    danger! {
        let a_bits = @intrinsic.bitcast<d32, u32>(me)
        let b_bits = @intrinsic.bitcast<d32, u32>(other)
        return (if d32_cmp(a_bits, b_bits) >= 0 then me else other)
    }
}

routine d32.clamp(me: d32, min_val: d32, max_val: d32) -> d32 {
    return me.min(max_val).max(min_val)
}

routine d32.is_positive(me: d32) -> bool {
    danger! {
        let me_bits = @intrinsic.bitcast<d32, u32>(me)
        let zero_bits = @intrinsic.bitcast<d32, u32>(D32_ZERO)
        return d32_cmp(me_bits, zero_bits) > 0
    }
}

routine d32.is_negative(me: d32) -> bool {
    danger! {
        let me_bits = @intrinsic.bitcast<d32, u32>(me)
        let zero_bits = @intrinsic.bitcast<d32, u32>(D32_ZERO)
        return d32_cmp(me_bits, zero_bits) < 0
    }
}

routine d32.is_zero(me: d32) -> bool {
    danger! {
        let me_bits = @intrinsic.bitcast<d32, u32>(me)
        let zero_bits = @intrinsic.bitcast<d32, u32>(D32_ZERO)
        return d32_cmp(me_bits, zero_bits) == 0
    }
}

routine d32.signum(me: d32) -> d32 {
    danger! {
        let me_bits = @intrinsic.bitcast<d32, u32>(me)
        let zero_bits = @intrinsic.bitcast<d32, u32>(D32_ZERO)
        let cmp = d32_cmp(me_bits, zero_bits)
        when {
            cmp > 0 => D32_ONE,
            cmp < 0 => me.__neg__(),
            _ => D32_ZERO
        }
    }
}

# ============================================================================
# Type Conversions
# ============================================================================

routine d32.to_f32(me: d32) -> f32 {
    danger! {
        let bits = @intrinsic.bitcast<d32, u32>(me)
        return rf_d32_to_f32(bits)
    }
}

routine d32.to_f64(me: d32) -> f64 {
    danger! {
        let bits = @intrinsic.bitcast<d32, u32>(me)
        return rf_d32_to_f64(bits)
    }
}

routine d32.to_d64(me: d32) -> d64 {
    danger! {
        let bits = @intrinsic.bitcast<d32, u32>(me)
        let result = rf_d32_to_d64(bits)
        return @intrinsic.bitcast<u64, d64>(result)
    }
}

routine d32.to_s8(me: d32) -> s8 {
    return me.to_s32().to_s8()
}

routine d32.to_u8(me: d32) -> u8 {
    return me.to_u32().to_u8()
}

routine d32.to_s16(me: d32) -> s16 {
    return me.to_s32().to_s16()
}

routine d32.to_u16(me: d32) -> u16 {
    return me.to_u32().to_u16()
}

routine d32.to_s32(me: d32) -> s32 {
    danger! {
        let bits = @intrinsic.bitcast<d32, u32>(me)
        return d32_to_i32(bits)
    }
}

routine d32.to_u32(me: d32) -> u32 {
    return me.to_s64().to_u32()
}

routine d32.to_s64(me: d32) -> s64 {
    danger! {
        let bits = @intrinsic.bitcast<d32, u32>(me)
        return d32_to_i64(bits)
    }
}

routine d32.to_u64(me: d32) -> u64 {
    return me.to_s64().to_u64()
}

# Reinterpret bits as u32 (type punning)
routine d32.to_bits(me: d32) -> u32 {
    danger! {
        return @intrinsic.bitcast<d32, u32>(me)
    }
}

# Create d32 from u32 bits (type punning)
routine d32.from_bits(bits: u32) -> d32 {
    danger! {
        return @intrinsic.bitcast<u32, d32>(bits)
    }
}

# ============================================================================
# String Conversion
# ============================================================================

routine d32.to_text(me: d32) -> Text {
    danger! {
        let bits = @intrinsic.bitcast<d32, u32>(me)
        let cstr_result = d32_to_string(bits)
        return Text.from_cstr(cstr_result)
    }
}

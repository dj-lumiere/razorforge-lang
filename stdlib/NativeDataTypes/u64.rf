# RazorForge u64 (unsigned 64-bit integer) native type implementation
# Maps directly to LLVM i64 type using compiler intrinsics

# Core u64 type definition - maps to LLVM i64
record u64 {
    public value: LlvmNativeI64
}

# Constants for u64 limits
preset U64_MIN: u64 = 0_u64
preset U64_MAX: u64 = 18_446_744_073_709_551_615_u64
preset U64_ZERO: u64 = 0_u64
preset U64_ONE: u64 = 1_u64

# ============================================================================
# Arithmetic Operations
# ============================================================================

# Addition (wrapping by default)
routine u64.__add__(other: u64) -> u64 {
    danger! {
        return @intrinsic.add.wrapping<i64>(me, other)
    }
}

# Subtraction (wrapping by default)
routine u64.__sub__(other: u64) -> u64 {
    danger! {
        return @intrinsic.sub.wrapping<i64>(me, other)
    }
}

# Multiplication (wrapping by default)
routine u64.__mul__(other: u64) -> u64 {
    danger! {
        return @intrinsic.mul.wrapping<i64>(me, other)
    }
}

# Division (unsigned)
routine u64.__div__(other: u64) -> u64 {
    danger! {
        return @intrinsic.div.wrapping<i64>(me, other)
    }
}

# Remainder (unsigned)
routine u64.__rem__(other: u64) -> u64 {
    danger! {
        return @intrinsic.rem.wrapping<i64>(me, other)
    }
}

# ============================================================================
# Checked Arithmetic (returns Result with overflow detection)
# ============================================================================

# Checked addition
routine u64.checked_add(other: u64) -> Result<u64, OverflowError> {
    danger! {
        let (result, overflow) = @intrinsic.add.overflow<i64>(me, other)
        return if overflow {
            Err(OverflowError())
        } else {
            Ok(result)
        }
    }
}

# Checked subtraction
routine u64.checked_sub(other: u64) -> Result<u64, OverflowError> {
    danger! {
        let (result, overflow) = @intrinsic.sub.overflow<i64>(me, other)
        return if overflow {
            Err(OverflowError())
        } else {
            Ok(result)
        }
    }
}

# Checked multiplication
routine u64.checked_mul(other: u64) -> Result<u64, OverflowError> {
    danger! {
        let (result, overflow) = @intrinsic.mul.overflow<i64>(me, other)
        return if overflow {
            Err(OverflowError())
        } else {
            Ok(result)
        }
    }
}

# ============================================================================
# Saturating Arithmetic (clamps at min/max instead of wrapping)
# ============================================================================

routine u64.saturating_add(other: u64) -> u64 {
    danger! {
        return @intrinsic.add.saturating<i64>(me, other)
    }
}

routine u64.saturating_sub(other: u64) -> u64 {
    danger! {
        return @intrinsic.sub.saturating<i64>(me, other)
    }
}

# ============================================================================
# Bitwise Operations
# ============================================================================

routine u64.__and__(other: u64) -> u64 {
    danger! {
        return @intrinsic.and<i64>(me, other)
    }
}

routine u64.__or__(other: u64) -> u64 {
    danger! {
        return @intrinsic.or<i64>(me, other)
    }
}

routine u64.__xor__(other: u64) -> u64 {
    danger! {
        return @intrinsic.xor<i64>(me, other)
    }
}

routine u64.__not__() -> u64 {
    danger! {
        return @intrinsic.not<i64>(me)
    }
}

# Left shift
routine u64.__shl__(bits: u32) -> u64 {
    danger! {
        return @intrinsic.shl<i64>(me, bits)
    }
}

# Logical right shift (zero-fill)
routine u64.__shr__(bits: u32) -> u64 {
    danger! {
        return @intrinsic.lshr<i64>(me, bits)
    }
}

# ============================================================================
# Comparison Operations (unsigned)
# ============================================================================

routine u64.__eq__(other: u64) -> bool {
    danger! {
        return @intrinsic.icmp.eq<i64>(me, other)
    }
}

routine u64.__ne__(other: u64) -> bool {
    danger! {
        return @intrinsic.icmp.ne<i64>(me, other)
    }
}

routine u64.__lt__(other: u64) -> bool {
    danger! {
        return @intrinsic.icmp.ult<i64>(me, other)
    }
}

routine u64.__le__(other: u64) -> bool {
    danger! {
        return @intrinsic.icmp.ule<i64>(me, other)
    }
}

routine u64.__gt__(other: u64) -> bool {
    danger! {
        return @intrinsic.icmp.ugt<i64>(me, other)
    }
}

routine u64.__ge__(other: u64) -> bool {
    danger! {
        return @intrinsic.icmp.uge<i64>(me, other)
    }
}

# ============================================================================
# Math Operations
# ============================================================================

routine u64.min(other: u64) -> u64 {
    return if me <= other then me else other
}

routine u64.max(other: u64) -> u64 {
    return if me >= other then me else other
}

routine u64.clamp(min_val: u64, max_val: u64) -> u64 {
    return me.min(max_val).max(min_val)
}

# ============================================================================
# Bit Manipulation
# ============================================================================

routine u64.count_ones() -> u64 {
    danger! {
        return @intrinsic.ctpop<i64>(me)
    }
}

routine u64.count_zeros() -> u64 {
    return 64_u64 - me.count_ones()
}

routine u64.leading_zeros() -> u64 {
    danger! {
        return @intrinsic.ctlz<i64>(me)
    }
}

routine u64.trailing_zeros() -> u64 {
    danger! {
        return @intrinsic.cttz<i64>(me)
    }
}

routine u64.leading_ones() -> u64 {
    return me.__not__().leading_zeros()
}

routine u64.trailing_ones() -> u64 {
    return me.__not__().trailing_zeros()
}

routine u64.reverse_bits() -> u64 {
    danger! {
        return @intrinsic.bitreverse<i64>(me)
    }
}

routine u64.swap_bytes() -> u64 {
    danger! {
        return @intrinsic.bswap<i64>(me)
    }
}

# ============================================================================
# Type Conversions
# ============================================================================

# Convert to signed (reinterpret bits)
routine u64.to_s64() -> s64 {
    danger! {
        return @intrinsic.bitcast<i64, i64>(me)
    }
}

# Convert to smaller unsigned integers (truncate)
routine u64.to_u32() -> u32 {
    danger! {
        return @intrinsic.trunc<i64, i32>(me)
    }
}

routine u64.to_u16() -> u16 {
    danger! {
        return @intrinsic.trunc<i64, i16>(me)
    }
}

routine u64.to_u8() -> u8 {
    danger! {
        return @intrinsic.trunc<i64, i8>(me)
    }
}

# Convert to float
routine u64.to_f64() -> f64 {
    danger! {
        return @intrinsic.uitofp<i64, double>(me)
    }
}

routine u64.to_f32() -> f32 {
    danger! {
        return @intrinsic.uitofp<i64, float>(me)
    }
}

# Convert to boolean
routine u64.to_bool() -> bool {
    danger! {
        return @intrinsic.icmp.ne<i64>(me, 0_u64)
    }
}

# ============================================================================
# Utility Methods
# ============================================================================

routine u64.is_zero() -> bool {
    return me == 0_u64
}

routine u64.is_even() -> bool {
    danger! {
        let result = @intrinsic.and<i64>(me, 1_u64)
        return @intrinsic.icmp.eq<i64>(result, 0_u64)
    }
}

routine u64.is_odd() -> bool {
    return not me.is_even()
}

# Power of 2 check (very common for unsigned)
routine u64.is_power_of_two() -> bool {
    danger! {
        let is_nonzero = @intrinsic.icmp.ne<i64>(me, 0_u64)
        let minus_one = @intrinsic.sub.wrapping<i64>(me, 1_u64)
        let anded = @intrinsic.and<i64>(me, minus_one)
        let is_zero = @intrinsic.icmp.eq<i64>(anded, 0_u64)
        return is_nonzero and is_zero
    }
}

# Next power of 2 (round up)
routine u64.next_power_of_two() -> u64 {
    when {
        me == 0_u64 => 1_u64,
        me.is_power_of_two() => me,
        _ => {
            danger! {
                var n = me
                n = @intrinsic.sub.wrapping<i64>(n, 1_u64)
                n = @intrinsic.or<i64>(n, @intrinsic.lshr<i64>(n, 1_u32))
                n = @intrinsic.or<i64>(n, @intrinsic.lshr<i64>(n, 2_u32))
                n = @intrinsic.or<i64>(n, @intrinsic.lshr<i64>(n, 4_u32))
                n = @intrinsic.or<i64>(n, @intrinsic.lshr<i64>(n, 8_u32))
                n = @intrinsic.or<i64>(n, @intrinsic.lshr<i64>(n, 16_u32))
                n = @intrinsic.or<i64>(n, @intrinsic.lshr<i64>(n, 32_u32))
                return @intrinsic.add.wrapping<i64>(n, 1_u64)
            }
        }
    }
}

# Rotate left
routine u64.rotate_left(bits: u32) -> u64 {
    danger! {
        let left = @intrinsic.shl<i64>(me, bits)
        let right = @intrinsic.lshr<i64>(me, 64_u32 - bits)
        return @intrinsic.or<i64>(left, right)
    }
}

# Rotate right
routine u64.rotate_right(bits: u32) -> u64 {
    danger! {
        let right = @intrinsic.lshr<i64>(me, bits)
        let left = @intrinsic.shl<i64>(me, 64_u32 - bits)
        return @intrinsic.or<i64>(right, left)
    }
}

# ============================================================================
# String Conversion (placeholder - needs proper implementation)
# ============================================================================

routine u64.to_text() -> Text {
    danger! {
        return @format_u64(me)
    }
}

# Parsing constructors using compiler intrinsics

# Fallible constructor - crashes on invalid input
routine u64!(from_text: Text) -> u64 {
    danger! {
        return @parse_u64(from_text)
    }
}

# Safe constructor - returns Maybe<u64>
routine u64?(from_text: Text) -> Maybe<u64> {
    danger! {
        return @try_parse_u64(from_text)
    }
}

# ============================================================================
# Example: Fast modular exponentiation
# ============================================================================

routine modpow_u64(base: u64, exp: u64, modulus: u64) -> u64 {
    var result: u64 = 1_u64
    var b = base % modulus
    var e = exp

    while e > 0_u64 {
        if e.is_odd() {
            result = (result * b) % modulus
        }
        b = (b * b) % modulus
        e = e >> 1_u32
    }

    return result
}

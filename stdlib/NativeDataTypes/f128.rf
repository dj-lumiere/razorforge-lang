# RazorForge f128 (quadruple precision floating point) native type implementation
# Maps directly to LLVM fp128 type using compiler intrinsics

# Core f128 type definition - maps to LLVM fp128
record f128 {
    public value: LlvmNativeFp128
}

# IEEE 754 quadruple precision constants
preset F128_EPSILON: f128 = 1.925929944387235853055977942584927319e-34_f128
preset F128_MIN: f128 = -1.189731495357231765085759326628007016e+4932_f128
preset F128_MAX: f128 = 1.189731495357231765085759326628007016e+4932_f128
preset F128_MIN_POSITIVE: f128 = 3.362103143112093506262677817321752602e-4932_f128
preset F128_ZERO: f128 = 0.0_f128
preset F128_ONE: f128 = 1.0_f128

# Mathematical constants with quadruple precision
preset F128_PI: f128 = 3.141592653589793238462643383279502884_f128
preset F128_E: f128 = 2.718281828459045235360287471352662498_f128
preset F128_SQRT_2: f128 = 1.414213562373095048801688724209698079_f128
preset F128_LN_2: f128 = 0.693147180559945309417232121458176568_f128
preset F128_LN_10: f128 = 2.302585092994045684017991454684364208_f128

# Failable constructor from Text - called as f128!(text)
# Compiler automatically generates try_f128.__create__(text) -> Maybe<f128>
routine f128.__create__!(from_text: Text<Letterlikes>) -> f128 {
    danger! {
        return @parse_f128(from_text)
    }
}

# ============================================================================
# Arithmetic Operations (IEEE 754 semantics)
# ============================================================================

routine f128.__add__(other: f128) -> f128 {
    danger! {
        return @intrinsic.add.wrapping<fp128>(me, other)
    }
}

routine f128.__sub__(other: f128) -> f128 {
    danger! {
        return @intrinsic.sub.wrapping<fp128>(me, other)
    }
}

routine f128.__mul__(other: f128) -> f128 {
    danger! {
        return @intrinsic.mul.wrapping<fp128>(me, other)
    }
}

routine f128.__truediv__(other: f128) -> f128 {
    danger! {
        return @intrinsic.div.wrapping<fp128>(me, other)
    }
}

routine f128.__neg__() -> f128 {
    danger! {
        return @intrinsic.sub.wrapping<fp128>(0.0_f128, me)
    }
}

# ============================================================================
# Comparison Operations (ordered - false if NaN)
# ============================================================================

routine f128.__eq__(other: f128) -> bool {
    danger! {
        return @intrinsic.fcmp.oeq<fp128>(me, other)
    }
}

routine f128.__ne__(other: f128) -> bool {
    danger! {
        return @intrinsic.fcmp.one<fp128>(me, other)
    }
}

routine f128.__lt__(other: f128) -> bool {
    danger! {
        return @intrinsic.fcmp.olt<fp128>(me, other)
    }
}

routine f128.__le__(other: f128) -> bool {
    danger! {
        return @intrinsic.fcmp.ole<fp128>(me, other)
    }
}

routine f128.__gt__(other: f128) -> bool {
    danger! {
        return @intrinsic.fcmp.ogt<fp128>(me, other)
    }
}

routine f128.__ge__(other: f128) -> bool {
    danger! {
        return @intrinsic.fcmp.oge<fp128>(me, other)
    }
}

# ============================================================================
# Math Operations using intrinsics
# ============================================================================

routine f128.sqrt() -> f128 {
    danger! {
        return @intrinsic.sqrt<fp128>(me)
    }
}

routine f128.abs() -> f128 {
    danger! {
        return @intrinsic.fabs<fp128>(me)
    }
}

routine f128.floor() -> f128 {
    danger! {
        return @intrinsic.floor<fp128>(me)
    }
}

routine f128.ceil() -> f128 {
    danger! {
        return @intrinsic.ceil<fp128>(me)
    }
}

routine f128.round() -> f128 {
    danger! {
        return @intrinsic.round<fp128>(me)
    }
}

routine f128.trunc() -> f128 {
    danger! {
        return @intrinsic.trunc_float<fp128>(me)
    }
}

# Trigonometric functions
routine f128.sin() -> f128 {
    danger! {
        return @intrinsic.sin<fp128>(me)
    }
}

routine f128.cos() -> f128 {
    danger! {
        return @intrinsic.cos<fp128>(me)
    }
}

# Exponential and logarithmic
routine f128.exp() -> f128 {
    danger! {
        return @intrinsic.exp<fp128>(me)
    }
}

routine f128.log() -> f128 {
    danger! {
        return @intrinsic.log<fp128>(me)
    }
}

routine f128.log10() -> f128 {
    danger! {
        return @intrinsic.log10<fp128>(me)
    }
}

routine f128.pow(exp: f128) -> f128 {
    danger! {
        return @intrinsic.pow<fp128>(me, exp)
    }
}

routine f128.copysign(sign: f128) -> f128 {
    danger! {
        return @intrinsic.copysign<fp128>(me, sign)
    }
}

# ============================================================================
# Utility Methods
# ============================================================================

routine f128.min(other: f128) -> f128 {
    return if me <= other then me else other
}

routine f128.max(other: f128) -> f128 {
    return if me >= other then me else other
}

routine f128.clamp(min_val: f128, max_val: f128) -> f128 {
    return me.min(max_val).max(min_val)
}

routine f128.is_positive() -> bool {
    return me > 0.0_f128
}

routine f128.is_negative() -> bool {
    return me < 0.0_f128
}

routine f128.is_zero() -> bool {
    return me == 0.0_f128
}

routine f128.signum() -> f128 {
    when {
        me > 0.0_f128 => 1.0_f128,
        me < 0.0_f128 => -1.0_f128,
        _ => 0.0_f128
    }
}

# ============================================================================
# Type Conversions
# ============================================================================

routine f128.to_s64() -> s64 {
    danger! {
        return @intrinsic.fptosi<fp128, i64>(me)
    }
}

routine f128.to_u64() -> u64 {
    danger! {
        return @intrinsic.fptoui<fp128, i64>(me)
    }
}

routine f128.to_s128() -> s128 {
    danger! {
        return @intrinsic.fptosi<fp128, i128>(me)
    }
}

routine f128.to_u128() -> u128 {
    danger! {
        return @intrinsic.fptoui<fp128, i128>(me)
    }
}

routine f128.to_f32() -> f32 {
    danger! {
        return @intrinsic.fptrunc<fp128, float>(me)
    }
}

routine f128.to_f64() -> f64 {
    danger! {
        return @intrinsic.fptrunc<fp128, double>(me)
    }
}

# Reinterpret bits as u128 (type punning)
routine f128.to_bits() -> u128 {
    danger! {
        return @intrinsic.bitcast<fp128, i128>(me)
    }
}

# Create f128 from u128 bits (type punning)
routine f128.from_bits(bits: u128) -> f128 {
    danger! {
        return @intrinsic.bitcast<i128, fp128>(bits)
    }
}

# ============================================================================
# String Conversion
# ============================================================================

routine f128.to_text() -> Text {
    danger! {
        return @format_f128(me)
    }
}

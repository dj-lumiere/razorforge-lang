# RazorForge f128 (quadruple precision floating point) native type implementation
# Maps directly to LLVM fp128 type using compiler intrinsics
namespace core
# Core f128 type definition - maps to LLVM fp128
record f128 {
    private value: @intrinsic.f128
}

# IEEE 754 quadruple precision constants
preset F128_EPSILON: f128 = 1.925929944387235853055977942584927319e-34_f128
preset F128_MIN: f128 = -1.189731495357231765085759326628007016e+4932_f128
preset F128_MAX: f128 = 1.189731495357231765085759326628007016e+4932_f128
preset F128_MIN_POSITIVE: f128 = 3.362103143112093506262677817321752602e-4932_f128
preset F128_ZERO: f128 = 0.0_f128
preset F128_ONE: f128 = 1.0_f128

# Mathematical constants with quadruple precision
preset F128_PI: f128 = 3.141592653589793238462643383279502884_f128
preset F128_E: f128 = 2.718281828459045235360287471352662498_f128
preset F128_SQRT_2: f128 = 1.414213562373095048801688724209698079_f128
preset F128_LN_2: f128 = 0.693147180559945309417232121458176568_f128
preset F128_LN_10: f128 = 2.302585092994045684017991454684364208_f128

# Failable constructor from Text - called as f128!(text)
# Compiler automatically generates try_f128.__create__(text) -> Maybe<f128>
routine f128.__create__!(from_text: Text<Letter>) -> f128 {
    danger! {
        return @native.rf_parse_f128(from_text)
    }
}

# Convert integers to f128 using LLVM intrinsics (lossless for all integer sizes)
routine f128.__create__(from: s8) -> f128 {
    danger! {
        return @intrinsic.sitofp<i8, fp128>(from)
    }
}

routine f128.__create__(from: s16) -> f128 {
    danger! {
        return @intrinsic.sitofp<i16, fp128>(from)
    }
}

routine f128.__create__(from: s32) -> f128 {
    danger! {
        return @intrinsic.sitofp<i32, fp128>(from)
    }
}

routine f128.__create__(from: s64) -> f128 {
    danger! {
        return @intrinsic.sitofp<i64, fp128>(from)
    }
}

routine f128.__create__(from: s128) -> f128 {
    danger! {
        return @intrinsic.sitofp<i128, fp128>(from)
    }
}

routine f128.__create__(from: u8) -> f128 {
    danger! {
        return @intrinsic.uitofp<i8, fp128>(from)
    }
}

routine f128.__create__(from: u16) -> f128 {
    danger! {
        return @intrinsic.uitofp<i16, fp128>(from)
    }
}

routine f128.__create__(from: u32) -> f128 {
    danger! {
        return @intrinsic.uitofp<i32, fp128>(from)
    }
}

routine f128.__create__(from: u64) -> f128 {
    danger! {
        return @intrinsic.uitofp<i64, fp128>(from)
    }
}

routine f128.__create__(from: u128) -> f128 {
    danger! {
        return @intrinsic.uitofp<i128, fp128>(from)
    }
}

# Extend from smaller float types using LLVM intrinsics (lossless widening)
routine f128.__create__(from: f16) -> f128 {
    danger! {
        return @intrinsic.fpext<half, fp128>(from)
    }
}

routine f128.__create__(from: f32) -> f128 {
    danger! {
        return @intrinsic.fpext<float, fp128>(from)
    }
}

routine f128.__create__(from: f64) -> f128 {
    danger! {
        return @intrinsic.fpext<double, fp128>(from)
    }
}

routine f128.__create__(from: f128) -> f128 {
    return from
}

# Convert from decimal types via native runtime (no LLVM intrinsic for decimal)
routine f128.__create__(from: d32) -> f128 {
    danger! {
        return @native.rf_d32_to_f128(from.to_bits())
    }
}

routine f128.__create__(from: d64) -> f128 {
    danger! {
        return @native.rf_d64_to_f128(from.to_bits())
    }
}

routine f128.__create__(from: d128) -> f128 {
    danger! {
        return @native.rf_d128_to_f128(from.low_bits(), from.high_bits())
    }
}

# From saddr - convert to float using LLVM intrinsic
routine f128.__create__(from: saddr) -> f128 {
    danger! {
        return @intrinsic.sitofp<iptr, fp128>(from)
    }
}

# From uaddr - convert to float using LLVM intrinsic
routine f128.__create__(from: uaddr) -> f128 {
    danger! {
        return @intrinsic.uitofp<uptr, fp128>(from)
    }
}

# ============================================================================
# Arithmetic Operations (IEEE 754 semantics)
# ============================================================================

routine f128.__add__(you: f128) -> f128 {
    danger! {
        return @intrinsic.add.wrapping<fp128>(me, you)
    }
}

routine f128.__sub__(you: f128) -> f128 {
    danger! {
        return @intrinsic.sub.wrapping<fp128>(me, you)
    }
}

routine f128.__mul__(you: f128) -> f128 {
    danger! {
        return @intrinsic.mul.wrapping<fp128>(me, you)
    }
}

routine f128.__truediv__(you: f128) -> f128 {
    danger! {
        return @intrinsic.div.wrapping<fp128>(me, you)
    }
}

routine f128.__neg__() -> f128 {
    danger! {
        return @intrinsic.sub.wrapping<fp128>(0.0_f128, me)
    }
}

# ============================================================================
# Comparison Operations (ordered - false if NaN)
# ============================================================================

routine f128.__lt__(you: f128) -> bool {
    danger! {
        return @intrinsic.fcmp.olt<fp128>(me, you)
    }
}

routine f128.__le__(you: f128) -> bool {
    danger! {
        return @intrinsic.fcmp.ole<fp128>(me, you)
    }
}

routine f128.__gt__(you: f128) -> bool {
    danger! {
        return @intrinsic.fcmp.ogt<fp128>(me, you)
    }
}

routine f128.__ge__(you: f128) -> bool {
    danger! {
        return @intrinsic.fcmp.oge<fp128>(me, you)
    }
}

# ============================================================================
# Math Operations using intrinsics
# ============================================================================

routine f128.sqrt() -> f128 {
    danger! {
        return @intrinsic.sqrt<fp128>(me)
    }
}

routine f128.abs() -> f128 {
    danger! {
        return @intrinsic.fabs<fp128>(me)
    }
}

routine f128.floor() -> f128 {
    danger! {
        return @intrinsic.floor<fp128>(me)
    }
}

routine f128.ceil() -> f128 {
    danger! {
        return @intrinsic.ceil<fp128>(me)
    }
}

routine f128.round() -> f128 {
    danger! {
        return @intrinsic.round<fp128>(me)
    }
}

routine f128.trunc() -> f128 {
    danger! {
        return @intrinsic.trunc_float<fp128>(me)
    }
}

# ============================================================================
# Trigonometric Functions (via LibBF native runtime)
# ============================================================================

routine f128.sin() -> f128 {
    danger! {
        return @native.rf_f128_sin(me)
    }
}

routine f128.cos() -> f128 {
    danger! {
        return @native.rf_f128_cos(me)
    }
}

routine f128.tan() -> f128 {
    danger! {
        return @native.rf_f128_tan(me)
    }
}

routine f128.asin() -> f128 {
    danger! {
        return @native.rf_f128_asin(me)
    }
}

routine f128.acos() -> f128 {
    danger! {
        return @native.rf_f128_acos(me)
    }
}

routine f128.atan() -> f128 {
    danger! {
        return @native.rf_f128_atan(me)
    }
}

routine f128.atan2(x: f128) -> f128 {
    danger! {
        return @native.rf_f128_atan2(me, x)
    }
}

# ============================================================================
# Hyperbolic Functions (via LibBF native runtime)
# ============================================================================

routine f128.sinh() -> f128 {
    danger! {
        return @native.rf_f128_sinh(me)
    }
}

routine f128.cosh() -> f128 {
    danger! {
        return @native.rf_f128_cosh(me)
    }
}

routine f128.tanh() -> f128 {
    danger! {
        return @native.rf_f128_tanh(me)
    }
}

routine f128.asinh() -> f128 {
    danger! {
        return @native.rf_f128_asinh(me)
    }
}

routine f128.acosh() -> f128 {
    danger! {
        return @native.rf_f128_acosh(me)
    }
}

routine f128.atanh() -> f128 {
    danger! {
        return @native.rf_f128_atanh(me)
    }
}

# ============================================================================
# Exponential and Logarithmic Functions (via LibBF native runtime)
# ============================================================================

routine f128.exp() -> f128 {
    danger! {
        return @native.rf_f128_exp(me)
    }
}

routine f128.exp2() -> f128 {
    danger! {
        return @native.rf_f128_exp2(me)
    }
}

routine f128.expm1() -> f128 {
    danger! {
        return @native.rf_f128_expm1(me)
    }
}

routine f128.log() -> f128 {
    danger! {
        return @native.rf_f128_log(me)
    }
}

routine f128.log2() -> f128 {
    danger! {
        return @native.rf_f128_log2(me)
    }
}

routine f128.log10() -> f128 {
    danger! {
        return @native.rf_f128_log10(me)
    }
}

routine f128.log1p() -> f128 {
    danger! {
        return @native.rf_f128_log1p(me)
    }
}

# ============================================================================
# Power Functions (via LibBF native runtime)
# ============================================================================

routine f128.pow(exp: f128) -> f128 {
    danger! {
        return @native.rf_f128_pow(me, exp)
    }
}

routine f128.cbrt() -> f128 {
    danger! {
        return @native.rf_f128_cbrt(me)
    }
}

routine f128.hypot(y: f128) -> f128 {
    danger! {
        return @native.rf_f128_hypot(me, y)
    }
}

routine f128.copysign(sign: f128) -> f128 {
    danger! {
        return @native.rf_f128_copysign(me, sign)
    }
}

# ============================================================================
# Utility Methods
# ============================================================================

routine f128.min(you: f128) -> f128 {
    return if me <= you then me else you
}

routine f128.max(you: f128) -> f128 {
    return if me >= you then me else you
}

routine f128.clamp(min_val: f128, max_val: f128) -> f128 {
    return me.min(max_val).max(min_val)
}

routine f128.is_positive() -> bool {
    return me > 0.0_f128
}

routine f128.is_negative() -> bool {
    return me < 0.0_f128
}

routine f128.is_zero() -> bool {
    return me == 0.0_f128
}

routine f128.signum() -> f128 {
    when {
        me > 0.0_f128 => 1.0_f128,
        me < 0.0_f128 => -1.0_f128,
        _ => 0.0_f128
    }
}

# Reinterpret bits as u128 (type punning)
routine f128.to_bits() -> u128 {
    danger! {
        return @intrinsic.bitcast<fp128, i128>(me)
    }
}

# Create f128 from u128 bits (type punning)
routine f128.from_bits(bits: u128) -> f128 {
    danger! {
        return @intrinsic.bitcast<i128, fp128>(bits)
    }
}

routine f128.to_text() -> Text {
    danger! {
        return @native.rf_format_f128(me)
    }
}

# RazorForge d64 (decimal64 floating point) native type implementation
# IEEE 754-2008 decimal floating point with 16 significant digits
# Uses Intel DFP library via imported C functions
namespace core

import FFI/cstr

# Core d64 type definition - stored as 64-bit value in BID encoding
record d64 {
    private value: u64
}

# Constants for d64
preset D64_ZERO: d64 = 0.0_d64
preset D64_ONE: d64 = 1.0_d64

# ============================================================================
# Constructors
# ============================================================================

routine d64.__create__!(from_text: Bytes) -> d64 {
    danger! {
        let cstr_val = from_text.to_cstr()
        let bits = @native.rf_d64_from_string(cstr_val)
        return @intrinsic.bitcast<u64, d64>(bits)
    }
}

routine d64.__create__(from: s8) -> d64 {
    danger! {
        let bits = @native.rf_d64_from_s32(s32(from))
        return @intrinsic.bitcast<u64, d64>(bits)
    }
}

routine d64.__create__(from: s16) -> d64 {
    danger! {
        let bits = @native.rf_d64_from_s32(s32(from))
        return @intrinsic.bitcast<u64, d64>(bits)
    }
}

routine d64.__create__(from: s32) -> d64 {
    danger! {
        let bits = @native.rf_d64_from_s32(from)
        return @intrinsic.bitcast<u64, d64>(bits)
    }
}

routine d64.__create__(from: s64) -> d64 {
    danger! {
        let bits = @native.rf_d64_from_s64(from)
        return @intrinsic.bitcast<u64, d64>(bits)
    }
}

routine d64.__create__(from: s128) -> d64 {
    # Convert through s64 - may lose precision
    return from.s64!().d64()
}

routine d64.__create__(from: u8) -> d64 {
    danger! {
        let bits = @native.rf_d64_from_u32(u32(from))
        return @intrinsic.bitcast<u64, d64>(bits)
    }
}

routine d64.__create__(from: u16) -> d64 {
    danger! {
        let bits = @native.rf_d64_from_u32(u32(from))
        return @intrinsic.bitcast<u64, d64>(bits)
    }
}

routine d64.__create__(from: u32) -> d64 {
    danger! {
        let bits = @native.rf_d64_from_u32(from)
        return @intrinsic.bitcast<u64, d64>(bits)
    }
}

routine d64.__create__(from: u64) -> d64 {
    danger! {
        let bits = @native.rf_d64_from_u64(from)
        return @intrinsic.bitcast<u64, d64>(bits)
    }
}

routine d64.__create__(from: u128) -> d64 {
    # Convert through u64 - may lose precision
    return from.u64!().d64()
}

routine d64.__create__(from: f16) -> d64 {
    return from.f32().d64()
}

routine d64.__create__(from: f32) -> d64 {
    danger! {
        let bits = @native.rf_f32_to_d64(from)
        return @intrinsic.bitcast<u64, d64>(bits)
    }
}

routine d64.__create__(from: f64) -> d64 {
    danger! {
        let bits = @native.rf_f64_to_d64(from)
        return @intrinsic.bitcast<u64, d64>(bits)
    }
}

routine d64.__create__(from: f128) -> d64 {
    return from.f64!().d64()
}

routine d64.__create__(from: d32) -> d64 {
    danger! {
        let bits = from.to_bits()
        let result_bits = @native.rf_d32_to_d64(bits)
        return @intrinsic.bitcast<u64, d64>(result_bits)
    }
}

routine d64.__create__(from: d64) -> d64 {
    return from
}

routine d64.__create__(from: d128) -> d64 {
    danger! {
        let result_bits = @native.rf_d128_to_d64(from.low_bits(), from.high_bits())
        return @intrinsic.bitcast<u64, d64>(result_bits)
    }
}

# From saddr - convert through s64
routine d64.__create__(from: saddr) -> d64 {
    return from.s64().d64()
}

# From uaddr - convert through u64
routine d64.__create__(from: uaddr) -> d64 {
    return from.u64().d64()
}

# ============================================================================
# Arithmetic Operations
# ============================================================================

routine d64.__add__(me: d64, you: d64) -> d64 {
    danger! {
        let a_bits = @intrinsic.bitcast<d64, u64>(me)
        let b_bits = @intrinsic.bitcast<d64, u64>(you)
        let result = @native.rf_d64_add(a_bits, b_bits)
        return @intrinsic.bitcast<u64, d64>(result)
    }
}

routine d64.__sub__(me: d64, you: d64) -> d64 {
    danger! {
        let a_bits = @intrinsic.bitcast<d64, u64>(me)
        let b_bits = @intrinsic.bitcast<d64, u64>(you)
        let result = @native.rf_d64_sub(a_bits, b_bits)
        return @intrinsic.bitcast<u64, d64>(result)
    }
}

routine d64.__mul__(me: d64, you: d64) -> d64 {
    danger! {
        let a_bits = @intrinsic.bitcast<d64, u64>(me)
        let b_bits = @intrinsic.bitcast<d64, u64>(you)
        let result = @native.rf_d64_mul(a_bits, b_bits)
        return @intrinsic.bitcast<u64, d64>(result)
    }
}

routine d64.__truediv__(me: d64, you: d64) -> d64 {
    danger! {
        let a_bits = @intrinsic.bitcast<d64, u64>(me)
        let b_bits = @intrinsic.bitcast<d64, u64>(you)
        let result = @native.rf_d64_div(a_bits, b_bits)
        return @intrinsic.bitcast<u64, d64>(result)
    }
}

routine d64.__neg__(me: d64) -> d64 {
    danger! {
        let zero_bits = @intrinsic.bitcast<d64, u64>(D64_ZERO)
        let me_bits = @intrinsic.bitcast<d64, u64>(me)
        let result = @native.rf_d64_sub(zero_bits, me_bits)
        return @intrinsic.bitcast<u64, d64>(result)
    }
}

# ============================================================================
# Comparison Operations
# ============================================================================

routine d64.__lt__(me: d64, you: d64) -> bool {
    danger! {
        let a_bits = @intrinsic.bitcast<d64, u64>(me)
        let b_bits = @intrinsic.bitcast<d64, u64>(you)
        return @native.rf_d64_cmp(a_bits, b_bits) < 0
    }
}

routine d64.__le__(me: d64, you: d64) -> bool {
    danger! {
        let a_bits = @intrinsic.bitcast<d64, u64>(me)
        let b_bits = @intrinsic.bitcast<d64, u64>(you)
        return @native.rf_d64_cmp(a_bits, b_bits) <= 0
    }
}

routine d64.__gt__(me: d64, you: d64) -> bool {
    danger! {
        let a_bits = @intrinsic.bitcast<d64, u64>(me)
        let b_bits = @intrinsic.bitcast<d64, u64>(you)
        return @native.rf_d64_cmp(a_bits, b_bits) > 0
    }
}

routine d64.__ge__(me: d64, you: d64) -> bool {
    danger! {
        let a_bits = @intrinsic.bitcast<d64, u64>(me)
        let b_bits = @intrinsic.bitcast<d64, u64>(you)
        return @native.rf_d64_cmp(a_bits, b_bits) >= 0
    }
}

routine d64.__eq__(me: d64, you: d64) -> bool {
    danger! {
        let a_bits = @intrinsic.bitcast<d64, u64>(me)
        let b_bits = @intrinsic.bitcast<d64, u64>(you)
        return @native.rf_d64_cmp(a_bits, b_bits) == 0
    }
}

routine d64.__ne__(me: d64, you: d64) -> bool {
    danger! {
        let a_bits = @intrinsic.bitcast<d64, u64>(me)
        let b_bits = @intrinsic.bitcast<d64, u64>(you)
        return @native.rf_d64_cmp(a_bits, b_bits) != 0
    }
}

# ============================================================================
# Math Operations
# ============================================================================

routine d64.sqrt(me: d64) -> d64 {
    danger! {
        let bits = @intrinsic.bitcast<d64, u64>(me)
        let result = @native.rf_d64_sqrt(bits)
        return @intrinsic.bitcast<u64, d64>(result)
    }
}

routine d64.abs(me: d64) -> d64 {
    danger! {
        let bits = @intrinsic.bitcast<d64, u64>(me)
        let result = @native.rf_d64_abs(bits)
        return @intrinsic.bitcast<u64, d64>(result)
    }
}

routine d64.ceil(me: d64) -> d64 {
    danger! {
        let bits = @intrinsic.bitcast<d64, u64>(me)
        let result = @native.rf_d64_ceil(bits)
        return @intrinsic.bitcast<u64, d64>(result)
    }
}

routine d64.floor(me: d64) -> d64 {
    danger! {
        let bits = @intrinsic.bitcast<d64, u64>(me)
        let result = @native.rf_d64_floor(bits)
        return @intrinsic.bitcast<u64, d64>(result)
    }
}

routine d64.round(me: d64) -> d64 {
    danger! {
        let bits = @intrinsic.bitcast<d64, u64>(me)
        let result = @native.rf_d64_round(bits)
        return @intrinsic.bitcast<u64, d64>(result)
    }
}

routine d64.trunc(me: d64) -> d64 {
    danger! {
        let bits = @intrinsic.bitcast<d64, u64>(me)
        let result = @native.rf_d64_trunc(bits)
        return @intrinsic.bitcast<u64, d64>(result)
    }
}

# ============================================================================
# Utility Methods
# ============================================================================

routine d64.min(me: d64, you: d64) -> d64 {
    danger! {
        let a_bits = @intrinsic.bitcast<d64, u64>(me)
        let b_bits = @intrinsic.bitcast<d64, u64>(you)
        return (if @native.rf_d64_cmp(a_bits, b_bits) <= 0 then me else you)
    }
}

routine d64.max(me: d64, you: d64) -> d64 {
    danger! {
        let a_bits = @intrinsic.bitcast<d64, u64>(me)
        let b_bits = @intrinsic.bitcast<d64, u64>(you)
        return (if @native.rf_d64_cmp(a_bits, b_bits) >= 0 then me else you)
    }
}

routine d64.clamp(me: d64, min_val: d64, max_val: d64) -> d64 {
    return me.min(max_val).max(min_val)
}

routine d64.is_positive(me: d64) -> bool {
    danger! {
        let me_bits = @intrinsic.bitcast<d64, u64>(me)
        let zero_bits = @intrinsic.bitcast<d64, u64>(D64_ZERO)
        return @native.rf_d64_cmp(me_bits, zero_bits) > 0
    }
}

routine d64.is_negative(me: d64) -> bool {
    danger! {
        let me_bits = @intrinsic.bitcast<d64, u64>(me)
        let zero_bits = @intrinsic.bitcast<d64, u64>(D64_ZERO)
        return @native.rf_d64_cmp(me_bits, zero_bits) < 0
    }
}

routine d64.is_zero(me: d64) -> bool {
    danger! {
        let me_bits = @intrinsic.bitcast<d64, u64>(me)
        let zero_bits = @intrinsic.bitcast<d64, u64>(D64_ZERO)
        return @native.rf_d64_cmp(me_bits, zero_bits) == 0
    }
}

routine d64.signum(me: d64) -> d64 {
    danger! {
        let me_bits = @intrinsic.bitcast<d64, u64>(me)
        let zero_bits = @intrinsic.bitcast<d64, u64>(D64_ZERO)
        let cmp = @native.rf_d64_cmp(me_bits, zero_bits)
        when {
            cmp > 0 => D64_ONE,
            cmp < 0 => me.__neg__(),
            _ => D64_ZERO
        }
    }
}

# Reinterpret bits as u64 (type punning)
routine d64.to_bits(me: d64) -> u64 {
    danger! {
        return @intrinsic.bitcast<d64, u64>(me)
    }
}

# Create d64 from u64 bits (type punning)
routine d64.from_bits(bits: u64) -> d64 {
    danger! {
        return @intrinsic.bitcast<u64, d64>(bits)
    }
}

# ============================================================================
# String Conversion
# ============================================================================

routine d64.to_text(me: d64) -> Text {
    danger! {
        let bits = @intrinsic.bitcast<d64, u64>(me)
        let cstr_result = @native.rf_d64_to_string(bits)
        return Text.from_cstr(cstr_result)
    }
}

# RazorForge s16 (signed 16-bit integer) native type implementation
# Maps directly to LLVM i16 type using compiler intrinsics

# Core s16 type definition - maps to LLVM i16
record s16 {
    public value: LlvmNativeI16
}

# Constants for s16 limits
preset S16_MIN: s16 = -32768_s16
preset S16_MAX: s16 = 32767_s16
preset S16_ZERO: s16 = 0_s16
preset S16_ONE: s16 = 1_s16

# ============================================================================
# Arithmetic Operations (trapping on overflow by default)
# ============================================================================

routine s16.__add__(other: s16) -> s16 {
    danger! {
        return @intrinsic.add<i16>(me, other)
    }
}

routine s16.__sub__(other: s16) -> s16 {
    danger! {
        return @intrinsic.sub<i16>(me, other)
    }
}

routine s16.__mul__(other: s16) -> s16 {
    danger! {
        return @intrinsic.mul<i16>(me, other)
    }
}

routine s16.__floordiv__(other: s16) -> s16 {
    danger! {
        return @intrinsic.sdiv<i16>(me, other)
    }
}

routine s16.__mod__(other: s16) -> s16 {
    danger! {
        return @intrinsic.srem<i16>(me, other)
    }
}

routine s16.__neg__() -> s16 {
    danger! {
        return @intrinsic.neg<i16>(me)
    }
}

# ============================================================================
# Wrapping Arithmetic (+%, -%, *%)
# ============================================================================

routine s16.__add_wrap__(other: s16) -> s16 {
    danger! {
        return @intrinsic.add.wrapping<i16>(me, other)
    }
}

routine s16.__sub_wrap__(other: s16) -> s16 {
    danger! {
        return @intrinsic.sub.wrapping<i16>(me, other)
    }
}

routine s16.__mul_wrap__(other: s16) -> s16 {
    danger! {
        return @intrinsic.mul.wrapping<i16>(me, other)
    }
}

# ============================================================================
# Saturating Arithmetic (+^, -^, *^)
# ============================================================================

routine s16.__add_sat__(other: s16) -> s16 {
    danger! {
        return @intrinsic.add.saturating<i16>(me, other)
    }
}

routine s16.__sub_sat__(other: s16) -> s16 {
    danger! {
        return @intrinsic.sub.saturating<i16>(me, other)
    }
}

routine s16.__mul_sat__(other: s16) -> s16 {
    danger! {
        return @intrinsic.mul.saturating<i16>(me, other)
    }
}

# ============================================================================
# Checked Arithmetic (+?, -?, *?) - returns Maybe<T>
# ============================================================================

routine s16.__add_checked__(other: s16) -> Maybe<s16> {
    danger! {
        let (result, overflow) = @intrinsic.add.overflow<i16>(me, other)
        return if overflow { None } else { result }
    }
}

routine s16.__sub_checked__(other: s16) -> Maybe<s16> {
    danger! {
        let (result, overflow) = @intrinsic.sub.overflow<i16>(me, other)
        return if overflow { None } else { result }
    }
}

routine s16.__mul_checked__(other: s16) -> Maybe<s16> {
    danger! {
        let (result, overflow) = @intrinsic.mul.overflow<i16>(me, other)
        return if overflow { None } else { result }
    }
}

# ============================================================================
# Bitwise Operations
# ============================================================================

routine s16.__and__(other: s16) -> s16 {
    danger! {
        return @intrinsic.and<i16>(me, other)
    }
}

routine s16.__or__(other: s16) -> s16 {
    danger! {
        return @intrinsic.or<i16>(me, other)
    }
}

routine s16.__xor__(other: s16) -> s16 {
    danger! {
        return @intrinsic.xor<i16>(me, other)
    }
}

routine s16.__not__() -> s16 {
    danger! {
        return @intrinsic.not<i16>(me)
    }
}

routine s16.__shl__(bits: u32) -> s16 {
    danger! {
        return @intrinsic.shl<i16>(me, bits)
    }
}

routine s16.__shr__(bits: u32) -> s16 {
    danger! {
        return @intrinsic.ashr<i16>(me, bits)
    }
}

# ============================================================================
# Comparison Operations
# ============================================================================

routine s16.__eq__(other: s16) -> bool {
    danger! {
        return @intrinsic.icmp.eq<i16>(me, other)
    }
}

routine s16.__ne__(other: s16) -> bool {
    danger! {
        return @intrinsic.icmp.ne<i16>(me, other)
    }
}

routine s16.__lt__(other: s16) -> bool {
    danger! {
        return @intrinsic.icmp.slt<i16>(me, other)
    }
}

routine s16.__le__(other: s16) -> bool {
    danger! {
        return @intrinsic.icmp.sle<i16>(me, other)
    }
}

routine s16.__gt__(other: s16) -> bool {
    danger! {
        return @intrinsic.icmp.sgt<i16>(me, other)
    }
}

routine s16.__ge__(other: s16) -> bool {
    danger! {
        return @intrinsic.icmp.sge<i16>(me, other)
    }
}

# ============================================================================
# Math Operations
# ============================================================================

routine s16.abs() -> s16 {
    danger! {
        return @intrinsic.abs<i16>(me)
    }
}

routine s16.min(other: s16) -> s16 {
    return if me <= other then me else other
}

routine s16.max(other: s16) -> s16 {
    return if me >= other then me else other
}

routine s16.clamp(min_val: s16, max_val: s16) -> s16 {
    return me.min(max_val).max(min_val)
}

# ============================================================================
# Bit Manipulation
# ============================================================================

routine s16.count_ones() -> s16 {
    danger! {
        return @intrinsic.ctpop<i16>(me)
    }
}

routine s16.count_zeros() -> s16 {
    return 16_s16 - me.count_ones()
}

routine s16.leading_zeros() -> s16 {
    danger! {
        return @intrinsic.ctlz<i16>(me)
    }
}

routine s16.trailing_zeros() -> s16 {
    danger! {
        return @intrinsic.cttz<i16>(me)
    }
}

routine s16.leading_ones() -> s16 {
    return me.__not__().leading_zeros()
}

routine s16.trailing_ones() -> s16 {
    return me.__not__().trailing_zeros()
}

routine s16.reverse_bits() -> s16 {
    danger! {
        return @intrinsic.bitreverse<i16>(me)
    }
}

routine s16.swap_bytes() -> s16 {
    danger! {
        return @intrinsic.bswap<i16>(me)
    }
}

# ============================================================================
# Type Conversions (constructor syntax)
# ============================================================================

# Bitcast to unsigned
routine u16(from: s16) -> u16 {
    danger! {
        return @intrinsic.bitcast<i16, i16>(from)
    }
}

# Sign-extend to larger types
routine s32(from: s16) -> s32 {
    danger! {
        return @intrinsic.sext<i16, i32>(from)
    }
}

routine s64(from: s16) -> s64 {
    danger! {
        return @intrinsic.sext<i16, i64>(from)
    }
}

routine s128(from: s16) -> s128 {
    danger! {
        return @intrinsic.sext<i16, i128>(from)
    }
}

# Truncate to smaller types
routine s8(from: s16) -> s8 {
    danger! {
        return @intrinsic.trunc<i16, i8>(from)
    }
}

# Convert to floating point
routine f32(from: s16) -> f32 {
    danger! {
        return @intrinsic.sitofp<i16, float>(from)
    }
}

routine f64(from: s16) -> f64 {
    danger! {
        return @intrinsic.sitofp<i16, double>(from)
    }
}

# Convert to boolean
routine bool(from: s16) -> bool {
    danger! {
        return @intrinsic.icmp.ne<i16>(from, 0_s16)
    }
}

# ============================================================================
# Utility Methods
# ============================================================================

routine s16.is_positive() -> bool {
    return me > 0_s16
}

routine s16.is_negative() -> bool {
    return me < 0_s16
}

routine s16.is_zero() -> bool {
    return me == 0_s16
}

routine s16.is_even() -> bool {
    danger! {
        let result = @intrinsic.and<i16>(me, 1_s16)
        return @intrinsic.icmp.eq<i16>(result, 0_s16)
    }
}

routine s16.is_odd() -> bool {
    return not me.is_even()
}

routine s16.signum() -> s16 {
    when {
        me > 0_s16 => 1_s16,
        me < 0_s16 => -1_s16,
        _ => 0_s16
    }
}

# ============================================================================
# String Conversion
# ============================================================================

routine s16.to_text() -> Text {
    danger! {
        return @format_s16(me)
    }
}

# ============================================================================
# Checked Constructors (crash on overflow)
# ============================================================================

# Failable constructor from Text - called as s16!(text)
# Compiler automatically generates try_s16.__create__(text) -> Maybe<s16>
routine s16.__create__!(from_text: Text<Letterlikes>) -> s16 {
    danger! {
        return @parse_s16(from_text)
    }
}

# From s32 - crashes if value out of s16 range
routine s16.__create__!(from: s32) -> s16 {
    if not (S16_MIN <= from <= S16_MAX) {
        throw IntegerOverflowError(f"Cannot convert {from} to s16: value out of range [{S16_MIN}, {S16_MAX}]")
    }
    danger! {
        return @intrinsic.trunc<i32, i16>(from)
    }
}

# From s64 - crashes if value out of s16 range
routine s16.__create__!(from: s64) -> s16 {
    if not (S16_MIN <= from <= S16_MAX) {
        throw IntegerOverflowError(f"Cannot convert {from} to s16: value out of range [{S16_MIN}, {S16_MAX}]")
    }
    danger! {
        return @intrinsic.trunc<i64, i16>(from)
    }
}

# From s128 - crashes if value out of s16 range
routine s16.__create__!(from: s128) -> s16 {
    if not (S16_MIN <= from <= S16_MAX) {
        throw IntegerOverflowError(f"Cannot convert {from} to s16: value out of range [{S16_MIN}, {S16_MAX}]")
    }
    danger! {
        return @intrinsic.trunc<i128, i16>(from)
    }
}

# From u8 - always fits, no check needed
routine s16.__create__!(from: u8) -> s16 {
    danger! {
        return @intrinsic.zext<i8, i16>(from)
    }
}

# From u16 - crashes if value > S16_MAX (bit 15 set)
routine s16.__create__!(from: u16) -> s16 {
    if from > 32767_u16 {
        throw IntegerOverflowError(f"Cannot convert {from} to s16: value out of range [{S16_MIN}, {S16_MAX}]")
    }
    danger! {
        return @intrinsic.bitcast<i16, i16>(from)
    }
}

# From u32 - crashes if value > S16_MAX
routine s16.__create__!(from: u32) -> s16 {
    if from > 32767_u32 {
        throw IntegerOverflowError(f"Cannot convert {from} to s16: value out of range [{S16_MIN}, {S16_MAX}]")
    }
    danger! {
        return @intrinsic.trunc<i32, i16>(from)
    }
}

# From u64 - crashes if value > S16_MAX
routine s16.__create__!(from: u64) -> s16 {
    if from > 32767_u64 {
        throw IntegerOverflowError(f"Cannot convert {from} to s16: value out of range [{S16_MIN}, {S16_MAX}]")
    }
    danger! {
        return @intrinsic.trunc<i64, i16>(from)
    }
}

# From u128 - crashes if value > S16_MAX
routine s16.__create__!(from: u128) -> s16 {
    if from > 32767_u128 {
        throw IntegerOverflowError(f"Cannot convert {from} to s16: value out of range [{S16_MIN}, {S16_MAX}]")
    }
    danger! {
        return @intrinsic.trunc<i128, i16>(from)
    }
}

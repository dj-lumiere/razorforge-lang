# RazorForge s128 (signed 128-bit integer) native type implementation
# Maps directly to LLVM i128 type using compiler intrinsics

# Core s128 type definition - maps to LLVM i128
record s128 {
    public value: LlvmNativeI128
}

# Constants for s128 limits
preset S128_MIN: s128 = -170_141_183_460_469_231_731_687_303_715_884_105_728_s128
preset S128_MAX: s128 = 170_141_183_460_469_231_731_687_303_715_884_105_727_s128
preset S128_ZERO: s128 = 0_s128
preset S128_ONE: s128 = 1_s128

# ============================================================================
# Checked Constructors (crash on overflow)
# ============================================================================

# Failable constructor from Text - called as s128!(text)
# Compiler automatically generates try_s128.__create__(text) -> Maybe<s128>
routine s128.__create__!(from_text: Text<Letterlikes>) -> s128 {
    danger! {
        return @parse_s128(from_text)
    }
}

# From u8 - always fits, no check needed
routine s128.__create__!(from: u8) -> s128 {
    danger! {
        return @intrinsic.zext<i8, i128>(from)
    }
}

# From u16 - always fits, no check needed
routine s128.__create__!(from: u16) -> s128 {
    danger! {
        return @intrinsic.zext<i16, i128>(from)
    }
}

# From u32 - always fits, no check needed
routine s128.__create__!(from: u32) -> s128 {
    danger! {
        return @intrinsic.zext<i32, i128>(from)
    }
}

# From u64 - always fits, no check needed
routine s128.__create__!(from: u64) -> s128 {
    danger! {
        return @intrinsic.zext<i64, i128>(from)
    }
}

# From u128 - crashes if value > S128_MAX (bit 127 set)
routine s128.__create__!(from: u128) -> s128 {
    if from > 170141183460469231731687303715884105727_u128 {
        throw IntegerOverflowError(f"Cannot convert {from} to s128: value out of range [{S128_MIN}, {S128_MAX}]")
    }
    danger! {
        return @intrinsic.bitcast<i128, i128>(from)
    }
}

# ============================================================================
# Arithmetic Operations (trapping on overflow by default)
# ============================================================================
@crash_only
routine s128.__add__!(other: s128) -> s128 {
    danger! {
        return @intrinsic.add<i128>(me, other)
    }
}

@crash_only
routine s128.__sub__!(other: s128) -> s128 {
    danger! {
        return @intrinsic.sub<i128>(me, other)
    }
}

@crash_only
routine s128.__mul__!(other: s128) -> s128 {
    danger! {
        return @intrinsic.mul<i128>(me, other)
    }
}

@crash_only
routine s128.__floordiv__!(other: s128) -> s128 {
    if other == 0 {
        throw DivisionByZeroError()
    }
    danger! {
        return @intrinsic.sdiv<i128>(me, other)
    }
}

@crash_only
routine s128.__mod__!(other: s128) -> s128 {
    danger! {
        return @intrinsic.srem<i128>(me, other)
    }
}

@crash_only
routine s128.__neg__!() -> s128 {
    danger! {
        return @intrinsic.neg<i128>(me)
    }
}

# ============================================================================
# Wrapping Arithmetic (+%, -%, *%)
# ============================================================================

routine s128.__add_wrap__(other: s128) -> s128 {
    danger! {
        return @intrinsic.add.wrapping<i128>(me, other)
    }
}

routine s128.__sub_wrap__(other: s128) -> s128 {
    danger! {
        return @intrinsic.sub.wrapping<i128>(me, other)
    }
}

routine s128.__mul_wrap__(other: s128) -> s128 {
    danger! {
        return @intrinsic.mul.wrapping<i128>(me, other)
    }
}

# ============================================================================
# Saturating Arithmetic (+^, -^, *^)
# ============================================================================

routine s128.__add_sat__(other: s128) -> s128 {
    danger! {
        return @intrinsic.add.saturating<i128>(me, other)
    }
}

routine s128.__sub_sat__(other: s128) -> s128 {
    danger! {
        return @intrinsic.sub.saturating<i128>(me, other)
    }
}

routine s128.__mul_sat__(other: s128) -> s128 {
    danger! {
        return @intrinsic.mul.saturating<i128>(me, other)
    }
}

# ============================================================================
# Checked Arithmetic (+?, -?, *?) - returns Maybe<T>
# ============================================================================

routine s128.__add_checked__(other: s128) -> Maybe<s128> {
    danger! {
        let (result, overflow) = @intrinsic.add.overflow<i128>(me, other)
        return if overflow { None } else { result }
    }
}

routine s128.__sub_checked__(other: s128) -> Maybe<s128> {
    danger! {
        let (result, overflow) = @intrinsic.sub.overflow<i128>(me, other)
        return if overflow { None } else { result }
    }
}

routine s128.__mul_checked__(other: s128) -> Maybe<s128> {
    danger! {
        let (result, overflow) = @intrinsic.mul.overflow<i128>(me, other)
        return if overflow { None } else { result }
    }
}

# ============================================================================
# Power Operations (**)
# ============================================================================

# Power operator (**) - can overflow
@crash_only
routine s128.__pow__!(exp: s128) -> s128 {
    danger! {
        var result: s128 = 1
        var base: s128 = me
        var e: u32 = exp
        if me == 0 and exp == 0 {
            throw IndeterminateResultError()
        }
        if exp < 0 {
            return NegativeExponentError(exp)
        }
        while e > 0 {
            if (e & 1) == 1 {
                result = @intrinsic.mul<i128>(result, base)
            }
            base = @intrinsic.mul<i128>(base, base)
            e = e >> 1
        }
        return result
    }
}

# Wrapping power (**%)
@crash_only
routine s128.__pow_wrap__!(exp: s128) -> s128 {
    danger! {
        var result: s128 = 1
        var base: s128 = me
        var e: u32 = exp
        if me == 0 and exp == 0 {
            throw IndeterminateResultError()
        }
        if exp < 0 {
            return NegativeExponentError(exp)
        }
        while e > 0 {
            if (e & 1) == 1 {
                result = @intrinsic.mul.wrapping<i128>(result, base)
            }
            base = @intrinsic.mul.wrapping<i128>(base, base)
            e = e >> 1
        }
        return result
    }
}

# Saturating power (**^)
@crash_only
routine s128.__pow_sat__!(exp: s128) -> s128 {
    danger! {
        var result: s128 = 1
        var base: s128 = me
        var e: u32 = exp
        if me == 0 and exp == 0 {
            throw IndeterminateResultError()
        }
        if exp < 0 {
            return NegativeExponentError(exp)
        }
        while e > 0 {
            if (e & 1) == 1 {
                result = @intrinsic.mul.saturating<i128>(result, base)
            }
            base = @intrinsic.mul.saturating<i128>(base, base)
            e = e >> 1
        }
        return result
    }
}

# Checked power (**?) - returns Maybe<s128>
routine s128.__pow_checked__(exp: s128) -> Maybe<s128> {
    danger! {
        var result: s128 = 1
        var base: s128 = me
        var e: u32 = exp
        if exp < 0 or me == 0 {
            return None
        }
        while e > 0 {
            if (e & 1) == 1 {
                let (new_result, overflow) = @intrinsic.mul.overflow<i128>(result, base)
                if overflow {
                    return None
                }
                result = new_result
            }
            let (new_base, overflow) = @intrinsic.mul.overflow<i128>(base, base)
            if overflow and e > 1 {
                return None
            }
            base = new_base
            e = e >> 1
        }
        return result
    }
}

# ============================================================================
# Bitwise Operations
# ============================================================================

routine s128.__and__(other: s128) -> s128 {
    danger! {
        return @intrinsic.and<i128>(me, other)
    }
}

routine s128.__or__(other: s128) -> s128 {
    danger! {
        return @intrinsic.or<i128>(me, other)
    }
}

routine s128.__xor__(other: s128) -> s128 {
    danger! {
        return @intrinsic.xor<i128>(me, other)
    }
}

routine s128.__not__() -> s128 {
    danger! {
        return @intrinsic.not<i128>(me)
    }
}

# ============================================================================
# Shift Operations (<<, <<?>, >>, <<<, >>>)
# ============================================================================

# Arithmetic left shift (<<) - sign preserving
routine s128.__ashl__(bits: u32) -> s128 {
    danger! {
        return @intrinsic.shl<i128>(me, bits)
    }
}

# Checked arithmetic left shift (<<?) - returns Maybe<s128>
routine s128.__ashl_checked__(bits: u32) -> Maybe<s128> {
    danger! {
        if bits >= 128 {
            return None
        }
        let result = @intrinsic.shl<i128>(me, bits)
        # Check if we can recover the original value
        let recovered = @intrinsic.ashr<i128>(result, bits)
        if recovered != me {
            return None
        }
        return result
    }
}

# Arithmetic right shift (>>) - preserves sign, always safe
routine s128.__ashr__(bits: u32) -> s128 {
    danger! {
        return @intrinsic.ashr<i128>(me, bits)
    }
}

# Logical left shift (<<<) - same as << but explicit
routine s128.__lshl__(bits: u32) -> s128 {
    danger! {
        return @intrinsic.shl<i128>(me, bits)
    }
}

# Logical right shift (>>>) - fills with zeros, ignores sign
routine s128.__lshr__(bits: u32) -> s128 {
    danger! {
        return @intrinsic.lshr<i128>(me, bits)
    }
}

# ============================================================================
# Comparison Operations
# ============================================================================

routine s128.__eq__(other: s128) -> bool {
    danger! {
        return @intrinsic.icmp.eq<i128>(me, other)
    }
}

routine s128.__ne__(other: s128) -> bool {
    danger! {
        return @intrinsic.icmp.ne<i128>(me, other)
    }
}

routine s128.__lt__(other: s128) -> bool {
    danger! {
        return @intrinsic.icmp.slt<i128>(me, other)
    }
}

routine s128.__le__(other: s128) -> bool {
    danger! {
        return @intrinsic.icmp.sle<i128>(me, other)
    }
}

routine s128.__gt__(other: s128) -> bool {
    danger! {
        return @intrinsic.icmp.sgt<i128>(me, other)
    }
}

routine s128.__ge__(other: s128) -> bool {
    danger! {
        return @intrinsic.icmp.sge<i128>(me, other)
    }
}

# ============================================================================
# Math Operations
# ============================================================================

routine s128.abs() -> s128 {
    danger! {
        return @intrinsic.abs<i128>(me)
    }
}

routine s128.min(other: s128) -> s128 {
    return if me <= other then me else other
}

routine s128.max(other: s128) -> s128 {
    return if me >= other then me else other
}

routine s128.clamp(min_val: s128, max_val: s128) -> s128 {
    return me.min(max_val).max(min_val)
}

# ============================================================================
# Bit Manipulation
# ============================================================================

routine s128.count_ones() -> s128 {
    danger! {
        return @intrinsic.ctpop<i128>(me)
    }
}

routine s128.count_zeros() -> s128 {
    return 128_s128 - me.count_ones()
}

routine s128.leading_zeros() -> s128 {
    danger! {
        return @intrinsic.ctlz<i128>(me)
    }
}

routine s128.trailing_zeros() -> s128 {
    danger! {
        return @intrinsic.cttz<i128>(me)
    }
}

routine s128.leading_ones() -> s128 {
    return me.__not__().leading_zeros()
}

routine s128.trailing_ones() -> s128 {
    return me.__not__().trailing_zeros()
}

routine s128.reverse_bits() -> s128 {
    danger! {
        return @intrinsic.bitreverse<i128>(me)
    }
}

routine s128.swap_bytes() -> s128 {
    danger! {
        return @intrinsic.bswap<i128>(me)
    }
}

# ============================================================================
# Type Conversions (constructor syntax)
# ============================================================================

# Bitcast to unsigned
routine u128(from: s128) -> u128 {
    danger! {
        return @intrinsic.bitcast<i128, i128>(from)
    }
}

# Truncate to smaller types
routine s64(from: s128) -> s64 {
    danger! {
        return @intrinsic.trunc<i128, i64>(from)
    }
}

routine s32(from: s128) -> s32 {
    danger! {
        return @intrinsic.trunc<i128, i32>(from)
    }
}

routine s16(from: s128) -> s16 {
    danger! {
        return @intrinsic.trunc<i128, i16>(from)
    }
}

routine s8(from: s128) -> s8 {
    danger! {
        return @intrinsic.trunc<i128, i8>(from)
    }
}

# Convert to floating point
routine f32(from: s128) -> f32 {
    danger! {
        return @intrinsic.sitofp<i128, float>(from)
    }
}

routine f64(from: s128) -> f64 {
    danger! {
        return @intrinsic.sitofp<i128, double>(from)
    }
}

# Convert to boolean
routine bool(from: s128) -> bool {
    danger! {
        return @intrinsic.icmp.ne<i128>(from, 0_s128)
    }
}

# ============================================================================
# Utility Methods
# ============================================================================

routine s128.is_positive() -> bool {
    return me > 0_s128
}

routine s128.is_negative() -> bool {
    return me < 0_s128
}

routine s128.is_zero() -> bool {
    return me == 0_s128
}

routine s128.is_even() -> bool {
    danger! {
        let result = @intrinsic.and<i128>(me, 1_s128)
        return @intrinsic.icmp.eq<i128>(result, 0_s128)
    }
}

routine s128.is_odd() -> bool {
    return not me.is_even()
}

routine s128.signum() -> s128 {
    when {
        me > 0_s128 => 1_s128,
        me < 0_s128 => -1_s128,
        _ => 0_s128
    }
}

# ============================================================================
# String Conversion
# ============================================================================

routine s128.to_text() -> Text {
    danger! {
        return @format_s128(me)
    }
}

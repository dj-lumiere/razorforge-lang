# RazorForge f64 (double precision floating point) native type implementation
# Maps directly to LLVM double type using compiler intrinsics
namespace core
# Core f64 type definition - maps to LLVM double
record f64 {
    private value: @intrinsic.f64
}

# IEEE 754 double precision constants
preset F64_EPSILON: f64 = 2.220446049250313e-16_f64
preset F64_MIN: f64 = 2.2250738585072014e-308_f64
preset F64_MAX: f64 = 1.7976931348623157e+308_f64
preset F64_ZERO: f64 = 0.0_f64
preset F64_ONE: f64 = 1.0_f64
preset F64_NAN: f64 = 0.0_f64 / 0.0_f64  # TODO: Proper NaN constant
preset F64_INFINITY: f64 = 1.0_f64 / 0.0_f64  # TODO: Proper infinity constant

# ============================================================================
# Constructors
# ============================================================================

# Failable constructor from Text - called as f64!(text)
# Compiler automatically generates try_f64.__create__(text) -> Maybe<f64>
routine f64.__create__!(from_text: Text<Letter>) -> f64 {
    danger! {
        return @native.rf_parse_f64(from_text)
    }
}

routine f64.__create__(from: s8) -> f64 {
    danger! {
        return @intrinsic.sitofp<i8, double>(from)
    }
}

routine f64.__create__(from: s16) -> f64 {
    danger! {
        return @intrinsic.sitofp<i16, double>(from)
    }
}

routine f64.__create__(from: s32) -> f64 {
    danger! {
        return @intrinsic.sitofp<i32, double>(from)
    }
}

routine f64.__create__(from: s64) -> f64 {
    danger! {
        return @intrinsic.sitofp<i64, double>(from)
    }
}

routine f64.__create__(from: s128) -> f64 {
    danger! {
        return @intrinsic.sitofp<i128, double>(from)
    }
}

routine f64.__create__(from: u8) -> f64 {
    danger! {
        return @intrinsic.uitofp<i8, double>(from)
    }
}

routine f64.__create__(from: u16) -> f64 {
    danger! {
        return @intrinsic.uitofp<i16, double>(from)
    }
}

routine f64.__create__(from: u32) -> f64 {
    danger! {
        return @intrinsic.uitofp<i32, double>(from)
    }
}

routine f64.__create__(from: u64) -> f64 {
    danger! {
        return @intrinsic.uitofp<i64, double>(from)
    }
}

routine f64.__create__(from: u128) -> f64 {
    danger! {
        return @intrinsic.uitofp<i128, double>(from)
    }
}

routine f64.__create__(from: f16) -> f64 {
    danger! {
        return @intrinsic.fpext<half, double>(from)
    }
}

routine f64.__create__(from: f32) -> f64 {
    danger! {
        return @intrinsic.fpext<float, double>(from)
    }
}

routine f64.__create__(from: f64) -> f64 {
    return from
}

routine f64.__create__(from: f128) -> f64 {
    danger! {
        return @intrinsic.fptrunc<fp128, double>(from)
    }
}

routine f64.__create__(from: d32) -> f64 {
    danger! {
        let bits = @intrinsic.bitcast<d32, u32>(from)
        return @native.rf_d32_to_f64(bits)
    }
}

routine f64.__create__(from: d64) -> f64 {
    danger! {
        let bits = @intrinsic.bitcast<d64, u64>(from)
        return @native.rf_d64_to_f64(bits)
    }
}

routine f64.__create__(from: d128) -> f64 {
    danger! {
        return @native.rf_d128_to_f64(from.low_bits(), from.high_bits())
    }
}

# From saddr - convert to float (may lose precision)
routine f64.__create__(from: saddr) -> f64 {
    danger! {
        return @intrinsic.sitofp<iptr, double>(from)
    }
}

# From uaddr - convert to float (may lose precision)
routine f64.__create__(from: uaddr) -> f64 {
    danger! {
        return @intrinsic.uitofp<uptr, double>(from)
    }
}

# ============================================================================
# Arithmetic Operations
# ============================================================================

routine f64.__add__(you: f64) -> f64 {
    danger! {
        return @intrinsic.add.wrapping<double>(me, you)
    }
}

routine f64.__sub__(you: f64) -> f64 {
    danger! {
        return @intrinsic.sub.wrapping<double>(me, you)
    }
}

routine f64.__mul__(you: f64) -> f64 {
    danger! {
        return @intrinsic.mul.wrapping<double>(me, you)
    }
}

routine f64.__truediv__(you: f64) -> f64 {
    danger! {
        return @intrinsic.div.wrapping<double>(me, you)
    }
}

routine f64.__neg__() -> f64 {
    danger! {
        return @intrinsic.sub.wrapping<double>(0.0_f64, me)
    }
}

# ============================================================================
# Comparison Operations (ordered - false if NaN)
# ============================================================================

routine f64.__lt__(you: f64) -> bool {
    danger! {
        return @intrinsic.fcmp.olt<double>(me, you)
    }
}

routine f64.__le__(you: f64) -> bool {
    danger! {
        return @intrinsic.fcmp.ole<double>(me, you)
    }
}

routine f64.__gt__(you: f64) -> bool {
    danger! {
        return @intrinsic.fcmp.ogt<double>(me, you)
    }
}

routine f64.__ge__(you: f64) -> bool {
    danger! {
        return @intrinsic.fcmp.oge<double>(me, you)
    }
}

# ============================================================================
# Math Operations using intrinsics
# ============================================================================

routine f64.sqrt() -> f64 {
    danger! {
        return @intrinsic.sqrt<double>(me)
    }
}

routine f64.abs() -> f64 {
    danger! {
        return @intrinsic.fabs<double>(me)
    }
}

routine f64.floor() -> f64 {
    danger! {
        return @intrinsic.floor<double>(me)
    }
}

routine f64.ceil() -> f64 {
    danger! {
        return @intrinsic.ceil<double>(me)
    }
}

routine f64.round() -> f64 {
    danger! {
        return @intrinsic.round<double>(me)
    }
}

routine f64.trunc() -> f64 {
    danger! {
        return @intrinsic.trunc_float<double>(me)
    }
}

# Trigonometric functions
routine f64.sin() -> f64 {
    danger! {
        return @intrinsic.sin<double>(me)
    }
}

routine f64.cos() -> f64 {
    danger! {
        return @intrinsic.cos<double>(me)
    }
}

# Exponential and logarithmic
routine f64.exp() -> f64 {
    danger! {
        return @intrinsic.exp<double>(me)
    }
}

routine f64.log() -> f64 {
    danger! {
        return @intrinsic.log<double>(me)
    }
}

routine f64.log10() -> f64 {
    danger! {
        return @intrinsic.log10<double>(me)
    }
}

routine f64.pow(exp: f64) -> f64 {
    danger! {
        return @intrinsic.pow<double>(me, exp)
    }
}

routine f64.copysign(sign: f64) -> f64 {
    danger! {
        return @intrinsic.copysign<double>(me, sign)
    }
}

# ============================================================================
# Utility Methods
# ============================================================================

routine f64.min(you: f64) -> f64 {
    return if me <= you then me else you
}

routine f64.max(you: f64) -> f64 {
    return if me >= you then me else you
}

routine f64.clamp(min_val: f64, max_val: f64) -> f64 {
    return me.min(max_val).max(min_val)
}

routine f64.is_positive() -> bool {
    return me > 0.0_f64
}

routine f64.is_negative() -> bool {
    return me < 0.0_f64
}

routine f64.is_zero() -> bool {
    return me == 0.0_f64
}

# TODO: Implement NaN/Infinity checks when we have proper constants
routine f64.is_finite() -> bool {
    # Placeholder - needs proper implementation
    return true
}

routine f64.signum() -> f64 {
    when {
        me > 0.0_f64 => 1.0_f64,
        me < 0.0_f64 => -1.0_f64,
        _ => 0.0_f64
    }
}

routine f64.to_text() -> Text {
    danger! {
        return @native.rf_format_f64(me)
    }
}

# Reinterpret bits as u64 (type punning)
routine f64.to_bits() -> u64 {
    danger! {
        return @intrinsic.bitcast<double, i64>(me)
    }
}

# Create f64 from u64 bits (type punning)
routine f64.from_bits(bits: u64) -> f64 {
    danger! {
        return @intrinsic.bitcast<i64, double>(bits)
    }
}

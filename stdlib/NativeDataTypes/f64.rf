# RazorForge f64 (double precision floating point) native type implementation
# Maps directly to LLVM double type using compiler intrinsics

# Core f64 type definition - maps to LLVM double
record f64 {
    public value: LlvmNativeDouble
}

# IEEE 754 double precision constants
preset F64_EPSILON: f64 = 2.220446049250313e-16_f64
preset F64_MIN: f64 = 2.2250738585072014e-308_f64
preset F64_MAX: f64 = 1.7976931348623157e+308_f64
preset F64_ZERO: f64 = 0.0_f64
preset F64_ONE: f64 = 1.0_f64
preset F64_NAN: f64 = 0.0_f64 / 0.0_f64  # TODO: Proper NaN constant
preset F64_INFINITY: f64 = 1.0_f64 / 0.0_f64  # TODO: Proper infinity constant

# ============================================================================
# Arithmetic Operations
# ============================================================================

routine f64.__add__(other: f64) -> f64 {
    danger! {
        return @intrinsic.add.wrapping<double>(me, other)
    }
}

routine f64.__sub__(other: f64) -> f64 {
    danger! {
        return @intrinsic.sub.wrapping<double>(me, other)
    }
}

routine f64.__mul__(other: f64) -> f64 {
    danger! {
        return @intrinsic.mul.wrapping<double>(me, other)
    }
}

routine f64.__div__(other: f64) -> f64 {
    danger! {
        return @intrinsic.div.wrapping<double>(me, other)
    }
}

routine f64.__rem__(other: f64) -> f64 {
    danger! {
        return @intrinsic.rem.wrapping<double>(me, other)
    }
}

routine f64.__neg__() -> f64 {
    danger! {
        return @intrinsic.sub.wrapping<double>(0.0_f64, me)
    }
}

# ============================================================================
# Comparison Operations (ordered - false if NaN)
# ============================================================================

routine f64.__eq__(other: f64) -> bool {
    danger! {
        return @intrinsic.fcmp.oeq<double>(me, other)
    }
}

routine f64.__ne__(other: f64) -> bool {
    danger! {
        return @intrinsic.fcmp.one<double>(me, other)
    }
}

routine f64.__lt__(other: f64) -> bool {
    danger! {
        return @intrinsic.fcmp.olt<double>(me, other)
    }
}

routine f64.__le__(other: f64) -> bool {
    danger! {
        return @intrinsic.fcmp.ole<double>(me, other)
    }
}

routine f64.__gt__(other: f64) -> bool {
    danger! {
        return @intrinsic.fcmp.ogt<double>(me, other)
    }
}

routine f64.__ge__(other: f64) -> bool {
    danger! {
        return @intrinsic.fcmp.oge<double>(me, other)
    }
}

# ============================================================================
# Math Operations using intrinsics
# ============================================================================

routine f64.sqrt() -> f64 {
    danger! {
        return @intrinsic.sqrt<double>(me)
    }
}

routine f64.abs() -> f64 {
    danger! {
        return @intrinsic.fabs<double>(me)
    }
}

routine f64.floor() -> f64 {
    danger! {
        return @intrinsic.floor<double>(me)
    }
}

routine f64.ceil() -> f64 {
    danger! {
        return @intrinsic.ceil<double>(me)
    }
}

routine f64.round() -> f64 {
    danger! {
        return @intrinsic.round<double>(me)
    }
}

routine f64.trunc() -> f64 {
    danger! {
        return @intrinsic.trunc_float<double>(me)
    }
}

# Trigonometric functions
routine f64.sin() -> f64 {
    danger! {
        return @intrinsic.sin<double>(me)
    }
}

routine f64.cos() -> f64 {
    danger! {
        return @intrinsic.cos<double>(me)
    }
}

# Exponential and logarithmic
routine f64.exp() -> f64 {
    danger! {
        return @intrinsic.exp<double>(me)
    }
}

routine f64.log() -> f64 {
    danger! {
        return @intrinsic.log<double>(me)
    }
}

routine f64.log10() -> f64 {
    danger! {
        return @intrinsic.log10<double>(me)
    }
}

routine f64.pow(exp: f64) -> f64 {
    danger! {
        return @intrinsic.pow<double>(me, exp)
    }
}

routine f64.copysign(sign: f64) -> f64 {
    danger! {
        return @intrinsic.copysign<double>(me, sign)
    }
}

# ============================================================================
# Utility Methods
# ============================================================================

routine f64.min(other: f64) -> f64 {
    return if me <= other then me else other
}

routine f64.max(other: f64) -> f64 {
    return if me >= other then me else other
}

routine f64.clamp(min_val: f64, max_val: f64) -> f64 {
    return me.min(max_val).max(min_val)
}

routine f64.is_positive() -> bool {
    return me > 0.0_f64
}

routine f64.is_negative() -> bool {
    return me < 0.0_f64
}

routine f64.is_zero() -> bool {
    return me == 0.0_f64
}

# TODO: Implement NaN/Infinity checks when we have proper constants
routine f64.is_finite() -> bool {
    # Placeholder - needs proper implementation
    return true
}

routine f64.signum() -> f64 {
    when {
        me > 0.0_f64 => 1.0_f64,
        me < 0.0_f64 => -1.0_f64,
        _ => 0.0_f64
    }
}

# ============================================================================
# Type Conversions
# ============================================================================

routine f64.to_s64() -> s64 {
    danger! {
        return @intrinsic.fptosi<double, i64>(me)
    }
}

routine f64.to_u64() -> u64 {
    danger! {
        return @intrinsic.fptoui<double, i64>(me)
    }
}

routine f64.to_s32() -> s32 {
    danger! {
        return @intrinsic.fptosi<double, i32>(me)
    }
}

routine f64.to_u32() -> u32 {
    danger! {
        return @intrinsic.fptoui<double, i32>(me)
    }
}

routine f64.to_f32() -> f32 {
    danger! {
        return @intrinsic.fptrunc<double, float>(me)
    }
}

# Reinterpret bits as u64 (type punning)
routine f64.to_bits() -> u64 {
    danger! {
        return @intrinsic.bitcast<double, i64>(me)
    }
}

# Create f64 from u64 bits (type punning)
routine f64.from_bits(bits: u64) -> f64 {
    danger! {
        return @intrinsic.bitcast<i64, double>(bits)
    }
}

# ============================================================================
# String Conversion (placeholder)
# ============================================================================

routine f64.to_text() -> Text {
    danger! {
        return @format_f64(me)
    }
}

# Failable constructor from Text - called as f64!(text)
# Compiler automatically generates try_f64.__create__(text) -> Maybe<f64>
routine f64.__create__!(from_text: Text<Letterlikes>) -> f64 {
    danger! {
        return @parse_f64(from_text)
    }
}

# ============================================================================
# Examples
# ============================================================================

# Distance between two points
routine distance_2d(x1: f64, y1: f64, x2: f64, y2: f64) -> f64 {
    let dx = x2 - x1
    let dy = y2 - y1
    return (dx * dx + dy * dy).sqrt()
}

# Pythagorean theorem
routine hypot(a: f64, b: f64) -> f64 {
    return (a * a + b * b).sqrt()
}

# Linear interpolation
routine lerp(a: f64, b: f64, t: f64) -> f64 {
    return a + (b - a) * t
}

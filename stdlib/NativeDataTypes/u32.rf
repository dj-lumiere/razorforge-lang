# RazorForge u32 (unsigned 32-bit integer) native type implementation
# Maps directly to LLVM i32 type for unsigned operations

# Core u32 type definition - maps to LLVM i32
record u32 {
    public value: LlvmNativeI32
}

# Constants for u32 limits (LLVM constant values)
preset U32_MIN: u32 = 0_u32
preset U32_MAX: u32 = 4294967295_u32
preset U32_ZERO: u32 = 0_u32
preset U32_ONE: u32 = 1_u32

# Basic arithmetic operations (LLVM intrinsics: add, sub, mul, udiv, urem)

# Addition with overflow checking
routine u32.add(me: u32, other: u32) -> u32 {
    return llvm_intrinsic("llvm.uadd.with.overflow.i32", me, other)
}

# Subtraction with overflow checking
routine u32.sub(me: u32, other: u32) -> u32 {
    return llvm_intrinsic("llvm.usub.with.overflow.i32", me, other)
}

# Multiplication with overflow checking
routine u32.mul(me: u32, other: u32) -> u32 {
    return llvm_intrinsic("llvm.umul.with.overflow.i32", me, other)
}

# Division (unsigned) - maps to LLVM udiv
routine u32.floordiv(me: u32, other: u32) -> u32 {
    when (other) {
        0 => throw panic("Division by zero"),
        _ => return llvm_intrinsic("udiv", me, other)
    }
}

# Remainder (unsigned) - maps to LLVM urem
routine u32.rem(me: u32, other: u32) -> u32 {
    when (other) {
        0 => throw panic("Division by zero"),
        _ => return llvm_intrinsic("urem", me, other)
    }
}

# Bitwise operations (direct LLVM mapping)
routine u32.and(me: u32, other: u32) -> u32 {
    return llvm_intrinsic("and", me, other)
}

routine u32.or(me: u32, other: u32) -> u32 {
    return llvm_intrinsic("or", me, other)
}

routine u32.xor(me: u32, other: u32) -> u32 {
    return llvm_intrinsic("xor", me, other)
}

routine u32.not(me: u32) -> u32 {
    return llvm_intrinsic("xor", me, 4294967295)
}

# Bit shifting operations
routine u32.shl(me: u32, bits: u32) -> u32 {
    return llvm_intrinsic("shl", me, bits)
}

routine u32.shr(me: u32, bits: u32) -> u32 {
    return llvm_intrinsic("lshr", me, bits)  # Logical right shift for unsigned
}

# Comparison operations (LLVM icmp)
routine u32.eq(me: u32, other: u32) -> bool {
    return llvm_intrinsic("icmp eq", me, other)
}

routine u32.ne(me: u32, other: u32) -> bool {
    return llvm_intrinsic("icmp ne", me, other)
}

routine u32.lt(me: u32, other: u32) -> bool {
    return llvm_intrinsic("icmp ult", me, other)  # Unsigned less than
}

routine u32.le(me: u32, other: u32) -> bool {
    return llvm_intrinsic("icmp ule", me, other)  # Unsigned less equal
}

routine u32.gt(me: u32, other: u32) -> bool {
    return llvm_intrinsic("icmp ugt", me, other)  # Unsigned greater than
}

routine u32.ge(me: u32, other: u32) -> bool {
    return llvm_intrinsic("icmp uge", me, other)  # Unsigned greater equal
}

# Math operations
routine u32.min(me: u32, other: u32) -> u32 {
    return if me <= other then me else other
}

routine u32.max(me: u32, other: u32) -> u32 {
    return if me >= other then me else other
}

# Bit manipulation utilities
routine u32.count_leading_zeros(me: u32) -> u32 {
    return llvm_intrinsic("llvm.ctlz.i32", me, false)
}

routine u32.count_trailing_zeros(me: u32) -> u32 {
    return llvm_intrinsic("llvm.cttz.i32", me, false)
}

routine u32.count_ones(me: u32) -> u32 {
    return llvm_intrinsic("llvm.ctpop.i32", me)
}

# Byte swapping for endianness conversion
routine u32.byte_swap(me: u32) -> u32 {
    return llvm_intrinsic("llvm.bswap.i32", me)
}

# Type conversions to other native types (using constructor syntax)
routine u8(from_u32: u32) -> u8 {
    return llvm_intrinsic("trunc", from_u32)      # Truncate to 8-bit
}

routine u16(from_u32: u32) -> u16 {
    return llvm_intrinsic("trunc", from_u32)      # Truncate to 16-bit
}

routine s8(from_u32: u32) -> s8 {
    return llvm_intrinsic("trunc", from_u32)      # Truncate to signed 8-bit
}

routine s16(from_u32: u32) -> s16 {
    return llvm_intrinsic("trunc", from_u32)      # Truncate to signed 16-bit
}

routine s32(from_u32: u32) -> s32 {
    return llvm_intrinsic("bitcast", from_u32)    # Direct bit reinterpretation
}

routine u64(from_u32: u32) -> u64 {
    return llvm_intrinsic("zext", from_u32)       # Zero-extend to 64-bit
}

routine u128(from_u32: u32) -> u128 {
    return llvm_intrinsic("zext", from_u32)       # Zero-extend to 128-bit
}

routine s64(from_u32: u32) -> s64 {
    return llvm_intrinsic("zext", from_u32)       # Zero-extend to signed 64-bit
}

routine s128(from_u32: u32) -> s128 {
    return llvm_intrinsic("zext", from_u32)       # Zero-extend to signed 128-bit
}

routine f32(from_u32: u32) -> f32 {
    return llvm_intrinsic("uitofp", from_u32)     # Unsigned int to float
}

routine f64(from_u32: u32) -> f64 {
    return llvm_intrinsic("uitofp", from_u32)     # Unsigned int to double
}

routine f128(from_u32: u32) -> f128 {
    return llvm_intrinsic("uitofp", from_u32)     # Unsigned int to quad
}

routine bool(from_u32: u32) -> bool {
    return from_u32 != 0
}

# Parsing constructors using compiler intrinsics

# Fallible constructor - crashes on invalid input
routine u32!(from_text: Text) -> u32 {
    danger! {
        return @parse_u32(from_text)
    }
}

# Safe constructor - returns Maybe<u32>
routine u32?(from_text: Text) -> Maybe<u32> {
    danger! {
        return @try_parse_u32(from_text)
    }
}

routine Text(from_u32: u32) -> Text {
    # Convert u32 to Text representation
    return ""  # Placeholder
}

# Utility functions for bit operations
routine u32.is_power_of_two(me: u32) -> bool {
    return me != 0 and (me & (me - 1)) == 0
}

routine u32.next_power_of_two(me: u32) -> u32 {
    when (me) {
        0 => return 1,
        1 => return 1,
        _ => {
            var power: u32 = 1
            while power < me {
                power = power << 1
            }
            return power
        }
    }
}

# Saturating arithmetic (clamps to min/max instead of wrapping)
routine u32.saturating_add(me: u32, other: u32) -> u32 {
    let result = me + other
    return if result < me then U32_MAX else result  # Overflow check
}

routine u32.saturating_sub(me: u32, other: u32) -> u32 {
    return if me >= other then me - other else U32_ZERO
}

routine u32.saturating_mul(me: u32, other: u32) -> u32 {
    let result = me * other
    return if other != 0 and result / other != me then U32_MAX else result
}

/*
LLVM IR Mapping:
- RazorForge u32 -> LLVM i32 -> C uint32_t
- Range: 0 to 4294967295
- Unsigned operations use ult, uge, udiv, urem, lshr
- Common for array indices, memory sizes, and hash values
- Zero-extension used for conversions to larger types
- Byte swapping available for endianness conversion
*/

# RazorForge u32 (unsigned 32-bit integer) native type implementation
# Maps directly to LLVM i32 type using compiler intrinsics
namespace core
# Core u32 type definition - maps to LLVM i32
record u32 {
    public value: LlvmNativeI32
}

# Constants for u32 limits
preset U32_MIN: u32 = 0_u32
preset U32_MAX: u32 = 4294967295_u32
preset U32_ZERO: u32 = 0_u32
preset U32_ONE: u32 = 1_u32

# ============================================================================
# Checked Constructors (crash on overflow)
# ============================================================================

# Failable constructor from Text - called as u32!(text)
# Compiler automatically generates try_u32.__create__(text) -> Maybe<u32>
routine u32.__create__!(from_text: Text<Letterlikes>) -> u32 {
    danger! {
        return @parse_u32(from_text)
    }
}

# From u8 - always fits, no check needed
routine u32.__create__!(from: u8) -> u32 {
    danger! {
        return @intrinsic.zext<i8, i32>(from)
    }
}

# From u16 - always fits, no check needed
routine u32.__create__!(from: u16) -> u32 {
    danger! {
        return @intrinsic.zext<i16, i32>(from)
    }
}

# From s8 - crashes if value is negative
routine u32.__create__!(from: s8) -> u32 {
    if from < 0_s8 {
        throw IntegerOverflowError(f"Cannot convert {from} to u32: value out of range [{U32_MIN}, {U32_MAX}]")
    }
    danger! {
        return @intrinsic.sext<i8, i32>(from)
    }
}

# From s16 - crashes if value is negative
routine u32.__create__!(from: s16) -> u32 {
    if from < 0_s16 {
        throw IntegerOverflowError(f"Cannot convert {from} to u32: value out of range [{U32_MIN}, {U32_MAX}]")
    }
    danger! {
        return @intrinsic.sext<i16, i32>(from)
    }
}

# From s32 - crashes if value is negative
routine u32.__create__!(from: s32) -> u32 {
    if from < 0_s32 {
        throw IntegerOverflowError(f"Cannot convert {from} to u32: value out of range [{U32_MIN}, {U32_MAX}]")
    }
    danger! {
        return @intrinsic.bitcast<i32, i32>(from)
    }
}

# From s64 - crashes if value out of u32 range
routine u32.__create__!(from: s64) -> u32 {
    if not (0_s64 <= from <= 4294967295_s64) {
        throw IntegerOverflowError(f"Cannot convert {from} to u32: value out of range [{U32_MIN}, {U32_MAX}]")
    }
    danger! {
        return @intrinsic.trunc<i64, i32>(from)
    }
}

# From s128 - crashes if value out of u32 range
routine u32.__create__!(from: s128) -> u32 {
    if not (0_s128 <= from <= 4294967295_s128) {
        throw IntegerOverflowError(f"Cannot convert {from} to u32: value out of range [{U32_MIN}, {U32_MAX}]")
    }
    danger! {
        return @intrinsic.trunc<i128, i32>(from)
    }
}

# From u64 - crashes if value > U32_MAX
routine u32.__create__!(from: u64) -> u32 {
    if from > 4294967295_u64 {
        throw IntegerOverflowError(f"Cannot convert {from} to u32: value out of range [{U32_MIN}, {U32_MAX}]")
    }
    danger! {
        return @intrinsic.trunc<i64, i32>(from)
    }
}

# From u128 - crashes if value > U32_MAX
routine u32.__create__!(from: u128) -> u32 {
    if from > 4294967295_u128 {
        throw IntegerOverflowError(f"Cannot convert {from} to u32: value out of range [{U32_MIN}, {U32_MAX}]")
    }
    danger! {
        return @intrinsic.trunc<i128, i32>(from)
    }
}

# From floating point - truncates
routine u32.__create__(from: f32) -> u32 {
    danger! {
        return @intrinsic.fptoui<float, i32>(from)
    }
}

routine u32.__create__(from: f64) -> u32 {
    danger! {
        return @intrinsic.fptoui<double, i32>(from)
    }
}

# From decimal - truncates
routine u32.__create__(from: d32) -> u32 {
    return from.to_u32()
}

routine u32.__create__(from: d64) -> u32 {
    return from.to_u32()
}

routine u32.__create__(from: d128) -> u32 {
    return from.to_u32()
}

# ============================================================================
# Arithmetic Operations (trapping on overflow by default)
# ============================================================================

@crash_only
routine u32.__add__!(other: u32) -> u32 {
    danger! {
        return @intrinsic.add<i32>(me, other)
    }
}

@crash_only
routine u32.__sub__!(other: u32) -> u32 {
    danger! {
        return @intrinsic.sub<i32>(me, other)
    }
}

@crash_only
routine u32.__mul__!(other: u32) -> u32 {
    danger! {
        return @intrinsic.mul<i32>(me, other)
    }
}

@crash_only
routine u32.__floordiv__!(other: u32) -> u32 {
    if other == 0 {
        throw DivisionByZeroError()
    }
    danger! {
        return @intrinsic.udiv<i32>(me, other)
    }
}

@crash_only
routine u32.__mod__!(other: u32) -> u32 {
    danger! {
        return @intrinsic.urem<i32>(me, other)
    }
}

# ============================================================================
# Wrapping Arithmetic (+%, -%, *%)
# ============================================================================

routine u32.__add_wrap__(other: u32) -> u32 {
    danger! {
        return @intrinsic.add.wrapping<i32>(me, other)
    }
}

routine u32.__sub_wrap__(other: u32) -> u32 {
    danger! {
        return @intrinsic.sub.wrapping<i32>(me, other)
    }
}

routine u32.__mul_wrap__(other: u32) -> u32 {
    danger! {
        return @intrinsic.mul.wrapping<i32>(me, other)
    }
}

# ============================================================================
# Saturating Arithmetic (+^, -^, *^)
# ============================================================================

routine u32.__add_sat__(other: u32) -> u32 {
    danger! {
        return @intrinsic.add.saturating<i32>(me, other)
    }
}

routine u32.__sub_sat__(other: u32) -> u32 {
    danger! {
        return @intrinsic.sub.saturating<i32>(me, other)
    }
}

routine u32.__mul_sat__(other: u32) -> u32 {
    danger! {
        return @intrinsic.mul.saturating<i32>(me, other)
    }
}

# ============================================================================
# Checked Arithmetic (+?, -?, *?) - returns Maybe<T>
# ============================================================================

routine u32.__add_checked__(other: u32) -> Maybe<u32> {
    danger! {
        let (result, overflow) = @intrinsic.add.overflow<i32>(me, other)
        return if overflow then None else result
    }
}

routine u32.__sub_checked__(other: u32) -> Maybe<u32> {
    danger! {
        let (result, overflow) = @intrinsic.sub.overflow<i32>(me, other)
        return if overflow then None else result
    }
}

routine u32.__mul_checked__(other: u32) -> Maybe<u32> {
    danger! {
        let (result, overflow) = @intrinsic.mul.overflow<i32>(me, other)
        return if overflow then None else result
    }
}

# ============================================================================
# Power Operations (**)
# ============================================================================

# Power operator (**) - can overflow
@crash_only
routine u32.__pow__!(exp: u32) -> u32 {
    danger! {
        var result: u32 = 1
        var base: u32 = me
        var e: u32 = exp
        if me == 0 and exp == 0 {
            throw IndeterminateResultError()
        }
        while e > 0 {
            if (e & 1) == 1 {
                result = @intrinsic.mul<i32>(result, base)
            }
            base = @intrinsic.mul<i32>(base, base)
            e = e >> 1
        }
        return result
    }
}

# Wrapping power (**%)
@crash_only
routine u32.__pow_wrap__!(exp: u32) -> u32 {
    danger! {
        var result: u32 = 1
        var base: u32 = me
        var e: u32 = exp
        if me == 0 and exp == 0 {
            throw IndeterminateResultError()
        }
        while e > 0 {
            if (e & 1) == 1 {
                result = @intrinsic.mul.wrapping<i32>(result, base)
            }
            base = @intrinsic.mul.wrapping<i32>(base, base)
            e = e >> 1
        }
        return result
    }
}

# Saturating power (**^)
@crash_only
routine u32.__pow_sat__!(exp: u32) -> u32 {
    danger! {
        var result: u32 = 1
        var base: u32 = me
        var e: u32 = exp
        if me == 0 and exp == 0 {
            throw IndeterminateResultError()
        }
        while e > 0 {
            if (e & 1) == 1 {
                result = @intrinsic.mul.saturating<i32>(result, base)
            }
            base = @intrinsic.mul.saturating<i32>(base, base)
            e = e >> 1
        }
        return result
    }
}

# Checked power (**?) - returns Maybe<u32>
routine u32.__pow_checked__(exp: u32) -> Maybe<u32> {
    danger! {
        var result: u32 = 1
        var base: u32 = me
        var e: u32 = exp
        if me == 0 {
            return None
        }
        while e > 0 {
            if (e & 1) == 1 {
                let (new_result, overflow) = @intrinsic.mul.overflow<i32>(result, base)
                if overflow {
                    return None
                }
                result = new_result
            }
            let (new_base, overflow) = @intrinsic.mul.overflow<i32>(base, base)
            if overflow and e > 1 {
                return None
            }
            base = new_base
            e = e >> 1
        }
        return result
    }
}

# ============================================================================
# Bitwise Operations
# ============================================================================

routine u32.__and__(other: u32) -> u32 {
    danger! {
        return @intrinsic.and<i32>(me, other)
    }
}

routine u32.__or__(other: u32) -> u32 {
    danger! {
        return @intrinsic.or<i32>(me, other)
    }
}

routine u32.__xor__(other: u32) -> u32 {
    danger! {
        return @intrinsic.xor<i32>(me, other)
    }
}

routine u32.__not__() -> u32 {
    danger! {
        return @intrinsic.not<i32>(me)
    }
}

# ============================================================================
# Shift Operations (<<, <<?>, >>, <<<, >>>)
# For unsigned types, arithmetic and logical shifts behave identically
# ============================================================================

# Arithmetic left shift (<<) - sign preserving (for unsigned, same as logical)
routine u32.__ashl__(bits: u32) -> u32 {
    danger! {
        return @intrinsic.shl<i32>(me, bits)
    }
}

# Checked arithmetic left shift (<<?) - returns Maybe<u32>
routine u32.__ashl_checked__(bits: u32) -> Maybe<u32> {
    danger! {
        if bits >= 32 {
            return None
        }
        let result = @intrinsic.shl<i32>(me, bits)
        # Check if we can recover the original value
        let recovered = @intrinsic.lshr<i32>(result, bits)
        if recovered != me {
            return None
        }
        return result
    }
}

# Arithmetic right shift (>>) - for unsigned, same as logical
routine u32.__ashr__(bits: u32) -> u32 {
    danger! {
        return @intrinsic.lshr<i32>(me, bits)
    }
}

# Logical left shift (<<<) - same as <<
routine u32.__lshl__(bits: u32) -> u32 {
    danger! {
        return @intrinsic.shl<i32>(me, bits)
    }
}

# Logical right shift (>>>) - fills with zeros
routine u32.__lshr__(bits: u32) -> u32 {
    danger! {
        return @intrinsic.lshr<i32>(me, bits)
    }
}

# ============================================================================
# Comparison Operations
# ============================================================================

routine u32.__eq__(other: u32) -> bool {
    danger! {
        return @intrinsic.icmp.eq<i32>(me, other)
    }
}

routine u32.__ne__(other: u32) -> bool {
    danger! {
        return @intrinsic.icmp.ne<i32>(me, other)
    }
}

routine u32.__lt__(other: u32) -> bool {
    danger! {
        return @intrinsic.icmp.ult<i32>(me, other)
    }
}

routine u32.__le__(other: u32) -> bool {
    danger! {
        return @intrinsic.icmp.ule<i32>(me, other)
    }
}

routine u32.__gt__(other: u32) -> bool {
    danger! {
        return @intrinsic.icmp.ugt<i32>(me, other)
    }
}

routine u32.__ge__(other: u32) -> bool {
    danger! {
        return @intrinsic.icmp.uge<i32>(me, other)
    }
}

# ============================================================================
# Math Operations
# ============================================================================

routine u32.min(other: u32) -> u32 {
    return if me <= other then me else other
}

routine u32.max(other: u32) -> u32 {
    return if me >= other then me else other
}

routine u32.clamp(min_val: u32, max_val: u32) -> u32 {
    return me.min(max_val).max(min_val)
}

# ============================================================================
# Bit Manipulation
# ============================================================================

routine u32.count_ones() -> u32 {
    danger! {
        return @intrinsic.ctpop<i32>(me)
    }
}

routine u32.count_zeros() -> u32 {
    return 32_u32 - me.count_ones()
}

routine u32.leading_zeros() -> u32 {
    danger! {
        return @intrinsic.ctlz<i32>(me)
    }
}

routine u32.trailing_zeros() -> u32 {
    danger! {
        return @intrinsic.cttz<i32>(me)
    }
}

routine u32.leading_ones() -> u32 {
    return me.__not__().leading_zeros()
}

routine u32.trailing_ones() -> u32 {
    return me.__not__().trailing_zeros()
}

routine u32.reverse_bits() -> u32 {
    danger! {
        return @intrinsic.bitreverse<i32>(me)
    }
}

routine u32.swap_bytes() -> u32 {
    danger! {
        return @intrinsic.bswap<i32>(me)
    }
}

routine u32.is_power_of_two() -> bool {
    return me != 0_u32 and (me & (me - 1_u32)) == 0_u32
}

# ============================================================================
# Type Conversions (constructor syntax)
# ============================================================================

# Bitcast to signed
routine s32(from: u32) -> s32 {
    danger! {
        return @intrinsic.bitcast<i32, i32>(from)
    }
}

# Zero-extend to larger types
routine u64(from: u32) -> u64 {
    danger! {
        return @intrinsic.zext<i32, i64>(from)
    }
}

routine u128(from: u32) -> u128 {
    danger! {
        return @intrinsic.zext<i32, i128>(from)
    }
}

# Truncate to smaller types
routine u16(from: u32) -> u16 {
    danger! {
        return @intrinsic.trunc<i32, i16>(from)
    }
}

routine u8(from: u32) -> u8 {
    danger! {
        return @intrinsic.trunc<i32, i8>(from)
    }
}

# Convert to floating point
routine f32(from: u32) -> f32 {
    danger! {
        return @intrinsic.uitofp<i32, float>(from)
    }
}

routine f64(from: u32) -> f64 {
    danger! {
        return @intrinsic.uitofp<i32, double>(from)
    }
}

# Convert to boolean
routine bool(from: u32) -> bool {
    danger! {
        return @intrinsic.icmp.ne<i32>(from, 0_u32)
    }
}

# ============================================================================
# Utility Methods
# ============================================================================

routine u32.is_zero() -> bool {
    return me == 0_u32
}

routine u32.is_even() -> bool {
    danger! {
        let result = @intrinsic.and<i32>(me, 1_u32)
        return @intrinsic.icmp.eq<i32>(result, 0_u32)
    }
}

routine u32.is_odd() -> bool {
    return not me.is_even()
}

# ============================================================================
# String Conversion
# ============================================================================

routine u32.to_text() -> Text {
    danger! {
        return @format_u32(me)
    }
}

# RazorForge d128 (decimal128 floating point) native type implementation
# IEEE 754-2008 decimal floating point with 34 significant digits
# Uses Intel DFP library via external C functions

import FFI/ctypes

# Core d128 type definition - stored as 128-bit value in BID encoding
# Uses two u64 fields (low and high) to represent the 128-bit value
record d128 {
    private low: u64
    private high: u64
}

# Constants for d128
preset D128_ZERO: d128 = 0.0_d128
preset D128_ONE: d128 = 1.0_d128

# ============================================================================
# External C Functions (from decimal_functions.c)
# Note: d128 is passed/returned as a struct {u64 low, u64 high}
# ============================================================================

external routine d128_add(a_low: u64, a_high: u64, b_low: u64, b_high: u64) -> d128
external routine d128_sub(a_low: u64, a_high: u64, b_low: u64, b_high: u64) -> d128
external routine d128_mul(a_low: u64, a_high: u64, b_low: u64, b_high: u64) -> d128
external routine d128_div(a_low: u64, a_high: u64, b_low: u64, b_high: u64) -> d128
external routine d128_cmp(a_low: u64, a_high: u64, b_low: u64, b_high: u64) -> s32
external routine d128_from_string(str: cstr) -> d128
external routine d128_to_string(low: u64, high: u64) -> cstr
external routine d128_from_i32(val: s32) -> d128
external routine d128_from_u32(val: u32) -> d128
external routine d128_from_i64(val: s64) -> d128
external routine d128_from_u64(val: u64) -> d128
external routine rf_d128_sqrt(low: u64, high: u64) -> d128
external routine rf_d128_abs(low: u64, high: u64) -> d128
external routine rf_d128_ceil(low: u64, high: u64) -> d128
external routine rf_d128_floor(low: u64, high: u64) -> d128
external routine rf_d128_round(low: u64, high: u64) -> d128
external routine rf_d128_trunc(low: u64, high: u64) -> d128
external routine rf_d128_to_f32(low: u64, high: u64) -> f32
external routine rf_d128_to_f64(low: u64, high: u64) -> f64
external routine rf_d128_to_d32(low: u64, high: u64) -> u32
external routine rf_d128_to_d64(low: u64, high: u64) -> u64
external routine rf_f32_to_d128(x: f32) -> d128
external routine rf_f64_to_d128(x: f64) -> d128
external routine rf_d32_to_d128(x: u32) -> d128
external routine rf_d64_to_d128(x: u64) -> d128
external routine d128_to_i32(low: u64, high: u64) -> s32
external routine d128_to_i64(low: u64, high: u64) -> s64

# ============================================================================
# Constructors
# ============================================================================

routine d128.__create__!(from_text: Text<LetterType>) -> d128 {
    danger! {
        let cstr_val = from_text.to_cstr()
        return d128_from_string(cstr_val)
    }
}

routine d128.__create__(from: f32) -> d128 {
    danger! {
        return rf_f32_to_d128(from)
    }
}

routine d128.__create__(from: f64) -> d128 {
    danger! {
        return rf_f64_to_d128(from)
    }
}

routine d128.__create__(from: d32) -> d128 {
    danger! {
        let bits = @intrinsic.bitcast<d32, u32>(from)
        return rf_d32_to_d128(bits)
    }
}

routine d128.__create__(from: d64) -> d128 {
    danger! {
        let bits = @intrinsic.bitcast<d64, u64>(from)
        return rf_d64_to_d128(bits)
    }
}

routine d128.__create__(from: s8) -> d128 {
    danger! {
        return d128_from_i32(from.to_s32())
    }
}

routine d128.__create__(from: u8) -> d128 {
    danger! {
        return d128_from_u32(from.to_u32())
    }
}

routine d128.__create__(from: s16) -> d128 {
    danger! {
        return d128_from_i32(from.to_s32())
    }
}

routine d128.__create__(from: u16) -> d128 {
    danger! {
        return d128_from_u32(from.to_u32())
    }
}

routine d128.__create__(from: s32) -> d128 {
    danger! {
        return d128_from_i32(from)
    }
}

routine d128.__create__(from: u32) -> d128 {
    danger! {
        return d128_from_u32(from)
    }
}

routine d128.__create__(from: s64) -> d128 {
    danger! {
        return d128_from_i64(from)
    }
}

routine d128.__create__(from: u64) -> d128 {
    danger! {
        return d128_from_u64(from)
    }
}

# ============================================================================
# Arithmetic Operations
# ============================================================================

routine d128.__add__(me: d128, other: d128) -> d128 {
    danger! {
        return d128_add(me.low, me.high, other.low, other.high)
    }
}

routine d128.__sub__(me: d128, other: d128) -> d128 {
    danger! {
        return d128_sub(me.low, me.high, other.low, other.high)
    }
}

routine d128.__mul__(me: d128, other: d128) -> d128 {
    danger! {
        return d128_mul(me.low, me.high, other.low, other.high)
    }
}

routine d128.__truediv__(me: d128, other: d128) -> d128 {
    danger! {
        return d128_div(me.low, me.high, other.low, other.high)
    }
}

routine d128.__neg__(me: d128) -> d128 {
    return D128_ZERO - me
}

# ============================================================================
# Comparison Operations
# ============================================================================

routine d128.__lt__(me: d128, other: d128) -> bool {
    danger! {
        return d128_cmp(me.low, me.high, other.low, other.high) < 0
    }
}

routine d128.__le__(me: d128, other: d128) -> bool {
    danger! {
        return d128_cmp(me.low, me.high, other.low, other.high) <= 0
    }
}

routine d128.__gt__(me: d128, other: d128) -> bool {
    danger! {
        return d128_cmp(me.low, me.high, other.low, other.high) > 0
    }
}

routine d128.__ge__(me: d128, other: d128) -> bool {
    danger! {
        return d128_cmp(me.low, me.high, other.low, other.high) >= 0
    }
}

routine d128.__eq__(me: d128, other: d128) -> bool {
    danger! {
        return d128_cmp(me.low, me.high, other.low, other.high) == 0
    }
}

routine d128.__ne__(me: d128, other: d128) -> bool {
    danger! {
        return d128_cmp(me.low, me.high, other.low, other.high) != 0
    }
}

# ============================================================================
# Math Operations
# ============================================================================

routine d128.sqrt(me: d128) -> d128 {
    danger! {
        return rf_d128_sqrt(me.low, me.high)
    }
}

routine d128.abs(me: d128) -> d128 {
    danger! {
        return rf_d128_abs(me.low, me.high)
    }
}

routine d128.ceil(me: d128) -> d128 {
    danger! {
        return rf_d128_ceil(me.low, me.high)
    }
}

routine d128.floor(me: d128) -> d128 {
    danger! {
        return rf_d128_floor(me.low, me.high)
    }
}

routine d128.round(me: d128) -> d128 {
    danger! {
        return rf_d128_round(me.low, me.high)
    }
}

routine d128.trunc(me: d128) -> d128 {
    danger! {
        return rf_d128_trunc(me.low, me.high)
    }
}

# ============================================================================
# Utility Methods
# ============================================================================

routine d128.min(me: d128, other: d128) -> d128 {
    return if me <= other { me } else { other }
}

routine d128.max(me: d128, other: d128) -> d128 {
    return if me >= other { me } else { other }
}

routine d128.clamp(me: d128, min_val: d128, max_val: d128) -> d128 {
    return me.min(max_val).max(min_val)
}

routine d128.is_positive(me: d128) -> bool {
    return me > D128_ZERO
}

routine d128.is_negative(me: d128) -> bool {
    return me < D128_ZERO
}

routine d128.is_zero(me: d128) -> bool {
    return me == D128_ZERO
}

routine d128.signum(me: d128) -> d128 {
    when {
        me > D128_ZERO => D128_ONE,
        me < D128_ZERO => -D128_ONE,
        _ => D128_ZERO
    }
}

# ============================================================================
# Type Conversions
# ============================================================================

routine d128.to_f32(me: d128) -> f32 {
    danger! {
        return rf_d128_to_f32(me.low, me.high)
    }
}

routine d128.to_f64(me: d128) -> f64 {
    danger! {
        return rf_d128_to_f64(me.low, me.high)
    }
}

routine d128.to_d32(me: d128) -> d32 {
    danger! {
        let result = rf_d128_to_d32(me.low, me.high)
        return @intrinsic.bitcast<u32, d32>(result)
    }
}

routine d128.to_d64(me: d128) -> d64 {
    danger! {
        let result = rf_d128_to_d64(me.low, me.high)
        return @intrinsic.bitcast<u64, d64>(result)
    }
}

routine d128.to_s8(me: d128) -> s8 {
    return me.to_s32().to_s8()
}

routine d128.to_u8(me: d128) -> u8 {
    return me.to_u32().to_u8()
}

routine d128.to_s16(me: d128) -> s16 {
    return me.to_s32().to_s16()
}

routine d128.to_u16(me: d128) -> u16 {
    return me.to_u32().to_u16()
}

routine d128.to_s32(me: d128) -> s32 {
    danger! {
        return d128_to_i32(me.low, me.high)
    }
}

routine d128.to_u32(me: d128) -> u32 {
    return me.to_s64().to_u32()
}

routine d128.to_s64(me: d128) -> s64 {
    danger! {
        return d128_to_i64(me.low, me.high)
    }
}

routine d128.to_u64(me: d128) -> u64 {
    return me.to_s64().to_u64()
}

# Get low 64 bits
routine d128.low_bits(me: d128) -> u64 {
    return me.low
}

# Get high 64 bits
routine d128.high_bits(me: d128) -> u64 {
    return me.high
}

# Create d128 from low and high u64 bits
routine d128.from_bits(low: u64, high: u64) -> d128 {
    return d128(low: low, high: high)
}

# ============================================================================
# String Conversion
# ============================================================================

routine d128.to_text(me: d128) -> Text {
    danger! {
        let cstr_result = d128_to_string(me.low, me.high)
        return Text.from_cstr(cstr_result)
    }
}
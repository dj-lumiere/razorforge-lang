# RazorForge saddr (system-sized signed integer) native type implementation
# Maps to LLVM pointer-sized integer - s32 on 32-bit, s64 on 64-bit platforms
#
# SAFETY: saddr does NOT support base arithmetic operators (+, -, *, //, %, **, <<)
# to prevent silent overflow bugs in pointer/offset calculations.
# You must use explicit wrapping (+%, -%, etc.) or checked (+?, -?, etc.) variants.

# TODO: Add "namespace core" once tuple destructuring is implemented in codegen
# Currently blocked by functions using let (result, overflow) = @intrinsic.add.overflow<iptr>(...)
namespace core
# Core saddr type definition - maps to LLVM iptr/isize
record saddr {
    public value: @intrinsic.iptr
}

# ============================================================================
# Constructors
# Since they are black hole types, all constructors are automatically wrapped.
# ============================================================================

routine saddr.__create__!(from_text: Text<Letter>) -> saddr {
    danger! {
        return @native.rf_parse_saddr(from_text)
    }
}

# From s8 - sign extend
routine saddr.__create__(from: s8) -> saddr {
    danger! {
        return @intrinsic.sext<i8, iptr>(from)
    }
}

# From s16 - sign extend
routine saddr.__create__(from: s16) -> saddr {
    danger! {
        return @intrinsic.sext<i16, iptr>(from)
    }
}

# From s32 - sign extend or bitcast depending on platform
routine saddr.__create__(from: s32) -> saddr {
    danger! {
        return @intrinsic.sext<i32, iptr>(from)
    }
}

# From s64 - truncate or bitcast depending on platform (wraps on 32-bit)
routine saddr.__create__(from: s64) -> saddr {
    danger! {
        return @intrinsic.trunc<i64, iptr>(from)
    }
}

# From s128 - truncate (wraps)
routine saddr.__create__(from: s128) -> saddr {
    danger! {
        return @intrinsic.trunc<i128, iptr>(from)
    }
}

# From u8 - zero extend
routine saddr.__create__(from: u8) -> saddr {
    danger! {
        return @intrinsic.zext<i8, iptr>(from)
    }
}

# From u16 - zero extend
routine saddr.__create__(from: u16) -> saddr {
    danger! {
        return @intrinsic.zext<i16, iptr>(from)
    }
}

# From u32 - zero extend or bitcast depending on platform
routine saddr.__create__(from: u32) -> saddr {
    danger! {
        return @intrinsic.zext<i32, iptr>(from)
    }
}

# From u64 - truncate or bitcast depending on platform (wraps)
routine saddr.__create__(from: u64) -> saddr {
    danger! {
        return @intrinsic.trunc<i64, iptr>(from)
    }
}

# From u128 - truncate (wraps)
routine saddr.__create__(from: u128) -> saddr {
    danger! {
        return @intrinsic.trunc<i128, iptr>(from)
    }
}

# From floating point - truncates
routine saddr.__create__(from: f16) -> saddr {
    return from.f32().saddr()
}

routine saddr.__create__(from: f32) -> saddr {
    danger! {
        return @intrinsic.fptosi<float, iptr>(from)
    }
}

routine saddr.__create__(from: f64) -> saddr {
    danger! {
        return @intrinsic.fptosi<double, iptr>(from)
    }
}

routine saddr.__create__(from: f128) -> saddr {
    return from.f64().saddr()
}

# From decimal - truncates fractional part (wraps on overflow)
routine saddr.__create__(from: d32) -> saddr {
    danger! {
        let bit_width = @intrinsic.bitwidth<iptr>()
        if bit_width == 32 {
            return from.s32().saddr()
        } else {
            return from.s64().saddr()
        }
    }
}

routine saddr.__create__(from: d64) -> saddr {
    danger! {
        let bit_width = @intrinsic.bitwidth<iptr>()
        if bit_width == 32 {
            return from.s32().saddr()
        } else {
            return from.s64().saddr()
        }
    }
}

routine saddr.__create__(from: d128) -> saddr {
    danger! {
        let bit_width = @intrinsic.bitwidth<iptr>()
        if bit_width == 32 {
            return from.s32().saddr()
        } else {
            return from.s64().saddr()
        }
    }
}

routine saddr.__create__(from: saddr) -> saddr {
    return from
}

routine saddr.__create__(from: uaddr) -> saddr {
    return from.s64().uaddr()
}

# ============================================================================
# Wrapping Arithmetic Operations (+%, -%, *%, //%, %%, **%)
# These explicitly wrap on overflow - use when wrapping is intentional
# ============================================================================

routine saddr.__add_wrap__(you: saddr) -> saddr {
    danger! {
        return @intrinsic.add.wrapping<iptr>(me, you)
    }
}

routine saddr.__sub_wrap__(you: saddr) -> saddr {
    danger! {
        return @intrinsic.sub.wrapping<iptr>(me, you)
    }
}

routine saddr.__mul_wrap__(you: saddr) -> saddr {
    danger! {
        return @intrinsic.mul.wrapping<iptr>(me, you)
    }
}

routine saddr.__floordiv_wrap__(you: saddr) -> saddr {
    danger! {
        return @intrinsic.sdiv<iptr>(me, you)
    }
}

routine saddr.__mod_wrap__(you: saddr) -> saddr {
    danger! {
        return @intrinsic.srem<iptr>(me, you)
    }
}

# ============================================================================
# Checked Arithmetic Operations (+?, -?, *?, //?, %?, **?, <<?)
# These return Maybe<saddr> - None on overflow
# ============================================================================

routine saddr.__add_checked__(you: saddr) -> Maybe<saddr> {
    danger! {
        let (result, overflow) = @intrinsic.add.overflow<iptr>(me, you)
        return if overflow then None else result
    }
}

routine saddr.__sub_checked__(you: saddr) -> Maybe<saddr> {
    danger! {
        let (result, overflow) = @intrinsic.sub.overflow<iptr>(me, you)
        return if overflow then None else result
    }
}

routine saddr.__mul_checked__(you: saddr) -> Maybe<saddr> {
    danger! {
        let (result, overflow) = @intrinsic.mul.overflow<iptr>(me, you)
        return if overflow then None else result
    }
}

routine saddr.__floordiv_checked__(you: saddr) -> Maybe<saddr> {
    # Division can overflow for MIN_VALUE / -1, and divide by zero
    if you == 0 {
        return None
    }
    danger! {
        let min_val = @intrinsic.min_value<iptr>()
        if me == min_val and you == -1 {
            return None  # Would overflow
        }
        return @intrinsic.sdiv<iptr>(me, you)
    }
}

routine saddr.__mod_checked__(you: saddr) -> Maybe<saddr> {
    if you == 0 {
        return None
    }
    danger! {
        return @intrinsic.srem<iptr>(me, you)
    }
}

routine saddr.__ashl_checked__(bits: u32) -> Maybe<saddr> {
    danger! {
        # Check if shift would overflow
        let bit_width = @intrinsic.bitwidth<iptr>()
        if bits >= bit_width {
            return None
        }
        let result = @intrinsic.shl<iptr>(me, bits)
        # Check if we can recover the original value by shifting back
        let recovered = @intrinsic.ashr<iptr>(result, bits)
        if recovered != me {
            return None
        }
        return result
    }
}

# ============================================================================
# Shift Operations (>>, <<<, >>>)
# saddr does NOT have << (sign-preserving left shift) - use <<? or <<< instead
# ============================================================================

routine saddr.__ashr__(bits: u32) -> saddr {
    danger! {
        # Arithmetic right shift - preserves sign
        return @intrinsic.ashr<iptr>(me, bits)
    }
}

routine saddr.__lshl__(bits: u32) -> saddr {
    danger! {
        return @intrinsic.shl<iptr>(me, bits)
    }
}

routine saddr.__lshr__(bits: u32) -> saddr {
    danger! {
        # Logical right shift - fills with zeros
        return @intrinsic.lshr<iptr>(me, bits)
    }
}

# ============================================================================
# Bitwise Operations (&, |, ^, ~)
# These cannot overflow
# ============================================================================

routine saddr.__and__(you: saddr) -> saddr {
    danger! {
        return @intrinsic.and<iptr>(me, you)
    }
}

routine saddr.__or__(you: saddr) -> saddr {
    danger! {
        return @intrinsic.or<iptr>(me, you)
    }
}

routine saddr.__xor__(you: saddr) -> saddr {
    danger! {
        return @intrinsic.xor<iptr>(me, you)
    }
}

routine saddr.__not__() -> saddr {
    danger! {
        return @intrinsic.not<iptr>(me)
    }
}

# ============================================================================
# Unary Operations
# ============================================================================

routine saddr.__neg__() -> saddr {
    danger! {
        # Note: negation can overflow for MIN_VALUE, but we allow it (wraps)
        return @intrinsic.neg<iptr>(me)
    }
}

# ============================================================================
# Comparison Operations (non-overloadable, but provided for completeness)
# ============================================================================

routine saddr.__lt__(you: saddr) -> bool {
    danger! {
        return @intrinsic.icmp.slt<iptr>(me, you)
    }
}

routine saddr.__le__(you: saddr) -> bool {
    danger! {
        return @intrinsic.icmp.sle<iptr>(me, you)
    }
}

routine saddr.__gt__(you: saddr) -> bool {
    danger! {
        return @intrinsic.icmp.sgt<iptr>(me, you)
    }
}

routine saddr.__ge__(you: saddr) -> bool {
    danger! {
        return @intrinsic.icmp.sge<iptr>(me, you)
    }
}

# ============================================================================
# Utility Methods
# ============================================================================

routine saddr.abs() -> saddr {
    return if me >= 0 then me else (0 -% me)
}

routine saddr.min(you: saddr) -> saddr {
    return if me <= you then me else you
}

routine saddr.max(you: saddr) -> saddr {
    return if me >= you then me else you
}

# ============================================================================
# String Conversion
# ============================================================================

routine saddr.to_text() -> Text {
    danger! {
        return @native.rf_format_saddr(me)
    }
}

# RazorForge u8 (unsigned 8-bit integer) native type implementation
# Maps directly to LLVM i8 type for unsigned operations

# Core u8 type definition - maps to LLVM i8
struct u8 {
    public value: LlvmNativeI8
}

# Constants for u8 limits (LLVM constant values)
preset U8_MIN: u8 = 0_u8
preset U8_MAX: u8 = 255_u8
preset U8_ZERO: u8 = 0_u8
preset U8_ONE: u8 = 1_u8

# Basic arithmetic operations (LLVM intrinsics: add, sub, mul, udiv, urem)

# Addition with overflow checking
recipe u8.add(my: u8, other: u8) -> u8 {
    return llvm_intrinsic("llvm.uadd.with.overflow.i8", my, other)
}

# Subtraction with overflow checking
recipe u8.sub(my: u8, other: u8) -> u8 {
    return llvm_intrinsic("llvm.usub.with.overflow.i8", my, other)
}

# Multiplication with overflow checking
recipe u8.mul(my: u8, other: u8) -> u8 {
    return llvm_intrinsic("llvm.umul.with.overflow.i8", my, other)
}

# Division (unsigned) - maps to LLVM udiv
recipe u8.floordiv(my: u8, other: u8) -> u8 {
    when (other) {
        0 => throw panic("Division by zero"),
        _ => return llvm_intrinsic("udiv", my, other)
    }
}

# Remainder (unsigned) - maps to LLVM urem
recipe u8.rem(my: u8, other: u8) -> u8 {
    when (other) {
        0 => throw panic("Division by zero"),
        _ => return llvm_intrinsic("urem", my, other)
    }
}

# Bitwise operations (direct LLVM mapping)
recipe u8.and(my: u8, other: u8) -> u8 {
    return llvm_intrinsic("and", my, other)
}

recipe u8.or(my: u8, other: u8) -> u8 {
    return llvm_intrinsic("or", my, other)
}

recipe u8.xor(my: u8, other: u8) -> u8 {
    return llvm_intrinsic("xor", my, other)
}

recipe u8.not(my: u8) -> u8 {
    return llvm_intrinsic("xor", my, 255)
}

# Bit shifting operations
recipe u8.shl(my: u8, bits: u8) -> u8 {
    return llvm_intrinsic("shl", my, bits)
}

recipe u8.shr(my: u8, bits: u8) -> u8 {
    return llvm_intrinsic("lshr", my, bits)  # Logical right shift for unsigned
}

# Comparison operations (LLVM icmp)
recipe u8.eq(my: u8, other: u8) -> bool {
    return llvm_intrinsic("icmp eq", my, other)
}

recipe u8.ne(my: u8, other: u8) -> bool {
    return llvm_intrinsic("icmp ne", my, other)
}

recipe u8.lt(my: u8, other: u8) -> bool {
    return llvm_intrinsic("icmp ult", my, other)  # Unsigned less than
}

recipe u8.le(my: u8, other: u8) -> bool {
    return llvm_intrinsic("icmp ule", my, other)  # Unsigned less equal
}

recipe u8.gt(my: u8, other: u8) -> bool {
    return llvm_intrinsic("icmp ugt", my, other)  # Unsigned greater than
}

recipe u8.ge(my: u8, other: u8) -> bool {
    return llvm_intrinsic("icmp uge", my, other)  # Unsigned greater equal
}

# Math operations
recipe u8.min(my: u8, other: u8) -> u8 {
    return if my <= other then my else other
}

recipe u8.max(my: u8, other: u8) -> u8 {
    return if my >= other then my else other
}

# Bit manipulation utilities
recipe u8.count_leading_zeros(my: u8) -> u8 {
    return llvm_intrinsic("llvm.ctlz.i8", my, false)
}

recipe u8.count_trailing_zeros(my: u8) -> u8 {
    return llvm_intrinsic("llvm.cttz.i8", my, false)
}

recipe u8.count_ones(my: u8) -> u8 {
    return llvm_intrinsic("llvm.ctpop.i8", my)
}

# No byte swapping for 8-bit values (single byte)

# Type conversions to other native types (using constructor syntax)
recipe s8(from_u8: u8) -> s8 {
    return llvm_intrinsic("bitcast", from_u8)  # Direct bit reinterpretation
}

recipe u16(from_u8: u8) -> u16 {
    return llvm_intrinsic("zext", from_u8)     # Zero-extend to 16-bit
}

recipe u32(from_u8: u8) -> u32 {
    return llvm_intrinsic("zext", from_u8)     # Zero-extend to 32-bit
}

recipe u64(from_u8: u8) -> u64 {
    return llvm_intrinsic("zext", from_u8)     # Zero-extend to 64-bit
}

recipe s16(from_u8: u8) -> s16 {
    return llvm_intrinsic("zext", from_u8)     # Zero-extend to signed 16-bit
}

recipe s32(from_u8: u8) -> s32 {
    return llvm_intrinsic("zext", from_u8)     # Zero-extend to signed 32-bit
}

recipe s64(from_u8: u8) -> s64 {
    return llvm_intrinsic("zext", from_u8)     # Zero-extend to signed 64-bit
}

recipe f32(from_u8: u8) -> f32 {
    return llvm_intrinsic("uitofp", from_u8)   # Unsigned int to float
}

recipe f64(from_u8: u8) -> f64 {
    return llvm_intrinsic("uitofp", from_u8)   # Unsigned int to double
}

recipe bool(from_u8: u8) -> bool {
    return from_u8 != 0
}

# Parsing and formatting using constructor syntax
recipe u8(from_text: Text) -> u8 {
    # Parse Text to u8 using LLVM constant folding when possible
    return 0  # Placeholder
}

recipe Text(from_u8: u8) -> Text {
    # Convert u8 to Text representation
    return ""  # Placeholder
}

# Utility functions for byte operations
recipe u8.is_power_of_two(my: u8) -> bool {
    return my != 0 and (my & (my - 1)) == 0
}

recipe u8.next_power_of_two(my: u8) -> u8 {
    when (my) {
        0 => return 1,
        1 => return 1,
        _ => {
            var power: u8 = 1
            while power < my {
                power = power << 1
            }
            return power
        }
    }
}

# Saturating arithmetic (clamps to min/max instead of wrapping)
recipe u8.saturating_add(my: u8, other: u8) -> u8 {
    let result = my + other
    return if result < my then U8_MAX else result  # Overflow check
}

recipe u8.saturating_sub(my: u8, other: u8) -> u8 {
    return if my >= other then my - other else U8_ZERO
}

recipe u8.saturating_mul(my: u8, other: u8) -> u8 {
    let result = my * other
    return if other != 0 and result / other != my then U8_MAX else result
}

/*
LLVM IR Mapping:
- RazorForge u8 -> LLVM i8 -> C uint8_t
- Range: 0 to 255
- Unsigned operations use ult, uge, udiv, urem, lshr
- Efficient for byte arrays, pixel data, and small counters
- Zero-extension used for conversions to larger types
*/
# RazorForge f16 (half precision floating point) native type implementation
# Maps directly to LLVM half type using compiler intrinsics
namespace core
# Core f16 type definition - maps to LLVM half
record f16 {
    public value: LlvmNativeHalf
}

# IEEE 754 half precision constants
preset F16_EPSILON: f16 = 9.765625e-4_f16
preset F16_MIN: f16 = -65504.0_f16
preset F16_MAX: f16 = 65504.0_f16
preset F16_MIN_POSITIVE: f16 = 6.103515625e-5_f16
preset F16_ZERO: f16 = 0.0_f16
preset F16_ONE: f16 = 1.0_f16

# Mathematical constants
preset F16_PI: f16 = 3.140625_f16
preset F16_E: f16 = 2.71875_f16
preset F16_SQRT_2: f16 = 1.414063_f16

# Failable constructor from Text - called as f16!(text)
# Compiler automatically generates try_f16.__create__(text) -> Maybe<f16>
routine f16.__create__!(from_text: Text<Letterlikes>) -> f16 {
    danger! {
        return @parse_f16(from_text)
    }
}

# ============================================================================
# Arithmetic Operations (IEEE 754 semantics)
# ============================================================================

routine f16.__add__(other: f16) -> f16 {
    danger! {
        return @intrinsic.add.wrapping<half>(me, other)
    }
}

routine f16.__sub__(other: f16) -> f16 {
    danger! {
        return @intrinsic.sub.wrapping<half>(me, other)
    }
}

routine f16.__mul__(other: f16) -> f16 {
    danger! {
        return @intrinsic.mul.wrapping<half>(me, other)
    }
}

routine f16.__truediv__(other: f16) -> f16 {
    danger! {
        return @intrinsic.div.wrapping<half>(me, other)
    }
}

routine f16.__neg__() -> f16 {
    danger! {
        return @intrinsic.sub.wrapping<half>(0.0_f16, me)
    }
}

# ============================================================================
# Comparison Operations (ordered - false if NaN)
# ============================================================================

routine f16.__lt__(other: f16) -> bool {
    danger! {
        return @intrinsic.fcmp.olt<half>(me, other)
    }
}

routine f16.__le__(other: f16) -> bool {
    danger! {
        return @intrinsic.fcmp.ole<half>(me, other)
    }
}

routine f16.__gt__(other: f16) -> bool {
    danger! {
        return @intrinsic.fcmp.ogt<half>(me, other)
    }
}

routine f16.__ge__(other: f16) -> bool {
    danger! {
        return @intrinsic.fcmp.oge<half>(me, other)
    }
}

# ============================================================================
# Math Operations using intrinsics
# ============================================================================

routine f16.sqrt() -> f16 {
    danger! {
        return @intrinsic.sqrt<half>(me)
    }
}

routine f16.abs() -> f16 {
    danger! {
        return @intrinsic.fabs<half>(me)
    }
}

routine f16.floor() -> f16 {
    danger! {
        return @intrinsic.floor<half>(me)
    }
}

routine f16.ceil() -> f16 {
    danger! {
        return @intrinsic.ceil<half>(me)
    }
}

routine f16.round() -> f16 {
    danger! {
        return @intrinsic.round<half>(me)
    }
}

routine f16.trunc() -> f16 {
    danger! {
        return @intrinsic.trunc_float<half>(me)
    }
}

routine f16.copysign(sign: f16) -> f16 {
    danger! {
        return @intrinsic.copysign<half>(me, sign)
    }
}

# ============================================================================
# Utility Methods
# ============================================================================

routine f16.min(other: f16) -> f16 {
    return if me <= other then me else other
}

routine f16.max(other: f16) -> f16 {
    return if me >= other then me else other
}

routine f16.clamp(min_val: f16, max_val: f16) -> f16 {
    return me.min(max_val).max(min_val)
}

routine f16.is_positive() -> bool {
    return me > 0.0_f16
}

routine f16.is_negative() -> bool {
    return me < 0.0_f16
}

routine f16.is_zero() -> bool {
    return me == 0.0_f16
}

routine f16.signum() -> f16 {
    when {
        me > 0.0_f16 => 1.0_f16,
        me < 0.0_f16 => -1.0_f16,
        _ => 0.0_f16
    }
}

# ============================================================================
# Type Conversions
# ============================================================================

routine f16.to_s16() -> s16 {
    danger! {
        return @intrinsic.fptosi<half, i16>(me)
    }
}

routine f16.to_u16() -> u16 {
    danger! {
        return @intrinsic.fptoui<half, i16>(me)
    }
}

routine f16.to_s32() -> s32 {
    danger! {
        return @intrinsic.fptosi<half, i32>(me)
    }
}

routine f16.to_u32() -> u32 {
    danger! {
        return @intrinsic.fptoui<half, i32>(me)
    }
}

routine f16.to_f32() -> f32 {
    danger! {
        return @intrinsic.fpext<half, float>(me)
    }
}

routine f16.to_f64() -> f64 {
    danger! {
        return @intrinsic.fpext<half, double>(me)
    }
}

# Reinterpret bits as u16 (type punning)
routine f16.to_bits() -> u16 {
    danger! {
        return @intrinsic.bitcast<half, i16>(me)
    }
}

# Create f16 from u16 bits (type punning)
routine f16.from_bits(bits: u16) -> f16 {
    danger! {
        return @intrinsic.bitcast<i16, half>(bits)
    }
}

# ============================================================================
# String Conversion
# ============================================================================

routine f16.to_text() -> Text {
    danger! {
        return @format_f16(me)
    }
}

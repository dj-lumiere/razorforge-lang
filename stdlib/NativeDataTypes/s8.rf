# RazorForge s8 (signed 8-bit integer) native type implementation
# Maps directly to LLVM i8 type using compiler intrinsics
namespace core
# Core s8 type definition - maps to LLVM i8
record s8 {
    private value: @intrinsic.i8
}

# Constants for s8 limits
preset S8_MIN: s8 = -128_s8
preset S8_MAX: s8 = 127_s8
preset S8_ZERO: s8 = 0_s8
preset S8_ONE: s8 = 1_s8

# ============================================================================
# Constructors
# ============================================================================

routine s8.__create__!(from_text: Text<Letter>) -> s8 {
    danger! {
        return @native.rf_parse_s8(from_text)
    }
}

routine s8.__create__(from: s8) -> s8 {
    return from
}

# From s16 - crashes if value out of s8 range
routine s8.__create__!(from: s16) -> s8 {
    if not (S8_MIN <= from <= S8_MAX) {
        throw IntegerOverflowError(f"Cannot convert {from} to s8: value out of range [{S8_MIN}, {S8_MAX}]")
    }
    danger! {
        return @intrinsic.trunc<i16, i8>(from)
    }
}

# From s32 - crashes if value out of s8 range
routine s8.__create__!(from: s32) -> s8 {
    if not (S8_MIN <= from <= S8_MAX) {
        throw IntegerOverflowError(f"Cannot convert {from} to s8: value out of range [{S8_MIN}, {S8_MAX}]")
    }
    danger! {
        return @intrinsic.trunc<i32, i8>(from)
    }
}

# From s64 - crashes if value out of s8 range
routine s8.__create__!(from: s64) -> s8 {
    if not (S8_MIN <= from <= S8_MAX) {
        throw IntegerOverflowError(f"Cannot convert {from} to s8: value out of range [{S8_MIN}, {S8_MAX}]")
    }
    danger! {
        return @intrinsic.trunc<i64, i8>(from)
    }
}

# From s128 - crashes if value out of s8 range
routine s8.__create__!(from: s128) -> s8 {
    if not (S8_MIN <= from <= S8_MAX) {
        throw IntegerOverflowError(f"Cannot convert {from} to s8: value out of range [{S8_MIN}, {S8_MAX}]")
    }
    danger! {
        return @intrinsic.trunc<i128, i8>(from)
    }
}

# From u8 - crashes if value > S8_MAX (bit 7 set)
routine s8.__create__!(from: u8) -> s8 {
    if from > 127_u8 {
        throw IntegerOverflowError(f"Cannot convert {from} to s8: value out of range [{S8_MIN}, {S8_MAX}]")
    }
    danger! {
        return @intrinsic.bitcast<i8, i8>(from)
    }
}

# From u16 - crashes if value > S8_MAX
routine s8.__create__!(from: u16) -> s8 {
    if from > 127_u16 {
        throw IntegerOverflowError(f"Cannot convert {from} to s8: value out of range [{S8_MIN}, {S8_MAX}]")
    }
    danger! {
        return @intrinsic.trunc<i16, i8>(from)
    }
}

# From u32 - crashes if value > S8_MAX
routine s8.__create__!(from: u32) -> s8 {
    if from > 127_u32 {
        throw IntegerOverflowError(f"Cannot convert {from} to s8: value out of range [{S8_MIN}, {S8_MAX}]")
    }
    danger! {
        return @intrinsic.trunc<i32, i8>(from)
    }
}

# From u64 - crashes if value > S8_MAX
routine s8.__create__!(from: u64) -> s8 {
    if from > 127_u64 {
        throw IntegerOverflowError(f"Cannot convert {from} to s8: value out of range [{S8_MIN}, {S8_MAX}]")
    }
    danger! {
        return @intrinsic.trunc<i64, i8>(from)
    }
}

# From u128 - crashes if value > S8_MAX
routine s8.__create__!(from: u128) -> s8 {
    if from > 127_u128 {
        throw IntegerOverflowError(f"Cannot convert {from} to s8: value out of range [{S8_MIN}, {S8_MAX}]")
    }
    danger! {
        return @intrinsic.trunc<i128, i8>(from)
    }
}

# From floating point - truncates fractional part and crashes if overflow
routine s8.__create__!(from: f16) -> s8 {
    return from.s32!().s8!()
}

routine s8.__create__!(from: f32) -> s8 {
    return from.s32!().s8!()
}

routine s8.__create__!(from: f64) -> s8 {
    return from.s32!().s8!()
}

routine s8.__create__!(from: f128) -> s8 {
    return from.s32!().s8!()
}

# From decimal - truncates fractional part and crashes if overflow
routine s8.__create__!(from: d32) -> s8 {
    return from.s32!().s8!()
}

routine s8.__create__!(from: d64) -> s8 {
    return from.s32!().s8!()
}

routine s8.__create__!(from: d128) -> s8 {
    return from.s32!().s8!()
}

# From saddr - crashes if value out of s8 range
routine s8.__create__!(from: saddr) -> s8 {
    let val_s64 = from.s64!()
    if not (-128_s64 <= val_s64 <= 127_s64) {
        throw IntegerOverflowError(f"Cannot convert {from} to s8: value out of range [{S8_MIN}, {S8_MAX}]")
    }
    danger! {
        return @intrinsic.trunc<iptr, i8>(from)
    }
}

# From uaddr - crashes if value out of s8 range
routine s8.__create__!(from: uaddr) -> s8 {
    let val_u64 = from.u64!()
    if val_u64 > 127_u64 {
        throw IntegerOverflowError(f"Cannot convert {from} to s8: value out of range [{S8_MIN}, {S8_MAX}]")
    }
    danger! {
        return @intrinsic.trunc<uptr, i8>(from)
    }
}

# ============================================================================
# Arithmetic Operations (trapping on overflow by default)
# ============================================================================

@crash_only
routine s8.__add__!(you: s8) -> s8 {
    danger! {
        return @intrinsic.add<i8>(me, you)
    }
}

@crash_only
routine s8.__sub__!(you: s8) -> s8 {
    danger! {
        return @intrinsic.sub<i8>(me, you)
    }
}

@crash_only
routine s8.__mul__!(you: s8) -> s8 {
    danger! {
        return @intrinsic.mul<i8>(me, you)
    }
}

@crash_only
routine s8.__floordiv__!(you: s8) -> s8 {
    if you == 0 {
        throw DivisionByZeroError()
    }
    danger! {
        return @intrinsic.sdiv<i8>(me, you)
    }
}

@crash_only
routine s8.__mod__!(you: s8) -> s8 {
    danger! {
        return @intrinsic.srem<i8>(me, you)
    }
}

@crash_only
routine s8.__neg__!() -> s8 {
    danger! {
        return @intrinsic.neg<i8>(me)
    }
}

# ============================================================================
# Wrapping Arithmetic (+%, -%, *%)
# ============================================================================

routine s8.__add_wrap__(you: s8) -> s8 {
    danger! {
        return @intrinsic.add.wrapping<i8>(me, you)
    }
}

routine s8.__sub_wrap__(you: s8) -> s8 {
    danger! {
        return @intrinsic.sub.wrapping<i8>(me, you)
    }
}

routine s8.__mul_wrap__(you: s8) -> s8 {
    danger! {
        return @intrinsic.mul.wrapping<i8>(me, you)
    }
}

# ============================================================================
# Saturating Arithmetic (+^, -^, *^)
# ============================================================================

routine s8.__add_sat__(you: s8) -> s8 {
    danger! {
        return @intrinsic.add.saturating<i8>(me, you)
    }
}

routine s8.__sub_sat__(you: s8) -> s8 {
    danger! {
        return @intrinsic.sub.saturating<i8>(me, you)
    }
}

routine s8.__mul_sat__(you: s8) -> s8 {
    danger! {
        return @intrinsic.mul.saturating<i8>(me, you)
    }
}

# ============================================================================
# Checked Arithmetic (+?, -?, *?) - returns Maybe<T>
# ============================================================================

routine s8.__add_checked__(you: s8) -> s8? {
    danger! {
        let (result, overflow) = @intrinsic.add.overflow<i8>(me, you)
        return if overflow then None else result
    }
}

routine s8.__sub_checked__(you: s8) -> s8? {
    danger! {
        let (result, overflow) = @intrinsic.sub.overflow<i8>(me, you)
        return if overflow then None else result
    }
}

routine s8.__mul_checked__(you: s8) -> s8? {
    danger! {
        let (result, overflow) = @intrinsic.mul.overflow<i8>(me, you)
        return if overflow then None else result
    }
}

# ============================================================================
# Power Operations (**)
# ============================================================================

# Power operator (**) - can overflow
@crash_only
routine s8.__pow__!(exp: s8) -> s8 {
    danger! {
        var result: s8 = 1
        var base: s8 = me
        var e: u32 = exp
        if me == 0 and exp == 0 {
            throw IndeterminateResultError()
        }
        if exp < 0 {
            return NegativeExponentError(exp)
        }
        while e > 0 {
            if (e & 1) == 1 {
                result = @intrinsic.mul<i8>(result, base)
            }
            base = @intrinsic.mul<i8>(base, base)
            e = e >> 1
        }
        return result
    }
}

# Wrapping power (**%)
routine s8.__pow_wrap__!(exp: s8) -> s8 {
    danger! {
        var result: s8 = 1
        var base: s8 = me
        var e: u32 = exp
        if me == 0 and exp == 0 {
            throw IndeterminateResultError()
        }
        if exp < 0 {
            return NegativeExponentError(exp)
        }
        while e > 0 {
            if (e & 1) == 1 {
                result = @intrinsic.mul.wrapping<i8>(result, base)
            }
            base = @intrinsic.mul.wrapping<i8>(base, base)
            e = e >> 1
        }
        return result
    }
}

# Saturating power (**^)
routine s8.__pow_sat__!(exp: s8) -> s8 {
    danger! {
        var result: s8 = 1
        var base: s8 = me
        var e: u32 = exp
        if me == 0 and exp == 0 {
            throw IndeterminateResultError()
        }
        if exp < 0 {
            return NegativeExponentError(exp)
        }
        while e > 0 {
            if (e & 1) == 1 {
                result = @intrinsic.mul.saturating<i8>(result, base)
            }
            base = @intrinsic.mul.saturating<i8>(base, base)
            e = e >> 1
        }
        return result
    }
}

# Checked power (**?) - returns Maybe<s8>
routine s8.__pow_checked__(exp: s8) -> s8? {
    danger! {
        var result: s8 = 1
        var base: s8 = me
        var e: u32 = exp
        if exp < 0 {
            return None
        }
        if me == 0 {
            return None
        }
        while e > 0 {
            if (e & 1) == 1 {
                let (new_result, overflow) = @intrinsic.mul.overflow<i8>(result, base)
                if overflow {
                    return None
                }
                result = new_result
            }
            let (new_base, overflow) = @intrinsic.mul.overflow<i8>(base, base)
            if overflow and e > 1 {
                return None
            }
            base = new_base
            e = e >> 1
        }
        return result
    }
}

# ============================================================================
# Bitwise Operations
# ============================================================================

routine s8.__and__(you: s8) -> s8 {
    danger! {
        return @intrinsic.and<i8>(me, you)
    }
}

routine s8.__or__(you: s8) -> s8 {
    danger! {
        return @intrinsic.or<i8>(me, you)
    }
}

routine s8.__xor__(you: s8) -> s8 {
    danger! {
        return @intrinsic.xor<i8>(me, you)
    }
}

routine s8.__not__() -> s8 {
    danger! {
        return @intrinsic.not<i8>(me)
    }
}

# ============================================================================
# Shift Operations (<<, <<?>, >>, <<<, >>>)
# ============================================================================

# Arithmetic left shift (<<) - sign preserving
routine s8.__ashl__(bits: u32) -> s8 {
    danger! {
        return @intrinsic.shl<i8>(me, bits)
    }
}

# Checked arithmetic left shift (<<?) - returns Maybe<s8>
routine s8.__ashl_checked__(bits: u32) -> Maybe<s8> {
    danger! {
        if bits >= 8 {
            return None
        }
        let result = @intrinsic.shl<i8>(me, bits)
        # Check if we can recover the original value
        let recovered = @intrinsic.ashr<i8>(result, bits)
        if recovered != me {
            return None
        }
        return result
    }
}

# Arithmetic right shift (>>) - preserves sign, always safe
routine s8.__ashr__(bits: u32) -> s8 {
    danger! {
        return @intrinsic.ashr<i8>(me, bits)
    }
}

# Logical left shift (<<<) - same as << but explicit
routine s8.__lshl__(bits: u32) -> s8 {
    danger! {
        return @intrinsic.shl<i8>(me, bits)
    }
}

# Logical right shift (>>>) - fills with zeros, ignores sign
routine s8.__lshr__(bits: u32) -> s8 {
    danger! {
        return @intrinsic.lshr<i8>(me, bits)
    }
}

# ============================================================================
# Comparison Operations
# ============================================================================

routine s8.__eq__(you: s8) -> bool {
    danger! {
        return @intrinsic.icmp.eq<i8>(me, you)
    }
}

routine s8.__ne__(you: s8) -> bool {
    danger! {
        return @intrinsic.icmp.ne<i8>(me, you)
    }
}

routine s8.__lt__(you: s8) -> bool {
    danger! {
        return @intrinsic.icmp.slt<i8>(me, you)
    }
}

routine s8.__le__(you: s8) -> bool {
    danger! {
        return @intrinsic.icmp.sle<i8>(me, you)
    }
}

routine s8.__gt__(you: s8) -> bool {
    danger! {
        return @intrinsic.icmp.sgt<i8>(me, you)
    }
}

routine s8.__ge__(you: s8) -> bool {
    danger! {
        return @intrinsic.icmp.sge<i8>(me, you)
    }
}

# ============================================================================
# Math Operations
# ============================================================================

routine s8.abs() -> s8 {
    danger! {
        return @intrinsic.abs<i8>(me)
    }
}

routine s8.min(you: s8) -> s8 {
    return if me <= you then me else you
}

routine s8.max(you: s8) -> s8 {
    return if me >= you then me else you
}

routine s8.clamp(min_val: s8, max_val: s8) -> s8 {
    return me.min(max_val).max(min_val)
}

# ============================================================================
# Bit Manipulation
# ============================================================================

routine s8.count_ones() -> s8 {
    danger! {
        return @intrinsic.ctpop<i8>(me)
    }
}

routine s8.count_zeros() -> s8 {
    return 8_s8 - me.count_ones()
}

routine s8.leading_zeros() -> s8 {
    danger! {
        return @intrinsic.ctlz<i8>(me)
    }
}

routine s8.trailing_zeros() -> s8 {
    danger! {
        return @intrinsic.cttz<i8>(me)
    }
}

routine s8.leading_ones() -> s8 {
    return me.__not__().leading_zeros()
}

routine s8.trailing_ones() -> s8 {
    return me.__not__().trailing_zeros()
}

routine s8.reverse_bits() -> s8 {
    danger! {
        return @intrinsic.bitreverse<i8>(me)
    }
}

# ============================================================================
# Type Conversions (constructor syntax)
# ============================================================================

# Bitcast to unsigned
routine u8(from: s8) -> u8 {
    danger! {
        return @intrinsic.bitcast<i8, i8>(from)
    }
}

# Sign-extend to larger types
routine s16(from: s8) -> s16 {
    danger! {
        return @intrinsic.sext<i8, i16>(from)
    }
}

routine s32(from: s8) -> s32 {
    danger! {
        return @intrinsic.sext<i8, i32>(from)
    }
}

routine s64(from: s8) -> s64 {
    danger! {
        return @intrinsic.sext<i8, i64>(from)
    }
}

routine s128(from: s8) -> s128 {
    danger! {
        return @intrinsic.sext<i8, i128>(from)
    }
}

# Convert to floating point
routine f32(from: s8) -> f32 {
    danger! {
        return @intrinsic.sitofp<i8, float>(from)
    }
}

routine f64(from: s8) -> f64 {
    danger! {
        return @intrinsic.sitofp<i8, double>(from)
    }
}

# Convert to boolean
routine bool(from: s8) -> bool {
    danger! {
        return @intrinsic.icmp.ne<i8>(from, 0_s8)
    }
}

# ============================================================================
# Utility Methods
# ============================================================================

routine s8.is_positive() -> bool {
    return me > 0_s8
}

routine s8.is_negative() -> bool {
    return me < 0_s8
}

routine s8.is_zero() -> bool {
    return me == 0_s8
}

routine s8.is_even() -> bool {
    danger! {
        let result = @intrinsic.and<i8>(me, 1_s8)
        return @intrinsic.icmp.eq<i8>(result, 0_s8)
    }
}

routine s8.is_odd() -> bool {
    return not me.is_even()
}

routine s8.signum() -> s8 {
    when {
        me > 0_s8 => 1_s8,
        me < 0_s8 => -1_s8,
        _ => 0_s8
    }
}

# ============================================================================
# String Conversion
# ============================================================================

routine s8.to_text() -> Text {
    danger! {
        return @native.rf_format_s8(me)
    }
}

# RazorForge s8 (signed 8-bit integer) native type implementation
# Maps directly to LLVM i8 type and native machine bytes

# Core s8 type definition - maps to LLVM i8
struct s8 {
    public value: LlvmNativeI8
}

# Constants for s8 limits (LLVM constant values)
preset S8_MIN: s8 = -128_s8
preset S8_MAX: s8 = 127_s8
preset S8_ZERO: s8 = 0_s8
preset S8_ONE: s8 = 1_s8

# Basic arithmetic operations (LLVM intrinsics: add, sub, mul, sdiv, srem)

# Addition with overflow checking
recipe s8.add(my: s8, other: s8) -> s8 {
    return llvm_intrinsic("llvm.sadd.with.overflow.i8", my, other)
}

# Subtraction with overflow checking
recipe s8.sub(my: s8, other: s8) -> s8 {
    return llvm_intrinsic("llvm.ssub.with.overflow.i8", my, other)
}

# Multiplication with overflow checking
recipe s8.mul(my: s8, other: s8) -> s8 {
    return llvm_intrinsic("llvm.smul.with.overflow.i8", my, other)
}

# Division (signed) - maps to LLVM sdiv
recipe s8.floordiv(my: s8, other: s8) -> s8 {
    when (other) {
        0 => throw panic("Division by zero"),
        _ => return llvm_intrinsic("sdiv", my, other)
    }
}

# Remainder (signed) - maps to LLVM srem
recipe s8.rem(my: s8, other: s8) -> s8 {
    when (other) {
        0 => throw panic("Division by zero"),
        _ => return llvm_intrinsic("srem", my, other)
    }
}

# Bitwise operations (direct LLVM mapping)
recipe s8.and(my: s8, other: s8) -> s8 {
    return llvm_intrinsic("and", my, other)
}

recipe s8.or(my: s8, other: s8) -> s8 {
    return llvm_intrinsic("or", my, other)
}

recipe s8.xor(my: s8, other: s8) -> s8 {
    return llvm_intrinsic("xor", my, other)
}

recipe s8.not(my: s8) -> s8 {
    return llvm_intrinsic("xor", my, -1)
}

# Bit shifting operations
recipe s8.shl(my: s8, bits: s8) -> s8 {
    return llvm_intrinsic("shl", my, bits)
}

recipe s8.shr(my: s8, bits: s8) -> s8 {
    return llvm_intrinsic("ashr", my, bits)  # Arithmetic right shift for signed
}

# Comparison operations (LLVM icmp)
recipe s8.eq(my: s8, other: s8) -> bool {
    return llvm_intrinsic("icmp eq", my, other)
}

recipe s8.ne(my: s8, other: s8) -> bool {
    return llvm_intrinsic("icmp ne", my, other)
}

recipe s8.lt(my: s8, other: s8) -> bool {
    return llvm_intrinsic("icmp slt", my, other)  # Signed less than
}

recipe s8.le(my: s8, other: s8) -> bool {
    return llvm_intrinsic("icmp sle", my, other)  # Signed less equal
}

recipe s8.gt(my: s8, other: s8) -> bool {
    return llvm_intrinsic("icmp sgt", my, other)  # Signed greater than
}

recipe s8.ge(my: s8, other: s8) -> bool {
    return llvm_intrinsic("icmp sge", my, other)  # Signed greater equal
}

# Advanced math operations using LLVM intrinsics
recipe s8.abs(my: s8) -> s8 {
    when (my) {
        >= 0 => return my,
        _ => return -my
    }
}

recipe s8.min(my: s8, other: s8) -> s8 {
    return if my <= other then my else other
}

recipe s8.max(my: s8, other: s8) -> s8 {
    return if my >= other then my else other
}

# Bit manipulation utilities
recipe s8.count_leading_zeros(my: s8) -> s8 {
    return llvm_intrinsic("llvm.ctlz.i8", my, false)
}

recipe s8.count_trailing_zeros(my: s8) -> s8 {
    return llvm_intrinsic("llvm.cttz.i8", my, false)
}

recipe s8.count_ones(my: s8) -> s8 {
    return llvm_intrinsic("llvm.ctpop.i8", my)
}

# No byte swapping for 8-bit values (single byte)

# Type conversions to other native types (using constructor syntax)
recipe u8(from_s8: s8) -> u8 {
    return llvm_intrinsic("bitcast", from_s8)  # Direct bit reinterpretation
}

recipe s16(from_s8: s8) -> s16 {
    return llvm_intrinsic("sext", from_s8)     # Sign-extend to 16-bit
}

recipe s32(from_s8: s8) -> s32 {
    return llvm_intrinsic("sext", from_s8)     # Sign-extend to 32-bit
}

recipe s64(from_s8: s8) -> s64 {
    return llvm_intrinsic("sext", from_s8)     # Sign-extend to 64-bit
}

recipe f32(from_s8: s8) -> f32 {
    return llvm_intrinsic("sitofp", from_s8)   # Signed int to float
}

recipe f64(from_s8: s8) -> f64 {
    return llvm_intrinsic("sitofp", from_s8)   # Signed int to double
}

recipe bool(from_s8: s8) -> bool {
    return from_s8 != 0
}

# Parsing and formatting using constructor syntax
recipe s8(from_text: Text) -> s8 {
    # Parse Text to s8 using LLVM constant folding when possible
    return 0  # Placeholder
}

recipe Text(from_s8: s8) -> Text {
    # Convert s8 to Text representation
    return ""  # Placeholder
}

/*
LLVM IR Mapping:
- RazorForge s8 -> LLVM i8 -> C int8_t
- Range: -128 to 127
- Single byte storage, efficient for small integers and byte arrays
- Auto-vectorized operations for SIMD processing
*/
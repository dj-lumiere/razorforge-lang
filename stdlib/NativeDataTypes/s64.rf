# RazorForge s64 (signed 64-bit integer) native type implementation
# Maps directly to LLVM i64 type using compiler intrinsics

namespace core

import ErrorHandling/Maybe
import Text/Text
import FFI/cstr

# Core s64 type definition - maps to LLVM i64
record s64 {
    private value: LlvmNativeI64
}

# Constants for s64 limits
preset S64_MIN: s64 = -9_223_372_036_854_775_808_s64
preset S64_MAX: s64 = 9_223_372_036_854_775_807_s64
preset S64_ZERO: s64 = 0_s64
preset S64_ONE: s64 = 1_s64

# ============================================================================
# Checked Constructors (crash on overflow)
# ============================================================================

routine s64.__create__!(from_text: Text<Letter>) -> s64 {
    danger! {
        return @native.rf_parse_s64(from_text)
    }
}

# From s8 - always fits, no check needed
routine s64.__create__!(from: s8) -> s64 {
    danger! {
        return @intrinsic.sext<i8, i64>(from)
    }
}

# From s16 - always fits, no check needed
routine s64.__create__!(from: s16) -> s64 {
    danger! {
        return @intrinsic.sext<i16, i64>(from)
    }
}

# From s32 - always fits, no check needed
routine s64.__create__!(from: s32) -> s64 {
    danger! {
        return @intrinsic.sext<i32, i64>(from)
    }
}

routine s64.__create__(from: s64) -> s64 {
    return from
}

# From s128 - crashes if value out of s64 range
routine s64.__create__!(from: s128) -> s64 {
    if not (S64_MIN <= from <= S64_MAX) {
        throw IntegerOverflowError(f"Cannot convert {from} to s64: value out of range [{S64_MIN}, {S64_MAX}]")
    }
    danger! {
        return @intrinsic.trunc<i128, i64>(from)
    }
}

# From u8 - always fits, no check needed
routine s64.__create__!(from: u8) -> s64 {
    danger! {
        return @intrinsic.zext<i8, i64>(from)
    }
}

# From u16 - always fits, no check needed
routine s64.__create__!(from: u16) -> s64 {
    danger! {
        return @intrinsic.zext<i16, i64>(from)
    }
}

# From u32 - always fits, no check needed
routine s64.__create__!(from: u32) -> s64 {
    danger! {
        return @intrinsic.zext<i32, i64>(from)
    }
}

# From u64 - crashes if value > S64_MAX (bit 63 set)
routine s64.__create__!(from: u64) -> s64 {
    if from > 9223372036854775807_u64 {
        throw IntegerOverflowError(f"Cannot convert {from} to s64: value out of range [{S64_MIN}, {S64_MAX}]")
    }
    danger! {
        return @intrinsic.bitcast<i64, i64>(from)
    }
}

# From u128 - crashes if value > S64_MAX
routine s64.__create__!(from: u128) -> s64 {
    if from > 9223372036854775807_u128 {
        throw IntegerOverflowError(f"Cannot convert {from} to s64: value out of range [{S64_MIN}, {S64_MAX}]")
    }
    danger! {
        return @intrinsic.trunc<i128, i64>(from)
    }
}

# From floating point - truncates
routine s64.__create__!(from: f16) -> s64 {
    return from.f32().s64!()
}

routine s64.__create__!(from: f32) -> s64 {
    danger! {
        return @intrinsic.fptosi<float, i64>(from)
    }
}

routine s64.__create__!(from: f64) -> s64 {
    danger! {
        return @intrinsic.fptosi<double, i64>(from)
    }
}

routine s64.__create__!(from: f128) -> s64 {
    return from.f64!().s64!()
}

# From decimal - truncates fractional part and can overflow
routine s64.__create__!(from: d32) -> s64 {
    danger! {
        let bits = @intrinsic.bitcast<d32, u32>(from)
        return d32_to_s64(bits)
    }
}

routine s64.__create__!(from: d64) -> s64 {
    danger! {
        let bits = @intrinsic.bitcast<d64, u64>(from)
        return d64_to_s64(bits)
    }
}

routine s64.__create__!(from: d128) -> s64 {
    danger! {
        return d128_to_s64(from.low, from.high)
    }
}

# From saddr - always fits (sign extends from 32 or 64-bit)
routine s64.__create__!(from: saddr) -> s64 {
    danger! {
        return @intrinsic.sext<iptr, i64>(from)
    }
}

# From uaddr - crashes if value > S64_MAX
routine s64.__create__!(from: uaddr) -> s64 {
    let val_u64 = from.u64!()
    if val_u64 > 9223372036854775807_u64 {
        throw IntegerOverflowError(f"Cannot convert {from} to s64: value out of range [{S64_MIN}, {S64_MAX}]")
    }
    danger! {
        return @intrinsic.zext<uptr, i64>(from)
    }
}

# ============================================================================
# Arithmetic Operations
# ============================================================================

# Addition
@crash_only
routine s64.__add__!(you: s64) -> s64 {
    danger! {
        return @intrinsic.add<i64>(me, you)
    }
}

# Subtraction
@crash_only
routine s64.__sub__!(you: s64) -> s64 {
    danger! {
        return @intrinsic.sub<i64>(me, you)
    }
}

# Multiplication
@crash_only
routine s64.__mul__!(you: s64) -> s64 {
    danger! {
        return @intrinsic.mul.wrapping<i64>(me, you)
    }
}

# Division
@crash_only
routine s64.__floordiv__!(you: s64) -> s64 {
    if you == 0 {
        throw DivisionByZeroError()
    }
    danger! {
        return @intrinsic.div.wrapping<i64>(me, you)
    }
}

# Remainder
@crash_only
routine s64.__rem__!(you: s64) -> s64 {
    danger! {
        return @intrinsic.rem.wrapping<i64>(me, you)
    }
}

# Negation
@crash_only
routine s64.__neg__!() -> s64 {
    danger! {
        return @intrinsic.sub.wrapping<i64>(0_s64, me)
    }
}

# ============================================================================
# Wrapping Arithmetic (+%, -%, *%)
# ============================================================================

routine s64.__add_wrap__(you: s64) -> s64 {
    danger! {
        return @intrinsic.add.wrapping<i64>(me, you)
    }
}

routine s64.__sub_wrap__(you: s64) -> s64 {
    danger! {
        return @intrinsic.sub.wrapping<i64>(me, you)
    }
}

routine s64.__mul_wrap__(you: s64) -> s64 {
    danger! {
        return @intrinsic.mul.wrapping<i64>(me, you)
    }
}

# ============================================================================
# Saturating Arithmetic (+^, -^, *^)
# ============================================================================

routine s64.__add_sat__(you: s64) -> s64 {
    danger! {
        return @intrinsic.add.saturating<i64>(me, you)
    }
}

routine s64.__sub_sat__(you: s64) -> s64 {
    danger! {
        return @intrinsic.sub.saturating<i64>(me, you)
    }
}

routine s64.__mul_sat__(you: s64) -> s64 {
    danger! {
        return @intrinsic.mul.saturating<i64>(me, you)
    }
}

# ============================================================================
# Checked Arithmetic (+?, -?, *?) - returns Maybe<T>
# ============================================================================

routine s64.__add_checked__(you: s64) -> Maybe<s64> {
    danger! {
        let (result, overflow) = @intrinsic.add.overflow<i64>(me, you)
        if overflow {
            return None
        } else {
            return result
        }
    }
}

routine s64.__sub_checked__(you: s64) -> Maybe<s64> {
    danger! {
        let (result, overflow) = @intrinsic.sub.overflow<i64>(me, you)
        if overflow {
            return None
        } else {
            return result
        }
    }
}

routine s64.__mul_checked__(you: s64) -> Maybe<s64> {
    danger! {
        let (result, overflow) = @intrinsic.mul.overflow<i64>(me, you)
        if overflow {
            return None
        } else {
            return result
        }
    }
}

# ============================================================================
# Power Operations (**)
# ============================================================================

# Power operator (**) - can overflow
@crash_only
routine s64.__pow__!(exp: s64) -> s64 {
    danger! {
        var result: s64 = 1
        var base: s64 = me
        if me == 0 and exp == 0 {
            throw IndeterminateResultError()
        }
        if exp < 0 {
            return NegativeExponentError(exp)
        }
        while exp > 0 {
            if (exp & 1) == 1 {
                result = @intrinsic.mul<i64>(result, base)
            }
            base = @intrinsic.mul<i64>(base, base)
            exp = exp >> 1
        }
        return result
    }
}

# Wrapping power (**%)
routine s64.__pow_wrap__!(exp: s64) -> s64 {
    danger! {
        var result: s64 = 1
        var base: s64 = me
        if me == 0 and exp == 0 {
            throw IndeterminateResultError()
        }
        if exp < 0 {
            return NegativeExponentError(exp)
        }
        while exp > 0 {
            if (exp & 1) == 1 {
                result = @intrinsic.mul.wrapping<i64>(result, base)
            }
            base = @intrinsic.mul.wrapping<i64>(base, base)
            exp = exp >> 1
        }
        return result
    }
}

# Saturating power (**^)
routine s64.__pow_sat__!(exp: s64) -> s64 {
    danger! {
        var result: s64 = 1
        var base: s64 = me
        if me == 0 and exp == 0 {
            throw IndeterminateResultError()
        }
        if exp < 0 {
            return NegativeExponentError(exp)
        }
        while exp > 0 {
            if (exp & 1) == 1 {
                result = @intrinsic.mul.saturating<i64>(result, base)
            }
            base = @intrinsic.mul.saturating<i64>(base, base)
            exp = exp >> 1
        }
        return result
    }
}

# Checked power (**?) - returns Maybe<s64>
routine s64.__pow_checked__(exp: s64) -> Maybe<s64> {
    danger! {
        var result: s64 = 1
        var base: s64 = me
        var e: u32 = exp
        if exp < 0 {
            return None
        }
        if me == 0 {
            return None
        }
        while e > 0 {
            if (e & 1) == 1 {
                let (new_result, overflow) = @intrinsic.mul.overflow<i64>(result, base)
                if overflow {
                    return None
                }
                result = new_result
            }
            let (new_base, overflow) = @intrinsic.mul.overflow<i64>(base, base)
            if overflow and e > 1 {
                return None
            }
            base = new_base
            e = e >> 1
        }
        return result
    }
}

# ============================================================================
# Bitwise Operations
# ============================================================================

routine s64.__and__(you: s64) -> s64 {
    danger! {
        return @intrinsic.and<i64>(me, you)
    }
}

routine s64.__or__(you: s64) -> s64 {
    danger! {
        return @intrinsic.or<i64>(me, you)
    }
}

routine s64.__xor__(you: s64) -> s64 {
    danger! {
        return @intrinsic.xor<i64>(me, you)
    }
}

routine s64.__not__() -> s64 {
    danger! {
        return @intrinsic.not<i64>(me)
    }
}

# ============================================================================
# Shift Operations (<<, <<?>, >>, <<<, >>>)
# ============================================================================

# Arithmetic left shift (<<) - sign preserving
routine s64.__ashl__(bits: u32) -> s64 {
    danger! {
        return @intrinsic.shl<i64>(me, bits)
    }
}

# Checked arithmetic left shift (<<?) - returns Maybe<s64>
routine s64.__ashl_checked__(bits: u32) -> Maybe<s64> {
    danger! {
        if bits >= 64 {
            return None
        }
        let result = @intrinsic.shl<i64>(me, bits)
        # Check if we can recover the original value
        let recovered = @intrinsic.ashr<i64>(result, bits)
        if recovered != me {
            return None
        }
        return result
    }
}

# Arithmetic right shift (>>) - preserves sign, always safe
routine s64.__ashr__(bits: u32) -> s64 {
    danger! {
        return @intrinsic.ashr<i64>(me, bits)
    }
}

# Logical left shift (<<<) - same as << but explicit
routine s64.__lshl__(bits: u32) -> s64 {
    danger! {
        return @intrinsic.shl<i64>(me, bits)
    }
}

# Logical right shift (>>>) - fills with zeros, ignores sign
routine s64.__lshr__(bits: u32) -> s64 {
    danger! {
        return @intrinsic.lshr<i64>(me, bits)
    }
}

# ============================================================================
# Comparison Operations
# ============================================================================

routine s64.__eq__(you: s64) -> bool {
    danger! {
        return @intrinsic.icmp.eq<i64>(me, you)
    }
}

routine s64.__ne__(you: s64) -> bool {
    danger! {
        return @intrinsic.icmp.ne<i64>(me, you)
    }
}

routine s64.__lt__(you: s64) -> bool {
    danger! {
        return @intrinsic.icmp.slt<i64>(me, you)
    }
}

routine s64.__le__(you: s64) -> bool {
    danger! {
        return @intrinsic.icmp.sle<i64>(me, you)
    }
}

routine s64.__gt__(you: s64) -> bool {
    danger! {
        return @intrinsic.icmp.sgt<i64>(me, you)
    }
}

routine s64.__ge__(you: s64) -> bool {
    danger! {
        return @intrinsic.icmp.sge<i64>(me, you)
    }
}

# ============================================================================
# Math Operations
# ============================================================================

routine s64.abs() -> s64 {
    danger! {
        return @intrinsic.abs<i64>(me)
    }
}

routine s64.min(you: s64) -> s64 {
    if me <= you {
        return me
    } else {
        return you
    }
}

routine s64.max(you: s64) -> s64 {
    if me >= you {
        return me
    } else {
        return you
    }
}

routine s64.clamp(min_val: s64, max_val: s64) -> s64 {
    return me.min(max_val).max(min_val)
}

# ============================================================================
# Bit Manipulation
# ============================================================================

routine s64.count_ones() -> s64 {
    danger! {
        return @intrinsic.ctpop<i64>(me)
    }
}

routine s64.count_zeros() -> s64 {
    return 64_s64 - me.count_ones()
}

routine s64.leading_zeros() -> s64 {
    danger! {
        return @intrinsic.ctlz<i64>(me)
    }
}

routine s64.trailing_zeros() -> s64 {
    danger! {
        return @intrinsic.cttz<i64>(me)
    }
}

routine s64.leading_ones() -> s64 {
    return me.__not__().leading_zeros()
}

routine s64.trailing_ones() -> s64 {
    return me.__not__().trailing_zeros()
}

routine s64.reverse_bits() -> s64 {
    danger! {
        return @intrinsic.bitreverse<i64>(me)
    }
}

routine s64.swap_bytes() -> s64 {
    danger! {
        return @intrinsic.bswap<i64>(me)
    }
}

# ============================================================================
# Utility Methods
# ============================================================================

routine s64.is_positive() -> bool {
    return me > 0_s64
}

routine s64.is_negative() -> bool {
    return me < 0_s64
}

routine s64.is_zero() -> bool {
    return me == 0_s64
}

routine s64.is_even() -> bool {
    danger! {
        let result = @intrinsic.and<i64>(me, 1_s64)
        return @intrinsic.icmp.eq<i64>(result, 0_s64)
    }
}

routine s64.is_odd() -> bool {
    return not me.is_even()
}

routine s64.signum() -> s64 {
    when {
        me > 0_s64 => 1_s64,
        me < 0_s64 => -1_s64,
        _ => 0_s64
    }
}

# Power of 2 check
routine s64.is_power_of_two() -> bool {
    danger! {
        let is_pos = @intrinsic.icmp.sgt<i64>(me, 0_s64)
        let minus_one = @intrinsic.sub.wrapping<i64>(me, 1_s64)
        let anded = @intrinsic.and<i64>(me, minus_one)
        let is_zero = @intrinsic.icmp.eq<i64>(anded, 0_s64)
        return is_pos and is_zero
    }
}

# ============================================================================
# String Conversion
# ============================================================================

routine s64.to_text() -> Bytes {
    danger! {
        let ptr = @native.rf_format_s64(me)
        return Bytes(ptr: cstr(ptr: ptr))
    }
}

# RazorForge s64 (signed 64-bit integer) native type implementation
# Maps directly to LLVM i64 type using compiler intrinsics

# Core s64 type definition - maps to LLVM i64
record s64 {
    private value: LlvmNativeI64
}

# Constants for s64 limits
preset S64_MIN: s64 = -9_223_372_036_854_775_808_s64
preset S64_MAX: s64 = 9_223_372_036_854_775_807_s64
preset S64_ZERO: s64 = 0_s64
preset S64_ONE: s64 = 1_s64

# ============================================================================
# Arithmetic Operations
# ============================================================================

# Addition (wrapping by default)
routine s64.__add__(other: s64) -> s64 {
    danger! {
        return @intrinsic.add.wrapping<i64>(me, other)
    }
}

# Subtraction (wrapping by default)
routine s64.__sub__(other: s64) -> s64 {
    danger! {
        return @intrinsic.sub.wrapping<i64>(me, other)
    }
}

# Multiplication (wrapping by default)
routine s64.__mul__(other: s64) -> s64 {
    danger! {
        return @intrinsic.mul.wrapping<i64>(me, other)
    }
}

# Division (signed)
routine s64.__div__(other: s64) -> s64 {
    danger! {
        return @intrinsic.div.wrapping<i64>(me, other)
    }
}

# Remainder (signed)
routine s64.__rem__(other: s64) -> s64 {
    danger! {
        return @intrinsic.rem.wrapping<i64>(me, other)
    }
}

# Negation
routine s64.__neg__() -> s64 {
    danger! {
        return @intrinsic.sub.wrapping<i64>(0_s64, me)
    }
}

# ============================================================================
# Wrapping Arithmetic (+%, -%, *%)
# ============================================================================

routine s64.__add_wrap__(other: s64) -> s64 {
    danger! {
        return @intrinsic.add.wrapping<i64>(me, other)
    }
}

routine s64.__sub_wrap__(other: s64) -> s64 {
    danger! {
        return @intrinsic.sub.wrapping<i64>(me, other)
    }
}

routine s64.__mul_wrap__(other: s64) -> s64 {
    danger! {
        return @intrinsic.mul.wrapping<i64>(me, other)
    }
}

# ============================================================================
# Saturating Arithmetic (+^, -^, *^)
# ============================================================================

routine s64.__add_sat__(other: s64) -> s64 {
    danger! {
        return @intrinsic.add.saturating<i64>(me, other)
    }
}

routine s64.__sub_sat__(other: s64) -> s64 {
    danger! {
        return @intrinsic.sub.saturating<i64>(me, other)
    }
}

routine s64.__mul_sat__(other: s64) -> s64 {
    danger! {
        return @intrinsic.mul.saturating<i64>(me, other)
    }
}

# ============================================================================
# Checked Arithmetic (+?, -?, *?) - returns Maybe<T>
# ============================================================================

routine s64.__add_checked__(other: s64) -> Maybe<s64> {
    danger! {
        let (result, overflow) = @intrinsic.add.overflow<i64>(me, other)
        return if overflow { None } else { result }
    }
}

routine s64.__sub_checked__(other: s64) -> Maybe<s64> {
    danger! {
        let (result, overflow) = @intrinsic.sub.overflow<i64>(me, other)
        return if overflow { None } else { result }
    }
}

routine s64.__mul_checked__(other: s64) -> Maybe<s64> {
    danger! {
        let (result, overflow) = @intrinsic.mul.overflow<i64>(me, other)
        return if overflow { None } else { result }
    }
}

# ============================================================================
# Bitwise Operations
# ============================================================================

routine s64.__and__(other: s64) -> s64 {
    danger! {
        return @intrinsic.and<i64>(me, other)
    }
}

routine s64.__or__(other: s64) -> s64 {
    danger! {
        return @intrinsic.or<i64>(me, other)
    }
}

routine s64.__xor__(other: s64) -> s64 {
    danger! {
        return @intrinsic.xor<i64>(me, other)
    }
}

routine s64.__not__() -> s64 {
    danger! {
        return @intrinsic.not<i64>(me)
    }
}

# Left shift
routine s64.__shl__(bits: u32) -> s64 {
    danger! {
        return @intrinsic.shl<i64>(me, bits)
    }
}

# Arithmetic right shift (sign-extending)
routine s64.__shr__(bits: u32) -> s64 {
    danger! {
        return @intrinsic.ashr<i64>(me, bits)
    }
}

# ============================================================================
# Comparison Operations
# ============================================================================

routine s64.__eq__(other: s64) -> bool {
    danger! {
        return @intrinsic.icmp.eq<i64>(me, other)
    }
}

routine s64.__ne__(other: s64) -> bool {
    danger! {
        return @intrinsic.icmp.ne<i64>(me, other)
    }
}

routine s64.__lt__(other: s64) -> bool {
    danger! {
        return @intrinsic.icmp.slt<i64>(me, other)
    }
}

routine s64.__le__(other: s64) -> bool {
    danger! {
        return @intrinsic.icmp.sle<i64>(me, other)
    }
}

routine s64.__gt__(other: s64) -> bool {
    danger! {
        return @intrinsic.icmp.sgt<i64>(me, other)
    }
}

routine s64.__ge__(other: s64) -> bool {
    danger! {
        return @intrinsic.icmp.sge<i64>(me, other)
    }
}

# ============================================================================
# Math Operations
# ============================================================================

routine s64.abs() -> s64 {
    danger! {
        return @intrinsic.abs<i64>(me)
    }
}

routine s64.min(other: s64) -> s64 {
    return if me <= other then me else other
}

routine s64.max(other: s64) -> s64 {
    return if me >= other then me else other
}

routine s64.clamp(min_val: s64, max_val: s64) -> s64 {
    return me.min(max_val).max(min_val)
}

# ============================================================================
# Bit Manipulation
# ============================================================================

routine s64.count_ones() -> s64 {
    danger! {
        return @intrinsic.ctpop<i64>(me)
    }
}

routine s64.count_zeros() -> s64 {
    return 64_s64 - me.count_ones()
}

routine s64.leading_zeros() -> s64 {
    danger! {
        return @intrinsic.ctlz<i64>(me)
    }
}

routine s64.trailing_zeros() -> s64 {
    danger! {
        return @intrinsic.cttz<i64>(me)
    }
}

routine s64.leading_ones() -> s64 {
    return me.__not__().leading_zeros()
}

routine s64.trailing_ones() -> s64 {
    return me.__not__().trailing_zeros()
}

routine s64.reverse_bits() -> s64 {
    danger! {
        return @intrinsic.bitreverse<i64>(me)
    }
}

routine s64.swap_bytes() -> s64 {
    danger! {
        return @intrinsic.bswap<i64>(me)
    }
}

# ============================================================================
# Type Conversions (constructor syntax)
# ============================================================================

# Bitcast to unsigned
routine u64(from: s64) -> u64 {
    danger! {
        return @intrinsic.bitcast<i64, i64>(from)
    }
}

# Sign-extend to larger types
routine s128(from: s64) -> s128 {
    danger! {
        return @intrinsic.sext<i64, i128>(from)
    }
}

# Truncate to smaller signed integers
routine s32(from: s64) -> s32 {
    danger! {
        return @intrinsic.trunc<i64, i32>(from)
    }
}

routine s16(from: s64) -> s16 {
    danger! {
        return @intrinsic.trunc<i64, i16>(from)
    }
}

routine s8(from: s64) -> s8 {
    danger! {
        return @intrinsic.trunc<i64, i8>(from)
    }
}

# Convert to floating point
routine f64(from: s64) -> f64 {
    danger! {
        return @intrinsic.sitofp<i64, double>(from)
    }
}

routine f32(from: s64) -> f32 {
    danger! {
        return @intrinsic.sitofp<i64, float>(from)
    }
}

# Convert to boolean
routine bool(from: s64) -> bool {
    danger! {
        return @intrinsic.icmp.ne<i64>(from, 0_s64)
    }
}

# ============================================================================
# Utility Methods
# ============================================================================

routine s64.is_positive() -> bool {
    return me > 0_s64
}

routine s64.is_negative() -> bool {
    return me < 0_s64
}

routine s64.is_zero() -> bool {
    return me == 0_s64
}

routine s64.is_even() -> bool {
    danger! {
        let result = @intrinsic.and<i64>(me, 1_s64)
        return @intrinsic.icmp.eq<i64>(result, 0_s64)
    }
}

routine s64.is_odd() -> bool {
    return not me.is_even()
}

routine s64.signum() -> s64 {
    when {
        me > 0_s64 => 1_s64,
        me < 0_s64 => -1_s64,
        _ => 0_s64
    }
}

# Power of 2 check
routine s64.is_power_of_two() -> bool {
    danger! {
        let is_pos = @intrinsic.icmp.sgt<i64>(me, 0_s64)
        let minus_one = @intrinsic.sub.wrapping<i64>(me, 1_s64)
        let anded = @intrinsic.and<i64>(me, minus_one)
        let is_zero = @intrinsic.icmp.eq<i64>(anded, 0_s64)
        return is_pos and is_zero
    }
}

# ============================================================================
# String Conversion (placeholder - needs proper implementation)
# ============================================================================

routine s64.to_text() -> Text {
    danger! {
        return @format_s64(me)
    }
}

# Parsing constructors using compiler intrinsics

# Fallible constructor - crashes on invalid input
routine s64!(from_text: Text) -> s64 {
    danger! {
        return @parse_s64(from_text)
    }
}

# Safe constructor - returns Maybe<s64>
routine s64?(from_text: Text) -> Maybe<s64> {
    danger! {
        return @try_parse_s64(from_text)
    }
}

# ============================================================================
# Example: Fibonacci using s64
# ============================================================================

routine fibonacci_s64(n: s64) -> s64 {
    when {
        n <= 1_s64 => n,
        _ => {
            var a: s64 = 0_s64
            var b: s64 = 1_s64
            var i: s64 = 2_s64

            while i <= n {
                let temp = a + b
                a = b
                b = temp
                i = i + 1_s64
            }

            return b
        }
    }
}

# ============================================================================
# Example: GCD (Greatest Common Divisor) using intrinsics
# ============================================================================

routine gcd_s64(a: s64, b: s64) -> s64 {
    var x = a.abs()
    var y = b.abs()

    while y != 0_s64 {
        let temp = y
        y = x % y
        x = temp
    }

    return x
}

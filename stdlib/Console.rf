# Console I/O - Generic show/alert/get functions
# According to Console-IO.md:
# - show() for stdout (with sep/end parameters)
# - alert() for stderr (with sep/end parameters)
# - get_*() for stdin (Text by default, Bytes opt-in)

namespace Console

import Text/Text
import FFI/cstr

# ============================================================================
# Output: show() - Standard Output (stdout)
# ============================================================================
# Signature (when variadic is supported):
#   routine show(value: Representable, sep: Text = " ", end: Text = "\n")           # Static dispatch
#   routine show(values...: @erased Representable, sep: Text = " ", end: Text = "\n") # Dynamic dispatch

# show for Text
@prelude
routine Console.show(value: Text, end: Text = "\n") {
    let bytes_value: Bytes = value.to_utf8()
    let ptr = bytes_value.to_cstr()
    danger! {
        @native.rf_console_print_cstr(ptr)
    }
    if end.count() > 0u64 {
        let end_bytes = end.to_utf8()
        let end_ptr = end_bytes.to_cstr()
        danger! {
            @native.rf_console_print_cstr(end_ptr)
        }
    }
}

# show for Bytes (writes raw bytes directly)
@prelude
routine Console.show(value: Bytes, end: Text = "\n") {
    let ptr = value.to_cstr()
    danger! {
        @native.rf_console_print_cstr(ptr)
    }
    if end.count() > 0u64 {
        let end_bytes = end.to_utf8()
        let end_ptr = end_bytes.to_cstr()
        danger! {
            @native.rf_console_print_cstr(end_ptr)
        }
    }
}

# Generic show for any type that implements Representable
# Converts to Text via .to_text(), then to Bytes (UTF-8) for C interop
@prelude
routine Console.show<T>(value: T, end: Text = "\n")
where T follows Representable {
    let text_value: Text = value.to_text()
    Console.show(text_value, end: end)
}

# ============================================================================
# Output: alert() - Standard Error (stderr)
# ============================================================================

# alert for Text
@prelude
routine Console.alert(value: Text, end: Text = "\n") {
    let bytes_value: Bytes = value.to_utf8()
    let ptr = bytes_value.to_cstr()
    danger! {
        @native.rf_console_alert_cstr(ptr)
    }
    if end.count() > 0u64 {
        let end_bytes = end.to_utf8()
        let end_ptr = end_bytes.to_cstr()
        danger! {
            @native.rf_console_alert_cstr(end_ptr)
        }
    }
}

# alert for Bytes (writes raw bytes directly)
@prelude
routine Console.alert(value: Bytes, end: Text = "\n") {
    let ptr = value.to_cstr()
    danger! {
        @native.rf_console_alert_cstr(ptr)
    }
    if end.count() > 0u64 {
        let end_bytes = end.to_utf8()
        let end_ptr = end_bytes.to_cstr()
        danger! {
            @native.rf_console_alert_cstr(end_ptr)
        }
    }
}

# Generic alert for any type that implements Representable
@prelude
routine Console.alert<T>(value: T, end: Text = "\n")
where T follows Representable{
    let text_value: Text = value.to_text()
    Console.alert(text_value, end: end)
}

# ============================================================================
# Input: Text functions (default)
# ============================================================================

# Read text until newline (single line)
@prelude
routine Console.get_line() -> Text {
    danger! {
        let ptr = @native.rf_console_get_line()
        let bytes = Bytes(ptr: ptr)
        return bytes.to_text()
    }
}

# Read text until whitespace (single word)
@prelude
routine Console.get_word() -> Text {
    danger! {
        let ptr = @native.rf_console_get_word()
        let bytes = Bytes(ptr: ptr)
        return bytes.to_text()
    }
}

# Read all text until EOF
@prelude
routine Console.get_all() -> Text {
    danger! {
        let ptr = @native.rf_console_get_all()
        let bytes = Bytes(ptr: ptr)
        return bytes.to_text()
    }
}

# Read exactly n codepoints from input
@prelude
routine Console.get_letters(count: uaddr) -> Text {
    danger! {
        let ptr = @native.rf_console_get_letters(count)
        let bytes = Bytes(ptr: ptr)
        return bytes.to_text()
    }
}

# Read all lines separated by newline
@prelude
routine Console.get_lines() -> List<Text> {
    let all = Console.get_all()
    # TODO: Implement split by newline
    throw NotImplementedError("Console.get_lines")
}

# Read all words separated by whitespace
@prelude
routine Console.get_words() -> List<Text> {
    let all = Console.get_all()
    # TODO: Implement split by whitespace
    throw NotImplementedError("Console.get_words")
}

# ============================================================================
# Input: Bytes functions (opt-in)
# ============================================================================

# Read all remaining input as raw bytes
@prelude
routine Console.get_raw() -> Bytes {
    danger! {
        let ptr = @native.rf_console_get_all()
        return Bytes(ptr: ptr)
    }
}

# Read up to n bytes
@prelude
routine Console.get_bytes(count: uaddr) -> Bytes {
    danger! {
        let ptr = @native.rf_console_get_bytes(count)
        return Bytes(ptr: ptr)
    }
}

# ============================================================================
# Utility Functions
# ============================================================================

routine Console.flush() {
    danger! {
        @native.rf_console_flush()
    }
}

routine Console.clear() {
    danger! {
        @native.rf_console_clear()
    }
}

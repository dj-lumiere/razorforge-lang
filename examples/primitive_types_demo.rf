# RazorForge Primitive Types Demonstration
# Demonstrates s64, u64, and f64 types using intrinsic-based operations

# ============================================================================
# s64 (Signed 64-bit Integer) Examples
# ============================================================================

routine test_s64_arithmetic() {
    Console.show_line("=== s64 Arithmetic Operations ===")

    let a: s64 = 100_s64
    let b: s64 = 42_s64

    # Basic arithmetic
    let sum = a + b
    let diff = a - b
    let product = a * b
    let quotient = a / b
    let remainder = a % b

    Console.show_line(f"a + b = {sum}")
    Console.show_line(f"a - b = {diff}")
    Console.show_line(f"a * b = {product}")
    Console.show_line(f"a / b = {quotient}")
    Console.show_line(f"a % b = {remainder}")

    # Negation
    let neg = -a
    Console.show_line(f"-a = {neg}")

    # Absolute value
    let negative: s64 = -42_s64
    let abs_val = negative.abs()
    Console.show_line(f"abs(-42) = {abs_val}")
}

routine test_s64_overflow() {
    Console.show_line("\n=== s64 Overflow Handling ===")

    let max_val: s64 = S64_MAX
    let one: s64 = 1_s64

    # Wrapping addition (default)
    let wrapped = max_val + one
    Console.show_line(f"S64_MAX + 1 (wrapping) = {wrapped}")

    # Checked addition
    let checked_result = max_val.checked_add(one)
    when checked_result {
        Ok(value) => Console.show_line(f"Checked add succeeded: {value}"),
        Err(_) => Console.show_line("Checked add detected overflow!")
    }

    # Saturating addition
    let saturated = max_val.saturating_add(one)
    Console.show_line(f"S64_MAX + 1 (saturating) = {saturated}")
}

routine test_s64_comparisons() {
    Console.show_line("\n=== s64 Comparison Operations ===")

    let x: s64 = 100_s64
    let y: s64 = 200_s64

    Console.show_line(f"{x} == {y}: {x == y}")
    Console.show_line(f"{x} != {y}: {x != y}")
    Console.show_line(f"{x} < {y}: {x < y}")
    Console.show_line(f"{x} <= {y}: {x <= y}")
    Console.show_line(f"{x} > {y}: {x > y}")
    Console.show_line(f"{x} >= {y}: {x >= y}")

    # min/max/clamp
    let min_val = x.min(y)
    let max_val = x.max(y)
    let clamped = 250_s64.clamp(100_s64, 200_s64)

    Console.show_line(f"min({x}, {y}) = {min_val}")
    Console.show_line(f"max({x}, {y}) = {max_val}")
    Console.show_line(f"clamp(250, 100, 200) = {clamped}")
}

routine test_s64_bitwise() {
    Console.show_line("\n=== s64 Bitwise Operations ===")

    let a: s64 = 0b1010_s64  # 10
    let b: s64 = 0b1100_s64  # 12

    Console.show_line(f"a & b = {a & b}")
    Console.show_line(f"a | b = {a | b}")
    Console.show_line(f"a ^ b = {a ^ b}")
    Console.show_line(f"~a = {~a}")

    # Shifts
    let shifted_left = a << 2_u32
    let shifted_right = a >> 1_u32
    Console.show_line(f"a << 2 = {shifted_left}")
    Console.show_line(f"a >> 1 = {shifted_right}")

    # Bit counting
    let value: s64 = 0b101010_s64
    Console.show_line(f"count_ones(0b101010) = {value.count_ones()}")
    Console.show_line(f"leading_zeros(0b101010) = {value.leading_zeros()}")
    Console.show_line(f"trailing_zeros(0b101010) = {value.trailing_zeros()}")
}

routine test_s64_conversions() {
    Console.show_line("\n=== s64 Type Conversions ===")

    let signed: s64 = -42_s64

    # To unsigned (reinterpret bits)
    let unsigned = signed.to_u64()
    Console.show_line(f"s64(-42) as u64 = {unsigned}")

    # To float
    let as_float = signed.to_f64()
    Console.show_line(f"s64(-42) as f64 = {as_float}")

    # To smaller types
    let as_s32 = signed.to_s32()
    Console.show_line(f"s64(-42) as s32 = {as_s32}")

    # Boolean conversion
    let zero: s64 = 0_s64
    let nonzero: s64 = 42_s64
    Console.show_line(f"0_s64.to_bool() = {zero.to_bool()}")
    Console.show_line(f"42_s64.to_bool() = {nonzero.to_bool()}")
}

routine test_s64_utilities() {
    Console.show_line("\n=== s64 Utility Methods ===")

    let pos: s64 = 42_s64
    let neg: s64 = -42_s64
    let zero: s64 = 0_s64

    Console.show_line(f"{pos}.is_positive() = {pos.is_positive()}")
    Console.show_line(f"{neg}.is_negative() = {neg.is_negative()}")
    Console.show_line(f"{zero}.is_zero() = {zero.is_zero()}")
    Console.show_line(f"{pos}.is_even() = {pos.is_even()}")
    Console.show_line(f"{pos}.is_odd() = {pos.is_odd()}")

    # Signum
    Console.show_line(f"signum({pos}) = {pos.signum()}")
    Console.show_line(f"signum({neg}) = {neg.signum()}")
    Console.show_line(f"signum({zero}) = {zero.signum()}")

    # Power of two check
    let power_of_two: s64 = 64_s64
    let not_power: s64 = 42_s64
    Console.show_line(f"{power_of_two}.is_power_of_two() = {power_of_two.is_power_of_two()}")
    Console.show_line(f"{not_power}.is_power_of_two() = {not_power.is_power_of_two()}")

    # Fibonacci example
    let fib_10 = fibonacci_s64(10_s64)
    Console.show_line(f"fibonacci(10) = {fib_10}")

    # GCD example
    let gcd_result = gcd_s64(48_s64, 18_s64)
    Console.show_line(f"gcd(48, 18) = {gcd_result}")
}

# ============================================================================
# u64 (Unsigned 64-bit Integer) Examples
# ============================================================================

routine test_u64_arithmetic() {
    Console.show_line("\n=== u64 Arithmetic Operations ===")

    let a: u64 = 100_u64
    let b: u64 = 42_u64

    # Basic arithmetic (same as s64 but unsigned semantics)
    let sum = a + b
    let diff = a - b
    let product = a * b
    let quotient = a / b
    let remainder = a % b

    Console.show_line(f"a + b = {sum}")
    Console.show_line(f"a - b = {diff}")
    Console.show_line(f"a * b = {product}")
    Console.show_line(f"a / b = {quotient}")
    Console.show_line(f"a % b = {remainder}")
}

routine test_u64_unsigned_features() {
    Console.show_line("\n=== u64 Unsigned-Specific Features ===")

    # Unsigned comparison (different from signed)
    let large: u64 = U64_MAX
    let small: u64 = 100_u64

    Console.show_line(f"U64_MAX > 100 (unsigned): {large > small}")

    # Wrapping subtraction (underflow)
    let zero: u64 = 0_u64
    let one: u64 = 1_u64
    let wrapped = zero - one
    Console.show_line(f"0 - 1 (wrapping) = {wrapped}")  # Should wrap to U64_MAX

    # Logical right shift (zero-fill)
    let value: u64 = U64_MAX
    let shifted = value >> 1_u32
    Console.show_line(f"U64_MAX >> 1 = {shifted}")
}

routine test_u64_power_of_two() {
    Console.show_line("\n=== u64 Power-of-Two Operations ===")

    let value: u64 = 64_u64
    let not_power: u64 = 42_u64

    Console.show_line(f"{value}.is_power_of_two() = {value.is_power_of_two()}")
    Console.show_line(f"{not_power}.is_power_of_two() = {not_power.is_power_of_two()}")

    # Next power of two
    let next = not_power.next_power_of_two()
    Console.show_line(f"next_power_of_two({not_power}) = {next}")
}

routine test_u64_rotations() {
    Console.show_line("\n=== u64 Rotation Operations ===")

    let value: u64 = 0b1010_u64

    let rotated_left = value.rotate_left(2_u32)
    let rotated_right = value.rotate_right(1_u32)

    Console.show_line(f"rotate_left(0b1010, 2) = {rotated_left}")
    Console.show_line(f"rotate_right(0b1010, 1) = {rotated_right}")
}

routine test_u64_bit_manipulation() {
    Console.show_line("\n=== u64 Bit Manipulation ===")

    let value: u64 = 0x12345678_u64

    # Byte swap (endianness conversion)
    let swapped = value.swap_bytes()
    Console.show_line(f"swap_bytes(0x12345678) = {swapped}")

    # Bit reversal
    let reversed = value.reverse_bits()
    Console.show_line(f"reverse_bits(0x12345678) = {reversed}")
}

routine test_u64_modular_exponentiation() {
    Console.show_line("\n=== u64 Modular Exponentiation ===")

    # Calculate 3^10 mod 7
    let result = modpow_u64(3_u64, 10_u64, 7_u64)
    Console.show_line(f"3^10 mod 7 = {result}")

    # Calculate 2^16 mod 100
    let result2 = modpow_u64(2_u64, 16_u64, 100_u64)
    Console.show_line(f"2^16 mod 100 = {result2}")
}

# ============================================================================
# f64 (Double-Precision Floating Point) Examples
# ============================================================================

routine test_f64_arithmetic() {
    Console.show_line("\n=== f64 Arithmetic Operations ===")

    let a: f64 = 3.14_f64
    let b: f64 = 2.71_f64

    # Basic arithmetic
    let sum = a + b
    let diff = a - b
    let product = a * b
    let quotient = a / b
    let remainder = a % b

    Console.show_line(f"a + b = {sum}")
    Console.show_line(f"a - b = {diff}")
    Console.show_line(f"a * b = {product}")
    Console.show_line(f"a / b = {quotient}")
    Console.show_line(f"a % b = {remainder}")

    # Negation
    let neg = -a
    Console.show_line(f"-a = {neg}")
}

routine test_f64_comparisons() {
    Console.show_line("\n=== f64 Comparison Operations ===")

    let x: f64 = 3.14_f64
    let y: f64 = 2.71_f64

    Console.show_line(f"{x} == {y}: {x == y}")
    Console.show_line(f"{x} != {y}: {x != y}")
    Console.show_line(f"{x} < {y}: {x < y}")
    Console.show_line(f"{x} <= {y}: {x <= y}")
    Console.show_line(f"{x} > {y}: {x > y}")
    Console.show_line(f"{x} >= {y}: {x >= y}")
}

routine test_f64_math_operations() {
    Console.show_line("\n=== f64 Math Operations ===")

    let value: f64 = 16.5_f64

    # Rounding operations
    Console.show_line(f"floor({value}) = {value.floor()}")
    Console.show_line(f"ceil({value}) = {value.ceil()}")
    Console.show_line(f"round({value}) = {value.round()}")
    Console.show_line(f"trunc({value}) = {value.trunc()}")

    # Absolute value
    let negative: f64 = -42.5_f64
    Console.show_line(f"abs({negative}) = {negative.abs()}")

    # Square root
    let sqrt_val = 25.0_f64.sqrt()
    Console.show_line(f"sqrt(25.0) = {sqrt_val}")
}

routine test_f64_trigonometric() {
    Console.show_line("\n=== f64 Trigonometric Functions ===")

    # Use π/4 ≈ 0.785398
    let angle: f64 = 0.785398_f64

    let sin_val = angle.sin()
    let cos_val = angle.cos()

    Console.show_line(f"sin(π/4) ≈ {sin_val}")
    Console.show_line(f"cos(π/4) ≈ {cos_val}")
}

routine test_f64_exponential_logarithmic() {
    Console.show_line("\n=== f64 Exponential and Logarithmic ===")

    let value: f64 = 2.0_f64

    # Exponential
    let exp_val = value.exp()
    Console.show_line(f"exp(2.0) = {exp_val}")

    # Natural logarithm
    let e: f64 = 2.71828_f64
    let log_val = e.log()
    Console.show_line(f"log(e) = {log_val}")

    # Base-10 logarithm
    let hundred: f64 = 100.0_f64
    let log10_val = hundred.log10()
    Console.show_line(f"log10(100.0) = {log10_val}")

    # Power
    let pow_val = 2.0_f64.pow(10.0_f64)
    Console.show_line(f"pow(2.0, 10.0) = {pow_val}")
}

routine test_f64_utility() {
    Console.show_line("\n=== f64 Utility Methods ===")

    let x: f64 = 3.14_f64
    let y: f64 = 2.71_f64

    # min/max/clamp
    let min_val = x.min(y)
    let max_val = x.max(y)
    let clamped = 5.0_f64.clamp(2.0_f64, 4.0_f64)

    Console.show_line(f"min({x}, {y}) = {min_val}")
    Console.show_line(f"max({x}, {y}) = {max_val}")
    Console.show_line(f"clamp(5.0, 2.0, 4.0) = {clamped}")

    # Checks
    let pos: f64 = 42.0_f64
    let neg: f64 = -42.0_f64
    let zero: f64 = 0.0_f64

    Console.show_line(f"{pos}.is_positive() = {pos.is_positive()}")
    Console.show_line(f"{neg}.is_negative() = {neg.is_negative()}")
    Console.show_line(f"{zero}.is_zero() = {zero.is_zero()}")

    # Signum
    Console.show_line(f"signum({pos}) = {pos.signum()}")
    Console.show_line(f"signum({neg}) = {neg.signum()}")
    Console.show_line(f"signum({zero}) = {zero.signum()}")

    # Copysign
    let magnitude: f64 = 42.0_f64
    let sign: f64 = -1.0_f64
    let result = magnitude.copysign(sign)
    Console.show_line(f"copysign(42.0, -1.0) = {result}")
}

routine test_f64_conversions() {
    Console.show_line("\n=== f64 Type Conversions ===")

    let float_val: f64 = 42.7_f64

    # Float to integer (truncates)
    let as_s64 = float_val.to_s64()
    let as_u64 = float_val.to_u64()
    Console.show_line(f"f64(42.7) as s64 = {as_s64}")
    Console.show_line(f"f64(42.7) as u64 = {as_u64}")

    # Float to smaller float
    let as_f32 = float_val.to_f32()
    Console.show_line(f"f64(42.7) as f32 = {as_f32}")

    # Bit manipulation (type punning)
    let bits = float_val.to_bits()
    Console.show_line(f"f64(42.7) to_bits = {bits}")

    let back = f64.from_bits(bits)
    Console.show_line(f"from_bits({bits}) = {back}")
}

routine test_f64_examples() {
    Console.show_line("\n=== f64 Real-World Examples ===")

    # Distance between two points
    let dist = distance_2d(0.0_f64, 0.0_f64, 3.0_f64, 4.0_f64)
    Console.show_line(f"distance((0,0), (3,4)) = {dist}")

    # Pythagorean theorem
    let hypotenuse = hypot(3.0_f64, 4.0_f64)
    Console.show_line(f"hypot(3.0, 4.0) = {hypotenuse}")

    # Linear interpolation
    let lerp_val = lerp(0.0_f64, 10.0_f64, 0.5_f64)
    Console.show_line(f"lerp(0.0, 10.0, 0.5) = {lerp_val}")
}

# ============================================================================
# Mixed Type Operations
# ============================================================================

routine test_mixed_type_conversions() {
    Console.show_line("\n=== Mixed Type Conversions ===")

    # s64 → u64 → f64
    let signed: s64 = 42_s64
    let unsigned = signed.to_u64()
    let floating = unsigned.to_f64()

    Console.show_line(f"s64(42) → u64 = {unsigned}")
    Console.show_line(f"u64(42) → f64 = {floating}")

    # f64 → s64 → u64
    let float_val: f64 = 42.7_f64
    let as_signed = float_val.to_s64()
    let as_unsigned = as_signed.to_u64()

    Console.show_line(f"f64(42.7) → s64 = {as_signed}")
    Console.show_line(f"s64(42) → u64 = {as_unsigned}")
}

# ============================================================================
# Main Entry Point
# ============================================================================

routine main() {
    Console.show_line("╔════════════════════════════════════════════════════╗")
    Console.show_line("║  RazorForge Primitive Types Demonstration         ║")
    Console.show_line("║  s64, u64, f64 with Intrinsic-Based Operations    ║")
    Console.show_line("╚════════════════════════════════════════════════════╝")

    # s64 tests
    test_s64_arithmetic()
    test_s64_overflow()
    test_s64_comparisons()
    test_s64_bitwise()
    test_s64_conversions()
    test_s64_utilities()

    # u64 tests
    test_u64_arithmetic()
    test_u64_unsigned_features()
    test_u64_power_of_two()
    test_u64_rotations()
    test_u64_bit_manipulation()
    test_u64_modular_exponentiation()

    # f64 tests
    test_f64_arithmetic()
    test_f64_comparisons()
    test_f64_math_operations()
    test_f64_trigonometric()
    test_f64_exponential_logarithmic()
    test_f64_utility()
    test_f64_conversions()
    test_f64_examples()

    # Mixed type tests
    test_mixed_type_conversions()

    Console.show_line("\n✓ All primitive type demonstrations completed!")
}

# RazorForge Compiler Integration Test
# Tests end-to-end compilation with memory slices, parser, AST, semantic analysis, and LLVM codegen

import stdlib/memory/HeapSlice
import stdlib/memory/StackSlice
import system/console/write_line

###
Tests basic parsing and compilation of slice constructors
###
recipe test_slice_constructors() {
    write_line("=== Testing Slice Constructors ===")

    # Test HeapSlice constructor parsing
    var heap_buffer = HeapSlice(128)
    write_line(f"HeapSlice created with size: {heap_buffer.size()}")

    # Test StackSlice constructor parsing
    var stack_buffer = StackSlice(64)
    write_line(f"StackSlice created with size: {stack_buffer.size()}")

    write_line("Slice constructor test completed\n")
}

###
Tests generic method call parsing and compilation
###
recipe test_generic_methods() {
    write_line("=== Testing Generic Methods ===")

    var buffer = HeapSlice(32)

    # Test generic write method
    buffer.write<s32>!(0, 42)
    buffer.write<s32>!(4, 100)
    buffer.write<f32>!(8, 3.14f)

    # Test generic read method
    let int_val = buffer.read<s32>!(0)
    let int_val2 = buffer.read<s32>!(4)
    let float_val = buffer.read<f32>!(8)

    write_line(f"Read s32 values: {int_val}, {int_val2}")
    write_line(f"Read f32 value: {float_val}")

    write_line("Generic method test completed\n")
}

###
Tests memory operation parsing and compilation
###
recipe test_memory_operations() {
    write_line("=== Testing Memory Operations ===")

    var buffer = StackSlice(48)

    # Test memory operation methods
    let size = buffer.size!()
    let addr = buffer.address!()
    let valid = buffer.is_valid!()
    let ptr = buffer.unsafe_ptr!(16)

    write_line(f"Buffer size: {size}")
    write_line(f"Buffer address: 0x{addr:x}")
    write_line(f"Buffer valid: {valid}")
    write_line(f"Unsafe ptr at offset 16: 0x{ptr:x}")

    # Test sub-slicing
    let sub_buffer = buffer.slice!(8, 32)
    write_line(f"Sub-slice size: {sub_buffer.size!()}")

    write_line("Memory operation test completed\n")
}

###
Tests external recipe declarations and linking
###
recipe test_external_functions() {
    write_line("=== Testing External Functions ===")

    # These external functions should be linked from C runtime
    let allocated_ptr = heap_alloc!(256)
    write_line(f"Heap allocated at: 0x{allocated_ptr:x}")

    # Test memory operations
    write_as<s64>!(allocated_ptr, 0xDEADBEEFCAFEBABE)
    let read_value = read_as<s64>!(allocated_ptr)
    write_line(f"Written and read value: 0x{read_value:x}")

    heap_free!(allocated_ptr)
    write_line("External recipe test completed\n")
}

###
Tests danger block parsing and compilation
###
recipe test_danger_blocks() {
    write_line("=== Testing Danger Blocks ===")

    var buffer = HeapSlice(64)

    danger! {
        # Test raw memory access in danger block
        let raw_addr = buffer.address!()

        # Direct memory writes bypassing bounds checking
        write_as<u64>!(raw_addr, 0x123456789ABCDEF0)
        write_as<u64>!(raw_addr + 8, 0xFEDCBA9876543210)

        # Direct memory reads
        let val1 = read_as<u64>!(raw_addr)
        let val2 = read_as<u64>!(raw_addr + 8)

        write_line(f"Raw read 1: 0x{val1:x}")
        write_line(f"Raw read 2: 0x{val2:x}")

        # Test addr_of operation
        let local_var: s32 = 999
        let var_addr = addr_of!(local_var)
        write_line(f"Local variable address: 0x{var_addr:x}")
    }

    write_line("Danger block test completed\n")
}

###
Tests memory wrapper operations and safety
###
recipe test_wrapper_operations() {
    write_line("=== Testing Wrapper Operations ===")

    var original = HeapSlice(96)
    original.write<s64>!(0, 1000)
    original.write<s64>!(8, 2000)

    # Test hijack operation (exclusive access)
    let hijacked = original.hijack!()
    write_line("Buffer hijacked successfully")

    # Test refer operation (get raw reference)
    let raw_ref = hijacked.refer!()
    write_line(f"Raw reference: 0x{raw_ref:x}")

    write_line("Wrapper operation test completed\n")
}

###
Tests comprehensive memory management scenarios
###
recipe test_memory_management() {
    write_line("=== Testing Memory Management ===")

    # Create multiple slices
    var heap1 = HeapSlice(128)
    var heap2 = HeapSlice(256)
    var stack1 = StackSlice(64)

    # Fill with test data
    for i in 0 to 16 {
        heap1.write<s32>!(i * 4, i * 10)
        heap2.write<s32>!(i * 4, i * 20)
        stack1.write<s32>!(i * 4, i * 30)
    }

    # Test copying between slices
    heap2.copy_from_stack!(stack1, 0, 128, 64)
    write_line("Copied data from stack to heap")

    # Test resizing
    heap1.resize!(256)
    write_line(f"Resized heap1 to: {heap1.size!()} bytes")

    # Test pattern operations
    heap2.fill!(0xAA)
    write_line("Filled heap2 with pattern")

    heap2.zero!()
    write_line("Zeroed heap2")

    write_line("Memory management test completed\n")
}

###
Main test runner that exercises the complete compiler pipeline
@return Exit code (0 for success, 1 for failure)
###
recipe main() -> s32 {
    write_line("RazorForge Compiler Integration Test Suite")
    write_line("==========================================")
    write_line("Testing: Parser â†’ AST â†’ Semantic Analysis â†’ LLVM IR â†’ Native Runtime")
    write_line("==========================================\n")

    # Run all test suites
    test_slice_constructors()
    test_generic_methods()
    test_memory_operations()
    test_external_functions()
    test_danger_blocks()
    test_wrapper_operations()
    test_memory_management()

    write_line("=== All Integration Tests Completed ===")
    write_line("If you see this message, the entire compiler pipeline is working:")
    write_line("  âœ“ Parser successfully parsed all RazorForge syntax")
    write_line("  âœ“ AST nodes created for all memory slice operations")
    write_line("  âœ“ Semantic analyzer validated memory safety")
    write_line("  âœ“ LLVM code generator emitted valid IR")
    write_line("  âœ“ Native runtime linked and executed successfully")
    write_line("")
    write_line("ðŸŽ‰ RazorForge Memory Slice Integration Complete! ðŸŽ‰")

    return 0
}
# RazorForge Memory Slice Test
# Tests StackSlice and HeapSlice functionality with memory operations

import stdlib/memory/StackSlice
import stdlib/memory/HeapSlice
import system/console/write_line

###
Tests basic StackSlice operations on stack memory
###
recipe test_stack_slice() {
    write_line("=== Testing StackSlice ===")

    # Create a stack slice for 40 bytes (10 s32 integers)
    var stack_buffer = StackSlice(40)

    # Write integers to stack memory
    for i in 0 to 10 {
        let offset = i * sizeof<s32>()
        stack_buffer.write<s32>!(offset, (i * 2) as s32)
    }

    # Read back and verify
    for i in 0 to 10 {
        let offset = i * sizeof<s32>()
        let value = stack_buffer.read<s32>!(offset)
        write_line(f"stack[{i}] = {value}")
    }

    # Test sub-slicing
    let sub_slice = stack_buffer.slice!(8, 20)  # Skip first 2 integers, take 5
    write_line(f"Sub-slice size: {sub_slice.size()} bytes")

    # Test unsafe pointer access
    let unsafe_addr = stack_buffer.unsafe_ptr!(0)
    write_line(f"Stack buffer address: 0x{unsafe_addr:x}")

    write_line("StackSlice test completed\n")
}

###
Tests basic HeapSlice operations on heap memory
###
recipe test_heap_slice() {
    write_line("=== Testing HeapSlice ===")

    # Create a heap slice for 32 bytes (8 f32 floats)
    var heap_buffer = HeapSlice(32)

    # Write float values
    let float_values = [3.14159f, 2.71828f, 1.41421f, 1.61803f,
                       0.57721f, 9.80665f, 6.62607f, 2.99792f]

    for i in 0 to 8 {
        let offset = i * sizeof<f32>()
        heap_buffer.write<f32>!(offset, float_values[i])
    }

    write_line(f"Heap buffer size: {heap_buffer.size()} bytes")
    write_line(f"Heap buffer address: 0x{heap_buffer.address():x}")

    # Read back values
    for i in 0 to 8 {
        let offset = i * sizeof<f32>()
        let value = heap_buffer.read<f32>!(offset)
        write_line(f"heap[{i}] = {value}")
    }

    # Test resize operation
    heap_buffer.resize!(64)  # Double the size
    write_line(f"After resize: {heap_buffer.size()} bytes")

    # Add more values in new space
    for i in 8 to 16 {
        let offset = i * sizeof<f32>()
        heap_buffer.write<f32>!(offset, (i as f32) * 100.0f)
    }

    write_line("HeapSlice test completed\n")
}

###
Tests memory operations between stack and heap
###
recipe test_memory_operations() {
    write_line("=== Testing Memory Operations ===")

    # Create both stack and heap buffers
    var stack_data = StackSlice(20)  # 5 s32 values
    var heap_data = HeapSlice(20)    # 5 s32 values

    # Fill stack with data
    for i in 0 to 5 {
        let offset = i * sizeof<s32>()
        stack_data.write<s32>!(offset, (i * 10) as s32)
    }

    # Copy from stack to heap
    heap_data.copy_from_stack!(stack_data, 0, 0, 20)

    # Verify copy worked
    write_line("Copied values from stack to heap:")
    for i in 0 to 5 {
        let offset = i * sizeof<s32>()
        let stack_val = stack_data.read<s32>!(offset)
        let heap_val = heap_data.read<s32>!(offset)
        write_line(f"  [{i}] stack={stack_val}, heap={heap_val}")
    }

    # Test hijack operation
    var new_owner = HeapSlice(0)
    new_owner.hijack!(heap_data)
    write_line(f"After hijack, new owner size: {new_owner.size()}")
    write_line(f"Original heap size: {heap_data.size()}")  # Should be 0

    write_line("Memory operations test completed\n")
}

###
Demonstrates wrapper type operations
###
recipe test_wrapper_operations() {
    write_line("=== Testing Wrapper Operations ===")

    # Create heap slice for integers
    var original = HeapSlice(12)  # 3 s32 values
    original.write<s32>!(0, 100)
    original.write<s32>!(4, 200)
    original.write<s32>!(8, 300)

    # Test refer! operation
    let raw_addr = original.refer!()
    write_line(f"Raw memory reference: 0x{raw_addr:x}")

    # Test memory pattern operations
    var pattern_buffer = HeapSlice(256)
    pattern_buffer.fill!(0xAA)  # Fill with alternating bit pattern

    let first_byte = pattern_buffer.read<u8>!(0)
    let last_byte = pattern_buffer.read<u8>!(255)
    write_line(f"Pattern fill - first: 0x{first_byte:x}, last: 0x{last_byte:x}")

    # Test zero operation
    pattern_buffer.zero!()
    let zero_byte = pattern_buffer.read<u8>!(128)
    write_line(f"After zero: middle byte = 0x{zero_byte:x}")

    write_line("Wrapper operations test completed\n")
}

###
Main test runner
@return Exit code (0 for success)
###
recipe main() -> s32 {
    write_line("RazorForge Memory Slice Test Suite")
    write_line("==================================\n")

    test_stack_slice()
    test_heap_slice()
    test_memory_operations()
    test_wrapper_operations()

    write_line("All tests completed successfully!")
    return 0
}